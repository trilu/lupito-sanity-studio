"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var jsxRuntime = require("react/jsx-runtime"), sanity = require("sanity"), ui = require("@sanity/ui"), react = require("react"), structure = require("sanity/structure"), dateFns = require("date-fns"), icons = require("@sanity/icons"), mutator = require("@sanity/mutator"), styledComponents = require("styled-components"), operators = require("rxjs/operators"), get = require("lodash/get.js"), isEqual = require("react-fast-compare"), rxjs = require("rxjs"), rxjsExhaustmapWithTrailing = require("rxjs-exhaustmap-with-trailing");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var get__default = /* @__PURE__ */ _interopDefaultCompat(get), isEqual__default = /* @__PURE__ */ _interopDefaultCompat(isEqual);
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("hidden") || overflow.includes("scroll");
}
function useRegionRects() {
  const ref = react.useRef(null), [relativeBoundsRect, setRelativeBoundsRect] = react.useState(null), [relativeElementRect, setRelativeElementRect] = react.useState(null), [boundsScroll, setBoundsScroll] = react.useState({ x: 0, y: 0 }), [scroll, setScroll] = react.useState({ x: 0, y: 0 }), boundsScrollXRef = react.useRef(0), boundsScrollYRef = react.useRef(0), elementScrollXRef = react.useRef(0), elementScrollYRef = react.useRef(0);
  react.useEffect(() => {
    const el = ref.current;
    if (!el) return;
    const scrollParents = [];
    let parent = el.parentElement;
    for (; parent && parent !== document.body; )
      hasOverflowScroll(parent) && scrollParents.push(parent), parent = parent.parentElement;
    function handleResize() {
      const boundsRect = scrollParents[0]?.getBoundingClientRect() || {
        x: 0,
        y: 0,
        width: window.innerWidth,
        height: window.innerHeight
      }, domRect = el.getBoundingClientRect();
      setRelativeBoundsRect({
        x: boundsRect.x + boundsScrollXRef.current,
        y: boundsRect.y + boundsScrollYRef.current,
        w: boundsRect.width,
        h: boundsRect.height
      }), setRelativeElementRect({
        x: domRect.x + elementScrollXRef.current,
        y: domRect.y + elementScrollYRef.current,
        w: domRect.width,
        h: domRect.height
      });
    }
    function handleScroll() {
      let scrollX = window.scrollX, scrollY = window.scrollY;
      for (const scrollParent2 of scrollParents)
        scrollX += scrollParent2.scrollLeft, scrollY += scrollParent2.scrollTop;
      const scrollParent = scrollParents[0];
      boundsScrollXRef.current = scrollX - (scrollParent?.scrollLeft || window.scrollX), boundsScrollYRef.current = scrollY - (scrollParent?.scrollTop || window.scrollY), setBoundsScroll({
        x: boundsScrollXRef.current,
        y: boundsScrollYRef.current
      }), elementScrollXRef.current = scrollX, elementScrollYRef.current = scrollY, setScroll({ x: scrollX, y: scrollY });
    }
    window.addEventListener("scroll", handleScroll, { passive: !0 });
    const ro = new ResizeObserver(handleResize);
    ro.observe(el);
    for (const scrollParent of scrollParents)
      scrollParent.addEventListener("scroll", handleScroll, { passive: !0 }), ro.observe(scrollParent);
    return handleScroll(), () => {
      ro.unobserve(el);
      for (const scrollParent of scrollParents)
        ro.unobserve(scrollParent), scrollParent.removeEventListener("scroll", handleScroll);
      ro.disconnect(), window.removeEventListener("scroll", handleScroll);
    };
  }, []);
  const bounds = react.useMemo(
    () => relativeBoundsRect && {
      x: relativeBoundsRect.x - boundsScroll.x,
      y: relativeBoundsRect.y - boundsScroll.y,
      w: relativeBoundsRect.w,
      h: relativeBoundsRect.h
    },
    [relativeBoundsRect, boundsScroll]
  ), element = react.useMemo(
    () => relativeElementRect && {
      x: relativeElementRect.x - scroll.x,
      y: relativeElementRect.y - scroll.y,
      w: relativeElementRect.w,
      h: relativeElementRect.h
    },
    [relativeElementRect, scroll]
  );
  return { bounds, element, ref };
}
function ConnectorRegion(props) {
  const { children, onRectsChange, ...restProps } = props, { bounds, element, ref } = useRegionRects();
  return react.useEffect(() => {
    onRectsChange?.(bounds && element ? { bounds, element } : null);
  }, [bounds, element, onRectsChange]), /* @__PURE__ */ jsxRuntime.jsx("div", { ...restProps, ref, children });
}
const ConnectorsStoreContext = react.createContext(null);
function useConnectorsStore() {
  const store = react.useContext(ConnectorsStoreContext);
  if (!store)
    throw new Error("Missing connectors store context");
  return store;
}
function ConnectFromRegion(props) {
  const { children, _key: key, zIndex, ...restProps } = props, store = useConnectorsStore(), [rects, setRects] = react.useState(null);
  return react.useEffect(() => store.from.subscribe(key, { zIndex }), [key, store, zIndex]), react.useEffect(() => {
    rects && store.from.next(key, rects);
  }, [key, rects, store]), /* @__PURE__ */ jsxRuntime.jsx(ConnectorRegion, { ...restProps, onRectsChange: setRects, children });
}
function createConnectorsStore() {
  const configKeys = [], fieldKeys = [], channels = {
    from: /* @__PURE__ */ new Map(),
    to: /* @__PURE__ */ new Map()
  }, payloads = {
    from: /* @__PURE__ */ new Map(),
    to: /* @__PURE__ */ new Map()
  }, observers = [];
  function notifyObservers() {
    const connectors = [];
    for (const key of configKeys) {
      const toRects = channels.to.get(key), toPayload = payloads.from.get(key), fromRects = channels.from.get(key), fromPayload = payloads.from.get(key);
      toRects && fromRects && connectors.push({
        key,
        from: { ...fromRects, payload: fromPayload },
        to: { ...toRects, payload: toPayload }
      });
    }
    for (const observer of observers)
      observer(connectors);
  }
  return {
    to: {
      subscribe(key, payload) {
        return channels.to.set(key, null), payloads.to.set(key, payload), configKeys.push(key), () => {
          channels.to.delete(key), payloads.to.delete(key);
          const idx = configKeys.indexOf(key);
          idx > -1 && configKeys.splice(idx, 1), notifyObservers();
        };
      },
      next(key, rects) {
        channels.to.set(key, rects), fieldKeys.includes(key) && notifyObservers();
      }
    },
    connectors: {
      subscribe(observer) {
        return observers.push(observer), () => {
          const idx = observers.indexOf(observer);
          idx > -1 && observers.splice(idx, 1);
        };
      }
    },
    from: {
      subscribe(key, payload) {
        return channels.from.set(key, null), payloads.from.set(key, payload), fieldKeys.push(key), () => {
          channels.from.delete(key), payloads.from.delete(key);
          const idx = fieldKeys.indexOf(key);
          idx > -1 && fieldKeys.splice(idx, 1), notifyObservers();
        };
      },
      next(key, rects) {
        channels.from.set(key, rects), configKeys.includes(key) && notifyObservers();
      }
    }
  };
}
function ConnectorsProvider(props) {
  const { children, onConnectorsChange } = props, store = react.useMemo(() => createConnectorsStore(), []);
  return react.useEffect(
    () => onConnectorsChange && store.connectors.subscribe(onConnectorsChange),
    [onConnectorsChange, store]
  ), /* @__PURE__ */ jsxRuntime.jsx(ConnectorsStoreContext.Provider, { value: store, children });
}
function getConnectorLinePoint(options2, rect, bounds) {
  const centerY = rect.y + rect.h / 2, isAbove = rect.y + rect.h < bounds.y + options2.arrow.marginY, isBelow = rect.y > bounds.y + bounds.h - options2.arrow.marginY;
  return {
    bounds,
    x: rect.x,
    y: centerY,
    centerY,
    startY: rect.y + options2.path.marginY,
    endY: rect.y + rect.h - options2.path.marginY,
    isAbove,
    isBelow,
    outOfBounds: isAbove || isBelow
  };
}
function mapConnectorToLine(options2, connector) {
  const fromBounds = {
    y: connector.from.bounds.y + options2.arrow.threshold,
    // bottom: connector.from.bounds.y + connector.from.bounds.h - options.arrow.threshold,
    x: connector.from.bounds.x,
    // right: connector.from.bounds.x + connector.from.bounds.w,
    w: connector.from.bounds.w,
    h: connector.from.bounds.h - options2.arrow.threshold * 2
  }, from = getConnectorLinePoint(options2, connector.from.element, fromBounds);
  from.x = connector.from.element.x + connector.from.element.w;
  const fromBottom = fromBounds.y + fromBounds.h, toBounds = {
    y: connector.to.bounds.y + options2.arrow.threshold,
    // bottom: connector.to.bounds.y + connector.to.bounds.h - options.arrow.threshold,
    x: connector.to.bounds.x,
    // right: connector.to.bounds.x + connector.to.bounds.w,
    w: connector.to.bounds.w,
    h: connector.to.bounds.h - options2.arrow.threshold * 2
  }, toBottom = toBounds.y + toBounds.h, to = getConnectorLinePoint(options2, connector.to.element, toBounds), maxStartY = Math.max(to.startY, from.startY);
  return from.y = Math.min(maxStartY, from.endY), from.y < toBounds.y ? from.y = Math.min(toBounds.y, from.endY) : from.y > toBottom && (from.y = Math.max(toBottom, from.startY)), to.y = Math.min(maxStartY, to.endY), to.y < fromBounds.y ? to.y = Math.min(fromBounds.y, to.endY) : to.y > fromBottom && (to.y = Math.max(fromBottom, to.startY)), from.y = Math.min(Math.max(from.y, fromBounds.y), fromBottom), to.y = Math.min(Math.max(to.y, toBounds.y), toBottom), { from, to };
}
const assistFormId = "assist", assistDocumentIdPrefix = "sanity.assist.schemaType.", assistDocumentStatusIdPrefix = "sanity.assist.status.", assistSchemaIdPrefix = "sanity.assist.schema.", assistDocumentTypeName = "sanity.assist.schemaType.annotations", assistFieldTypeName = "sanity.assist.schemaType.field", instructionTypeName = "sanity.assist.instruction", promptTypeName = "sanity.assist.instruction.prompt", userInputTypeName = "sanity.assist.instruction.userInput", instructionContextTypeName = "sanity.assist.instruction.context", fieldReferenceTypeName = "sanity.assist.instruction.fieldRef", contextDocumentTypeName = "assist.instruction.context", assistTasksStatusTypeName = "sanity.assist.task.status", instructionTaskTypeName = "sanity.assist.instructionTask", fieldPresenceTypeName = "sanity.assist.instructionTask.presence", assistSerializedTypeName = "sanity.assist.serialized.type", assistSerializedFieldTypeName = "sanity.assist.serialized.field", outputFieldTypeName = "sanity.assist.output.field", outputTypeTypeName = "sanity.assist.output.type", fieldPathParam = "pathKey", instructionParam = "instruction", documentRootKey = "<document>";
function usePathKey(path) {
  return react.useMemo(() => getPathKey(path), [path]);
}
function getPathKey(path) {
  return path.length ? Array.isArray(path) ? sanity.pathToString(path) : path : documentRootKey;
}
function getInstructionTitle(instruction2) {
  return instruction2?.title ?? "Untitled";
}
function isDefined(t) {
  return t != null;
}
function isPortableTextArray(type) {
  return type.of.find((t) => isType(t, "block"));
}
function isType(schemaType, typeName) {
  return schemaType.name === typeName ? !0 : schemaType.type ? isType(schemaType.type, typeName) : !1;
}
function isImage(schemaType) {
  return isType(schemaType, "image");
}
function getDescriptionFieldOption(schemaType) {
  if (!schemaType)
    return;
  const descriptionField = schemaType.options?.aiAssist?.imageDescriptionField;
  return typeof descriptionField == "string" ? {
    path: descriptionField,
    updateOnImageChange: !0
  } : descriptionField ? {
    path: descriptionField.path,
    updateOnImageChange: descriptionField.updateOnImageChange ?? !0
  } : getDescriptionFieldOption(schemaType.type);
}
function getImageInstructionFieldOption(schemaType) {
  return schemaType ? schemaType.options?.aiAssist?.imageInstructionField || getImageInstructionFieldOption(schemaType.type) : void 0;
}
function isSchemaAssistEnabled(type) {
  return !type.options?.aiAssist?.exclude;
}
function isAssistSupported(type) {
  return !isSchemaAssistEnabled(type) || isDisabled(type) ? !1 : type.jsonType === "array" ? !type.of.every((t) => isDisabled(t)) : type.jsonType === "object" ? !type.fields.every((field) => isDisabled(field.type)) || /* to allow attaching custom actions on fieldless images */
  isType(type, "image") : !0;
}
function isDisabled(type) {
  return !isSchemaAssistEnabled(type) || isUnsupportedType(type);
}
function isUnsupportedType(type) {
  return type.name === "sanity.imageCrop" || type.name === "sanity.imageHotspot" || isType(type, "globalDocumentReference") || isType(type, "reference") && !type?.options?.aiAssist?.embeddingsIndex || isType(type, "crossDatasetReference") || isType(type, "file");
}
const FirstAssistedPathContext = react.createContext(void 0);
function FirstAssistedPathProvider(props) {
  const { members } = props, firstAssistedPath = react.useMemo(() => {
    const firstAssisted = members.find(
      (member) => member.kind === "field" && isAssistSupported(member.field.schemaType)
    );
    return firstAssisted?.field.path ? sanity.pathToString(firstAssisted?.field.path) : void 0;
  }, [members]);
  return /* @__PURE__ */ jsxRuntime.jsx(FirstAssistedPathContext.Provider, { value: firstAssistedPath, children: props.children });
}
const releaseAnnouncementUrl = "https://www.sanity.io/blog/sanity-ai-assist-announcement?utm_source=sanity-assist-plugin&utm_medium=organic_social&utm_campaign=ai-assist&utm_content=", instructionGuideUrl = "https://sanity.io/guides/getting-started-with-ai-assist-instructions?utm_source=sanity-assist-plugin&utm_medium=organic_social&utm_campaign=ai-assist&utm_content=", giveFeedbackUrl = "https://forms.gle/Kwz7CThxGeA2GiEU8", salesUrl = "https://www.sanity.io/contact/sales?utm_source=sanity-assist-plugin&utm_medium=organic_social&utm_campaign=ai-assist&utm_content=", packageName = "@sanity/assist", pluginTitle = "Sanity AI Assist", pluginTitleShort = "AI Assist", maxHistoryVisibilityMs = dateFns.minutesToMilliseconds(30), illegalIdChars = /[^a-zA-Z0-9._-]/g;
function assistDocumentId(documentType) {
  return `${assistDocumentIdPrefix}${documentType}`.replace(illegalIdChars, "_");
}
function assistTasksStatusId(documentId) {
  return sanity.isVersionId(documentId) ? `${assistDocumentStatusIdPrefix}${sanity.getVersionFromId(documentId)}.${sanity.getPublishedId(documentId)}` : `${assistDocumentStatusIdPrefix}${sanity.getPublishedId(documentId)}`;
}
function useDocumentState(id, docType) {
  const state = sanity.useEditState(id, docType);
  return state.draft || state.published;
}
function useStudioAssistDocument({
  documentId,
  schemaType,
  initDoc
}) {
  const documentTypeName = schemaType.name, currentUser = sanity.useCurrentUser(), assistDocument = useDocumentState(
    assistDocumentId(documentTypeName),
    assistDocumentTypeName
  ), assistTasksStatus = useDocumentState(
    assistTasksStatusId(documentId ?? ""),
    assistTasksStatusTypeName
  ), client = sanity.useClient({ apiVersion: "2023-01-01" });
  return react.useEffect(() => {
    !assistDocument && initDoc && client.createIfNotExists({
      _id: assistDocumentId(documentTypeName),
      _type: assistDocumentTypeName
    }).catch(() => {
    });
  }, [client, assistDocument, documentTypeName, initDoc]), react.useMemo(() => {
    if (!assistDocument)
      return;
    const tasks = assistTasksStatus?.tasks ?? [], fields = (assistDocument?.fields ?? []).map((assistField) => ({
      ...assistField,
      tasks: tasks.filter((task) => task.path === assistField.path),
      instructions: assistField.instructions?.filter((p) => !p.userId || p.userId === currentUser?.id).map((instruction2) => asStudioInstruction(instruction2, tasks))
    }));
    return sanity.typed({
      ...assistDocument,
      tasks: tasks?.map((task) => {
        const instruction2 = fields.find((f) => f.path === task.path)?.instructions?.find((i) => i._key === task.instructionKey);
        return {
          ...task,
          instruction: instruction2
        };
      }),
      fields
    });
  }, [assistDocument, assistTasksStatus, currentUser]);
}
function asStudioInstruction(instruction2, run) {
  return {
    ...instruction2,
    tasks: run.filter((task) => task.instructionKey === instruction2._key).filter(
      (task) => task.started && (/* @__PURE__ */ new Date()).getTime() - new Date(task.started).getTime() < maxHistoryVisibilityMs
    )
  };
}
const NO_TASKS = [];
function useInstructionToaster(documentId, documentSchemaType) {
  const assistDocument = useStudioAssistDocument({ documentId, schemaType: documentSchemaType }), assistDocLoaded = !!assistDocument, currentUser = sanity.useCurrentUser(), toast = ui.useToast(), tasks = assistDocument?.tasks, previousTasks = react.useRef("initial");
  react.useEffect(() => {
    if (assistDocLoaded) {
      if (previousTasks.current !== "initial") {
        const prevTaskByKey = Object.fromEntries(
          (previousTasks.current ?? NO_TASKS).map((run) => [run._key, run])
        );
        tasks?.filter((task) => task.startedByUserId === currentUser?.id).filter((task) => {
          const prevTask = prevTaskByKey[task._key];
          return !prevTask && task.ended || !prevTask?.ended && task.ended;
        }).filter((task) => task.ended && dateFns.isAfter(dateFns.addSeconds(new Date(task.ended), 30), /* @__PURE__ */ new Date()))?.forEach((task) => {
          const title = task.title ?? getInstructionTitle(task.instruction);
          task.reason === "error" ? toast.push({
            title: `Failed: ${title}`,
            status: "error",
            description: `Instruction failed. ${task.message ?? ""}`,
            closable: !0,
            duration: 1e4
          }) : task.reason === "timeout" ? toast.push({
            title: `Timeout: ${title}`,
            status: "error",
            description: "Instruction timed out.",
            closable: !0
          }) : task.reason === "success" ? toast.push({
            title: `Success: ${title}`,
            status: "success",
            description: "Instruction completed.",
            closable: !0
          }) : task.reason === "aborted" && toast.push({
            title: `Canceled: ${title}`,
            status: "warning",
            description: "Instruction canceled.",
            closable: !0
          });
        });
      }
      previousTasks.current = tasks;
    }
  }, [tasks, previousTasks, toast, currentUser, assistDocLoaded]);
}
function AssistDocumentInputWrapper(props) {
  if (!isType(props.schemaType, "document") && props.id !== "root" && props.id !== assistFormId)
    return /* @__PURE__ */ jsxRuntime.jsx(AssistInput, { ...props });
  const documentId = props.value?._id;
  return documentId ? /* @__PURE__ */ jsxRuntime.jsx(AssistDocumentInput, { ...props, documentId }) : props.renderDefault(props);
}
function AssistDocumentInput({ documentId, ...props }) {
  useInstructionToaster(documentId, props.schemaType);
  const schemaType = react.useMemo(() => props.schemaType.name !== assistDocumentTypeName ? props.schemaType : {
    ...props.schemaType,
    type: {
      ...props.schemaType.type,
      // compatability with i18nArrays plugin that requires this to be document
      name: "document"
    }
  }, [props.schemaType]);
  return /* @__PURE__ */ jsxRuntime.jsx(FirstAssistedPathProvider, { members: props.members, children: props.renderDefault({ ...props, schemaType }) });
}
function AssistInput(props) {
  const { zIndex } = ui.useLayer(), { paneKey } = structure.useDocumentPane(), pathKey = usePathKey(props.path);
  return /* @__PURE__ */ jsxRuntime.jsx(ConnectFromRegion, { _key: `${paneKey}_${pathKey}`, zIndex, style: { minWidth: 0 }, children: props.renderDefault(props) });
}
const AssistDocumentContext = react.createContext(
  void 0
);
function useAssistDocumentContext() {
  const context = react.useContext(AssistDocumentContext);
  if (!context)
    throw new Error("AssistDocumentContext value is missing");
  return context;
}
const AiAssistanceConfigContext = react.createContext({});
function useAiAssistanceConfig() {
  const context = react.useContext(AiAssistanceConfigContext);
  if (!context)
    throw new Error("Missing AiAssistanceConfigContext");
  return context;
}
function useSerializedTypes() {
  return useAiAssistanceConfig().serializedTypes;
}
const basePath = "/assist/tasks/instruction", API_VERSION_WITH_EXTENDED_TYPES = "2025-04-01";
function canUseAssist(status) {
  return status?.enabled && status.initialized && status.validToken;
}
function useApiClient(customApiClient) {
  const client = sanity.useClient({ apiVersion: API_VERSION_WITH_EXTENDED_TYPES });
  return react.useMemo(
    () => customApiClient ? customApiClient(client) : client,
    [client, customApiClient]
  );
}
function useTranslate(apiClient) {
  const [loading, setLoading] = react.useState(!1), user = sanity.useCurrentUser(), types = useSerializedTypes(), toast = ui.useToast(), translate = react.useCallback(
    ({
      documentId,
      languagePath,
      styleguide,
      translatePath,
      fieldLanguageMap,
      conditionalMembers
    }) => {
      setLoading(!0);
      async function run() {
        return apiClient.request({
          method: "POST",
          url: `/assist/tasks/translate/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
          body: {
            documentId,
            types,
            languagePath,
            userStyleguide: await styleguide(),
            fieldLanguageMap,
            conditionalMembers,
            translatePath: translatePath.length === 0 ? documentRootKey : sanity.pathToString(translatePath),
            userId: user?.id
          }
        });
      }
      return run().catch((e) => {
        throw toast.push({
          status: "error",
          title: "Translate failed",
          description: e.message
        }), setLoading(!1), e;
      }).finally(() => {
        setTimeout(() => {
          setLoading(!1);
        }, 2e3);
      });
    },
    [setLoading, apiClient, toast, user, types]
  );
  return react.useMemo(
    () => ({
      translate,
      loading
    }),
    [translate, loading]
  );
}
function useGenerateCaption(apiClient) {
  const [loading, setLoading] = react.useState(!1), user = sanity.useCurrentUser(), types = useSerializedTypes(), toast = ui.useToast(), generateCaption = react.useCallback(
    ({ path, documentId }) => (setLoading(!0), apiClient.request({
      method: "POST",
      url: `/assist/tasks/generate-caption/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
      body: {
        path,
        documentId,
        types,
        userId: user?.id
      }
    }).catch((e) => {
      throw toast.push({
        status: "error",
        title: "Generate image description failed",
        description: e.message
      }), setLoading(!1), e;
    }).finally(() => {
      setTimeout(() => {
        setLoading(!1);
      }, 2e3);
    })),
    [setLoading, apiClient, toast, user, types]
  );
  return react.useMemo(
    () => ({
      generateCaption,
      loading
    }),
    [generateCaption, loading]
  );
}
function useGenerateImage(apiClient) {
  const [loading, setLoading] = react.useState(!1), user = sanity.useCurrentUser(), types = useSerializedTypes(), toast = ui.useToast(), generateImage = react.useCallback(
    ({ path, documentId }) => (setLoading(!0), apiClient.request({
      method: "POST",
      url: `/assist/tasks/generate-image/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
      body: {
        path,
        documentId,
        types,
        userId: user?.id
      }
    }).catch((e) => {
      throw toast.push({
        status: "error",
        title: "Generate image from prompt failed",
        description: e.message
      }), setLoading(!1), e;
    }).finally(() => {
      setTimeout(() => {
        setLoading(!1);
      }, 2e3);
    })),
    [setLoading, apiClient, toast, user, types]
  );
  return react.useMemo(
    () => ({
      generateImage,
      loading
    }),
    [generateImage, loading]
  );
}
function useGetInstructStatus(apiClient) {
  const [loading, setLoading] = react.useState(!0), getInstructStatus = react.useCallback(async () => {
    setLoading(!0);
    const projectId = apiClient.config().projectId;
    try {
      return await apiClient.request({
        method: "GET",
        url: `${basePath}/${apiClient.config().dataset}/status?projectId=${projectId}`
      });
    } finally {
      setLoading(!1);
    }
  }, [setLoading, apiClient]);
  return {
    loading,
    getInstructStatus
  };
}
function useInitInstruct(apiClient) {
  const [loading, setLoading] = react.useState(!1), initInstruct = react.useCallback(() => (setLoading(!0), apiClient.request({
    method: "GET",
    url: `${basePath}/${apiClient.config().dataset}/init?projectId=${apiClient.config().projectId}`
  }).finally(() => {
    setLoading(!1);
  })), [setLoading, apiClient]);
  return {
    loading,
    initInstruct
  };
}
function useRunInstructionApi(apiClient) {
  const toast = ui.useToast(), [loading, setLoading] = react.useState(!1), user = sanity.useCurrentUser(), types = useSerializedTypes(), {
    config: { assist: assistConfig }
  } = useAiAssistanceConfig(), runInstruction = react.useCallback(
    (request) => {
      if (!user) {
        toast.push({
          status: "error",
          title: "Unable to get user for instruction."
        });
        return;
      }
      setLoading(!0);
      const { timeZone, locale } = Intl.DateTimeFormat().resolvedOptions(), defaultLocaleSettings = { timeZone, locale }, localeSettings = assistConfig?.localeSettings?.({ user, defaultSettings: defaultLocaleSettings }) ?? defaultLocaleSettings;
      return apiClient.request({
        method: "POST",
        url: `${basePath}/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
        body: {
          ...request,
          types,
          userId: user?.id,
          localeSettings,
          maxPathDepth: assistConfig?.maxPathDepth
        }
      }).catch((e) => {
        throw toast.push({
          status: "error",
          title: "Instruction failed",
          description: e.message
        }), e;
      }).finally(() => {
        setLoading(!1);
      });
    },
    [apiClient, types, user, toast, assistConfig]
  );
  return react.useMemo(
    () => ({
      runInstruction,
      loading
    }),
    [runInstruction, loading]
  );
}
const NO_INPUT = {}, RunInstructionContext = react.createContext({
  runInstruction: () => {
  },
  getUserInput: async () => {
  },
  instructionLoading: !1
});
function useRunInstruction() {
  return react.useContext(RunInstructionContext);
}
function isUserInputBlock(block) {
  return block._type === userInputTypeName;
}
function RunInstructionProvider(props) {
  const { config } = useAiAssistanceConfig(), apiClient = useApiClient(config?.__customApiClient), { runInstruction: runInstructionRequest, loading } = useRunInstructionApi(apiClient), id = react.useId(), [inputs, setInputs] = react.useState(NO_INPUT), [runRequest, setRunRequest] = react.useState(), [resolveUserInput, setResolveUserInput] = react.useState(), getUserInput = react.useCallback(async ({ title, inputs: inputs2 }) => {
    const userInputBlocks = inputs2.map((input, i) => ({
      _type: userInputTypeName,
      _key: input.id ?? `${i}`,
      message: input.title,
      description: input.description
    }));
    if (userInputBlocks.length)
      return setRunRequest({ dialogTitle: title, userInputBlocks }), new Promise((resolve) => {
        setResolveUserInput(() => resolve);
      });
  }, []), runInstruction = react.useCallback(
    (req) => {
      if (loading)
        return;
      const { instruction: instruction2, ...request } = req, instructionKey = instruction2._key, userInputBlocks = instruction2?.prompt?.flatMap(
        (block) => block._type === "block" ? block.children.filter(isUserInputBlock) : [block]
      ).filter(isUserInputBlock);
      if (!userInputBlocks?.length) {
        runInstructionRequest({
          ...request,
          instructionKey,
          userTexts: void 0
        });
        return;
      }
      setRunRequest({
        ...req,
        userInputBlocks
      });
    },
    [runInstructionRequest, loading]
  ), close = react.useCallback(() => {
    setRunRequest(void 0), setInputs(NO_INPUT), resolveUserInput && resolveUserInput(void 0), setResolveUserInput(void 0);
  }, [resolveUserInput]), runWithInput = react.useCallback(() => {
    if (runRequest)
      if ("instruction" in runRequest) {
        const { instruction: instruction2, userTexts, ...request } = runRequest;
        runInstructionRequest({
          ...request,
          instructionKey: instruction2._key,
          userTexts: Object.entries(inputs).map(([key, value]) => ({
            blockKey: key,
            userInput: value
          }))
        });
      } else {
        const userInputs = Object.values(inputs).map((input, i) => {
          const userInputBlock = runRequest.userInputBlocks[i];
          return {
            input: {
              id: userInputBlock._key,
              title: userInputBlock.message ?? "",
              description: userInputBlock.description
            },
            result: input
          };
        });
        resolveUserInput?.(userInputs), setResolveUserInput(void 0);
      }
    close();
  }, [close, runInstructionRequest, runRequest, inputs, resolveUserInput]), open = !!runRequest, runDisabled = react.useMemo(
    () => (runRequest?.userInputBlocks?.length ?? 0) > Object.entries(inputs).filter(([, value]) => !!value).length,
    [runRequest?.userInputBlocks, inputs]
  ), runButton = /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      text: "Run instruction",
      onClick: runWithInput,
      tone: "primary",
      icon: icons.PlayIcon,
      style: { width: "100%" },
      disabled: runDisabled
    }
  ), contextValue = react.useMemo(
    () => ({ runInstruction, getUserInput, instructionLoading: loading }),
    [runInstruction, loading]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(RunInstructionContext.Provider, { value: contextValue, children: [
    open ? /* @__PURE__ */ jsxRuntime.jsx(
      ui.Dialog,
      {
        id,
        open,
        onClose: close,
        width: 1,
        header: "dialogTitle" in runRequest ? runRequest.dialogTitle : getInstructionTitle(runRequest?.instruction),
        footer: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "space-between", padding: 2, flex: 1, children: runDisabled ? /* @__PURE__ */ jsxRuntime.jsx(
          ui.Tooltip,
          {
            content: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "Unable to run instruction. All fields must have a value." }) }),
            placement: "top",
            children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, children: runButton })
          }
        ) : runButton }),
        children: /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 4, space: 2, children: runRequest?.userInputBlocks?.map((block, i) => /* @__PURE__ */ jsxRuntime.jsx(
          UserInput,
          {
            block,
            autoFocus: i === 0,
            inputs,
            setInputs
          },
          block._key
        )) })
      }
    ) : null,
    props.children
  ] });
}
function UserInput(props) {
  const { block, autoFocus, setInputs, inputs } = props, key = block._key, textAreaRef = react.useRef(null), onChange = react.useCallback(
    (e) => {
      setInputs((current) => ({
        ...current,
        [key]: (e.currentTarget ?? e.target).value
      }));
    },
    [key, setInputs]
  ), value = react.useMemo(() => inputs[key], [inputs, key]);
  return react.useEffect(() => {
    autoFocus && setTimeout(() => textAreaRef.current?.focus(), 0);
  }, [autoFocus]), /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { padding: 2, space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      sanity.FormFieldHeaderText,
      {
        title: block?.message ?? "Provide more context",
        description: block.description
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.TextArea,
      {
        ref: textAreaRef,
        rows: 4,
        value,
        onChange,
        style: { resize: "vertical" }
      }
    )
  ] });
}
function isDocAssistable(documentSchemaType, published, draft) {
  return !!(documentSchemaType.liveEdit ? published : draft);
}
function useRequestRunInstruction(args) {
  const { runInstruction, instructionLoading } = useRunInstruction(), requestRunInstruction = useDraftDelayedTask({
    ...args,
    task: runInstruction
  });
  return {
    instructionLoading,
    requestRunInstruction
  };
}
function useDraftDelayedTask(args) {
  const { documentOnChange, isDocAssistable: isDocAssistable2, task } = args, [queuedArgs, setQueuedArgs] = react.useState(void 0);
  return react.useEffect(() => {
    queuedArgs && isDocAssistable2 && (task(queuedArgs), setQueuedArgs(void 0));
  }, [queuedArgs, isDocAssistable2, task]), react.useCallback(
    (taskArgs) => {
      documentOnChange(sanity.PatchEvent.from([sanity.unset(["_force_document_creation"])])), setQueuedArgs(taskArgs);
    },
    [setQueuedArgs, documentOnChange]
  );
}
const maxDepth = 6;
function getTypeIcon(schemaType) {
  let t = schemaType;
  for (; t; ) {
    if (t.icon) return t.icon;
    t = t.type;
  }
  return isType(schemaType, "slug") ? icons.LinkIcon : isType(schemaType, "image") ? icons.ImageIcon : schemaType.jsonType === "array" && isPortableTextArray(schemaType) ? icons.BlockContentIcon : schemaType.jsonType === "array" ? icons.OlistIcon : schemaType.jsonType === "object" ? icons.BlockquoteIcon : schemaType.jsonType === "string" ? icons.StringIcon : icons.DocumentIcon;
}
function asFieldRefsByTypePath(fieldRefs) {
  return fieldRefs.reduce(
    (acc, ref) => ({ ...acc, [ref.key]: ref }),
    {}
  );
}
function getDocumentFieldRef(schemaType) {
  return {
    key: documentRootKey,
    icon: schemaType.icon ?? icons.DocumentIcon,
    title: "The entire document",
    path: [],
    schemaType
  };
}
function getFieldRefs(schemaType, parent, depth = 0) {
  return depth >= maxDepth ? [] : schemaType.fields.filter((f) => !f.name.startsWith("_")).flatMap((field) => {
    const path = parent ? [...parent.path, field.name] : [field.name], title = field.type.title ?? field.name, fieldRef = {
      key: patchableKey(sanity.pathToString(path)),
      path,
      title: parent ? [parent.title, title].join(" / ") : title,
      schemaType: field.type,
      icon: getTypeIcon(field.type)
    }, fields = field.type.jsonType === "object" ? getFieldRefs(field.type, fieldRef, depth + 1) : [], syntheticFields = field.type.jsonType === "array" ? getSyntheticFields(field.type, fieldRef, depth + 1) : [];
    return isAssistSupported(field.type) ? [fieldRef, ...fields, ...syntheticFields] : [...fields, ...syntheticFields];
  });
}
function getSyntheticFields(schemaType, parent, depth = 0) {
  return depth >= maxDepth ? [] : schemaType.of.filter((itemType) => !isType(itemType, "block")).flatMap((itemType) => {
    const segment = { _key: itemType.name }, title = itemType.title ?? itemType.name, path = parent ? [...parent.path, segment] : [segment], fieldRef = {
      key: patchableKey(sanity.pathToString(path)),
      path,
      title: parent ? [parent.title, title].join(" / ") : title,
      schemaType: itemType,
      icon: getTypeIcon(itemType),
      synthetic: !0
    }, fields = itemType.jsonType === "object" ? getFieldRefs(itemType, fieldRef, depth + 1) : [];
    return isAssistSupported(itemType) ? [fieldRef, ...fields] : fields;
  });
}
function getTypePath(doc, pathString) {
  if (!pathString)
    return;
  const path = sanity.stringToPath(pathString), currentPath = [];
  let valid = !0;
  const syntheticPath = path.map((segment) => {
    if (currentPath.push(segment), sanity.isKeySegment(segment)) {
      const match = mutator.extractWithPath(sanity.pathToString(currentPath), doc)[0], value = match?.value;
      if (match && value && typeof value == "object" && "_type" in value)
        return { _key: value._type };
      valid = !1;
    }
    return segment;
  });
  return valid ? patchableKey(sanity.pathToString(syntheticPath)) : void 0;
}
function patchableKey(pathKey) {
  return pathKey.replace(/[=]=/g, ":").replace(/[[\]]/g, "|").replace(/"/g, "");
}
function useTypePath(doc, pathString) {
  return react.useMemo(() => getTypePath(doc, pathString), [doc, pathString]);
}
function useSelectedField(documentSchemaType, path) {
  const { getFieldRefs: getFieldRefs2 } = useAiAssistanceConfig(), selectableFields = react.useMemo(
    () => documentSchemaType && sanity.isObjectSchemaType(documentSchemaType) ? [getDocumentFieldRef(documentSchemaType), ...getFieldRefs2(documentSchemaType.name)] : [],
    [documentSchemaType, getFieldRefs2]
  );
  return react.useMemo(() => path ? selectableFields?.find((f) => f.key === path) : void 0, [selectableFields, path]);
}
function getFieldTitle(field) {
  const schemaType = field?.schemaType;
  return field?.title ?? schemaType?.title ?? schemaType?.name ?? "Untitled";
}
function useAiPaneRouter() {
  const paneRouter = structure.usePaneRouter();
  return react.useMemo(
    () => ({ ...paneRouter, params: paneRouter.params ?? {} }),
    [paneRouter]
  );
}
function useAssistDocumentContextValue(documentId, documentType) {
  const schema = sanity.useSchema(), { getFieldRefs: getFieldRefs2, getFieldRefsByTypePath } = useAiAssistanceConfig(), documentSchemaType = react.useMemo(() => {
    const schemaType = schema.get(documentType);
    if (!schemaType)
      throw new Error(`Schema type "${documentType}" not found`);
    return schemaType;
  }, [documentType, schema]), { fieldRefs, fieldRefsByTypePath } = react.useMemo(() => ({
    fieldRefs: getFieldRefs2(documentType),
    fieldRefsByTypePath: getFieldRefsByTypePath(documentType)
  }), [getFieldRefs2, getFieldRefsByTypePath, documentType]), {
    openInspector,
    closeInspector,
    inspector,
    onChange: documentOnChange,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore this is a valid option available in `corel` - Remove after corel is merged to next
    selectedReleaseId,
    editState
  } = structure.useDocumentPane(), { draft, published, version } = editState || {}, assistableDocumentId = selectedReleaseId ? sanity.getVersionId(documentId, selectedReleaseId) : documentSchemaType.liveEdit ? documentId : sanity.getDraftId(documentId), documentIsNew = selectedReleaseId ? !version?._id : !draft?._id && !published?._id, documentIsAssistable = selectedReleaseId ? !!version : isDocAssistable(documentSchemaType, published, draft), { params } = useAiPaneRouter(), selectedPath = params[fieldPathParam], assistDocument = useStudioAssistDocument({
    documentId: assistableDocumentId,
    schemaType: documentSchemaType
  }), { syntheticTasks, addSyntheticTask, removeSyntheticTask } = useSyntheticTasks(assistableDocumentId);
  return react.useMemo(() => {
    const base = {
      assistableDocumentId,
      documentSchemaType,
      documentIsNew,
      documentIsAssistable,
      openInspector,
      closeInspector,
      inspector,
      documentOnChange,
      selectedPath,
      syntheticTasks,
      addSyntheticTask,
      removeSyntheticTask,
      fieldRefs,
      fieldRefsByTypePath
    };
    return assistDocument ? {
      ...base,
      loading: !1,
      assistDocument
    } : { ...base, loading: !0, assistDocument: void 0 };
  }, [
    assistDocument,
    documentIsAssistable,
    assistableDocumentId,
    documentSchemaType,
    documentIsNew,
    openInspector,
    closeInspector,
    inspector,
    documentOnChange,
    selectedPath,
    syntheticTasks,
    addSyntheticTask,
    removeSyntheticTask,
    fieldRefs,
    fieldRefsByTypePath
  ]);
}
function useSyntheticTasks(assistableDocumentId) {
  const [syntheticTasks, setSyntheticTasks] = react.useState(() => []), addSyntheticTask = react.useCallback((task) => {
    setSyntheticTasks((current) => [...current, task]);
  }, []), removeSyntheticTask = react.useCallback((task) => {
    setSyntheticTasks((current) => current.filter((t) => task._key !== t._key));
  }, []);
  return react.useEffect(() => {
    setSyntheticTasks([]);
  }, [assistableDocumentId]), {
    syntheticTasks,
    addSyntheticTask,
    removeSyntheticTask
  };
}
function AssistDocumentContextProvider(props) {
  const { documentId, documentType } = props, value = useAssistDocumentContextValue(documentId, documentType);
  return /* @__PURE__ */ jsxRuntime.jsx(AssistDocumentContext.Provider, { value, children: props.children });
}
function AssistDocumentLayout(props) {
  const { documentId, documentType } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(AssistDocumentContextProvider, { documentType, documentId, children: props.renderDefault(props) });
}
function AssistFeatureBadge() {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Badge, { fontSize: 0, style: { margin: "-2px 0" }, tone: "primary", children: "Beta" });
}
function AssistOnboardingPopover(props) {
  const { dismiss } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Popover,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(AssistIntroCard, { dismiss }),
      open: !0,
      portal: !0,
      placeholder: "bottom",
      tone: "default",
      width: 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, shadow: 2, style: { padding: 2, lineHeight: 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { disabled: !0, fontSize: 1, icon: icons.SparklesIcon, mode: "bleed", padding: 2 }) })
    }
  );
}
function AssistIntroCard(props) {
  const buttonRef = react.useRef(null);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { as: "section", padding: 3, space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { padding: 2, space: 4, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, align: "center", children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "h1", size: 1, weight: "semibold", children: pluginTitle }),
        /* @__PURE__ */ jsxRuntime.jsx("div", { "aria-hidden": !0, style: { margin: "-3px 0", lineHeight: 0 }, children: /* @__PURE__ */ jsxRuntime.jsx(AssistFeatureBadge, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "p", muted: !0, size: 1, children: [
        "Manage reusable AI instructions to boost your content creation and reduce amount of repetitive chores.",
        " ",
        /* @__PURE__ */ jsxRuntime.jsxs("a", { href: releaseAnnouncementUrl, target: "_blank", rel: "noreferrer", children: [
          "Learn more ",
          /* @__PURE__ */ jsxRuntime.jsx(icons.ArrowRightIcon, {})
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        fontSize: 1,
        icon: icons.CheckmarkIcon,
        onClick: props.dismiss,
        padding: 3,
        ref: buttonRef,
        text: "Ok, good to know!",
        tone: "primary"
      }
    )
  ] });
}
const inspectorOnboardingKey = "sanityStudio:assist:inspector:onboarding:dismissed", fieldOnboardingKey = "sanityStudio:assist:field:onboarding:dismissed";
function isFeatureOnboardingDismissed(featureKey) {
  return typeof localStorage > "u" ? !1 : localStorage.getItem(featureKey) === "true";
}
function dismissFeatureOnboarding(featureKey) {
  typeof localStorage > "u" || localStorage.setItem(featureKey, "true");
}
function useOnboardingFeature(featureKey) {
  const [showOnboarding, setShowOnboarding] = react.useState(
    () => !isFeatureOnboardingDismissed(featureKey)
  ), dismissOnboarding = react.useCallback(() => {
    setShowOnboarding(!1), dismissFeatureOnboarding(featureKey);
  }, [setShowOnboarding, featureKey]);
  return { showOnboarding, dismissOnboarding };
}
const fadeIn = styledComponents.keyframes`
  0% {
    opacity: 0;
    transform: scale(0.75);
  }
  40% {
    opacity: 0;
    transform: scale(0.75);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
`, FadeInDiv = styledComponents.styled.div`
  animation-name: ${fadeIn};
  animation-timing-function: ease-in-out;
`, FadeInContent = react.forwardRef(function({
  children,
  durationMs = 250
}, ref) {
  return /* @__PURE__ */ jsxRuntime.jsx(FadeInDiv, { ref, style: { animationDuration: `${durationMs}ms` }, children });
}), purple = {
  400: {
    hex: "#b087f7"
  },
  500: {
    hex: "#8f57ef"
  },
  600: {
    hex: "#721fe5"
  }
}, Root = styledComponents.styled.span`
  display: block;
  width: 25px;
  height: 25px;
  position: relative;
`, dash = styledComponents.keyframes`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(43deg);
  }
`, Outline = styledComponents.styled.svg`
  display: block;
  position: absolute;
  top: 0;
  left: 0;

  & > circle {
    stroke: var(--ai-avatar-stroke-color);
    stroke-width: 1.5px;
    stroke-linecap: round;
    transform-origin: center;
    animation: ${dash} 500ms ease-in-out infinite;
    transition: stroke-dasharray 200ms ease-in-out;

    stroke-dasharray: 2.34px 0;

    [data-state='active'] > & {
      stroke-dasharray: 2px 2.34px;
    }
  }
`, IconDisc = styledComponents.styled.span`
  background: var(--ai-avatar-disc-color);
  color: white;
  width: 21px;
  height: 21px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10.5px;
  position: absolute;
  top: 2px;
  left: 2px;
`;
function AssistAvatar(props) {
  const { state = "present" } = props, scheme = sanity.useColorSchemeValue(), style = react.useMemo(() => scheme === "dark" ? {
    "--ai-avatar-stroke-color": purple[400].hex,
    "--ai-avatar-disc-color": purple[600].hex
  } : {
    "--ai-avatar-stroke-color": purple[500].hex,
    "--ai-avatar-disc-color": purple[600].hex
  }, [scheme]);
  return /* @__PURE__ */ jsxRuntime.jsxs(Root, { "data-state": state, style, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      Outline,
      {
        width: "25",
        height: "25",
        viewBox: "0 0 25 25",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsxRuntime.jsx("circle", { cx: "12.5", cy: "12.5", r: "11.75" })
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(IconDisc, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "span", size: 0, style: { color: "inherit" }, children: /* @__PURE__ */ jsxRuntime.jsx(icons.SparklesIcon, { style: { color: "inherit" } }) }) })
  ] });
}
function AiFieldPresence(props) {
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { style: { position: "relative", background: "transparent" }, contentEditable: !1, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Tooltip,
    {
      placement: "left",
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 3, border: !0, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "Running instruction..." }) }) }),
      children: /* @__PURE__ */ jsxRuntime.jsx(FadeInContent, { durationMs: 300, children: /* @__PURE__ */ jsxRuntime.jsx(AssistAvatar, { state: "active" }) })
    }
  ) });
}
const NO_PRESENCE = [];
function useAssistPresence(path, showFocusWithin) {
  const context = useAssistDocumentContext(), tasks = (context && "assistDocument" in context ? context.assistDocument : void 0)?.tasks;
  return react.useMemo(() => {
    const activePresence = tasks?.filter((task) => !task.ended)?.flatMap((task) => task.presence ?? [])?.filter(
      (p) => p.started && (/* @__PURE__ */ new Date()).getTime() - new Date(p.started).getTime() < maxHistoryVisibilityMs
    ).filter((presence) => {
      if (!presence.path || !path.length)
        return !1;
      const statusPath = sanity.stringToPath(presence.path);
      return !showFocusWithin && statusPath.length !== path.length ? !1 : path.every((pathSegment, i) => {
        const statusSegment = statusPath[i];
        return typeof pathSegment == "string" ? pathSegment === statusSegment : sanity.isKeySegment(pathSegment) && sanity.isKeySegment(statusSegment) ? pathSegment._key === statusSegment._key : !1;
      });
    });
    return activePresence?.length ? activePresence.map((status) => aiPresence(status, path)) : NO_PRESENCE;
  }, [showFocusWithin, tasks, path]);
}
function aiPresence(presence, path, title) {
  return {
    user: {
      id: `sanity-assistant_${presence._key}`,
      displayName: pluginTitle
    },
    path,
    sessionId: "not-available",
    lastActiveAt: presence?.started ?? (/* @__PURE__ */ new Date()).toISOString()
  };
}
function AssistFieldWrapper(props) {
  const { schemaType } = props;
  return !react.useMemo(() => isAssistSupported(schemaType), [schemaType]) || schemaType.name.startsWith("sanity.") || schemaType.name === contextDocumentTypeName ? props.renderDefault(props) : !isType(props.schemaType, "document") && props.inputId !== "root" && props.inputId !== assistFormId ? /* @__PURE__ */ jsxRuntime.jsx(AssistField, { ...props, children: props.children }) : props.renderDefault(props);
}
function AssistField(props) {
  const { path } = props, isPortableText = react.useMemo(
    () => !!(sanity.isArraySchemaType(props.schemaType) && isPortableTextArray(props.schemaType)),
    [props.schemaType]
  ), presence = useAssistPresence(props.path, isPortableText), firstAssistedPath = react.useContext(FirstAssistedPathContext), isFirstAssisted = react.useMemo(
    () => sanity.pathToString(path) === firstAssistedPath,
    [path, firstAssistedPath]
  ), { showOnboarding, dismissOnboarding } = useOnboardingFeature(fieldOnboardingKey), singlePresence = presence[0], actions = /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, align: "center", justify: "space-between", children: [
    singlePresence && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(AiFieldPresence, { presence: singlePresence }) }),
    isFirstAssisted && showOnboarding && /* @__PURE__ */ jsxRuntime.jsx(AssistOnboardingPopover, { dismiss: dismissOnboarding })
  ] });
  return props.renderDefault({
    ...props,
    // When showing the onboarding, prevent default field actions from being rendered
    actions: isFirstAssisted && showOnboarding ? [] : props.actions,
    // Render presence (and possibly onboarding) in the internal slot (between presence and the field actions)
    // eslint-disable-next-line camelcase
    __internal_slot: actions
  });
}
const WrapPreCard = styledComponents.styled(ui.Card)`
  & pre {
    white-space: pre-wrap !important;
  }
`;
function SafeValueInput(props) {
  return /* @__PURE__ */ jsxRuntime.jsx(ErrorWrapper, { onChange: props.onChange, children: /* @__PURE__ */ jsxRuntime.jsx(PteValueFixer, { ...props }) });
}
function ErrorWrapper(props) {
  const { onChange } = props, [error, setError] = react.useState(), catchError = react.useCallback((params) => {
    setError(params.error);
  }, []), unsetValue = react.useCallback(() => {
    onChange(sanity.PatchEvent.from(sanity.unset())), setError(void 0);
  }, [onChange]), dismiss = react.useCallback(() => setError(void 0), []), catcher = /* @__PURE__ */ jsxRuntime.jsx(ui.ErrorBoundary, { onCatch: catchError, children: props.children });
  return error ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, tone: "critical", padding: 2, contentEditable: !1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, weight: "semibold", children: "An error occurred." }),
    /* @__PURE__ */ jsxRuntime.jsx(WrapPreCard, { flex: 1, padding: 2, tone: "critical", border: !0, children: catcher }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { width: "fill", flex: 1, gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { text: "Dismiss", onClick: dismiss, tone: "primary" }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { text: "Unset value", onClick: unsetValue, tone: "critical" })
    ] })
  ] }) }) : catcher;
}
function PteValueFixer(props) {
  const isPortableText = react.useMemo(
    () => sanity.isArraySchemaType(props.schemaType) && isPortableTextArray(props.schemaType),
    [props.schemaType]
  ), value = props.value;
  return isPortableText && value && !value.length ? props.renderDefault({ ...props, value: void 0 }) : props.renderDefault(props);
}
function AssistFormBlock(props) {
  const presence = useAssistPresence(props.path, !0), { onChange } = sanity.useFormCallbacks(), key = props.value._key, localOnChange = react.useCallback(
    (patchEvent) => {
      key && onChange(sanity.PatchEvent.from(patchEvent).prefixAll({ _key: key }));
    },
    [onChange, key]
  ), singlePresence = presence[0];
  return /* @__PURE__ */ jsxRuntime.jsx(ErrorWrapper, { onChange: localOnChange, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", justify: "space-between", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: props.renderDefault(props) }),
    singlePresence && /* @__PURE__ */ jsxRuntime.jsx(AiFieldPresence, { presence: singlePresence })
  ] }) });
}
const InlineBlockValueContext = react.createContext(void 0);
function AssistInlineFormBlock(props) {
  return /* @__PURE__ */ jsxRuntime.jsx(InlineBlockValueContext.Provider, { value: props.value, children: /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: props.renderDefault(props) }) });
}
function AssistItem(props) {
  const { path } = props, presence = useAssistPresence(path, !0);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", width: "fill", style: { position: "relative" }, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: props.renderDefault({ ...props }) }),
    presence.map((pre) => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { position: "absolute", right: 35 }, children: /* @__PURE__ */ jsxRuntime.jsx(AiFieldPresence, { presence: pre }) }, pre.user.id))
  ] });
}
const preventDefault = (ev) => ev.preventDefault();
function DocumentForm(props) {
  const {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    documentId,
    documentType,
    editState,
    formState,
    onBlur,
    onChange,
    onFocus,
    onPathOpen,
    onSetActiveFieldGroup,
    onSetCollapsedFieldSet,
    onSetCollapsedPath,
    ready,
    validation
  } = structure.useDocumentPane(), documentStore = sanity.useDocumentStore(), presence = sanity.useDocumentPresence(documentId), patchChannel = react.useMemo(() => sanity.createPatchChannel(), []), isLocked = editState?.transactionSyncLock?.enabled;
  react.useEffect(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(
      operators.tap((event) => {
        event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
      })
    ).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = !!value?._rev;
  react.useEffect(() => {
    hasRev && patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, [hasRev]);
  const formRef = react.useRef(null);
  return react.useEffect(() => {
    ui.focusFirstDescendant(formRef.current);
  }, []), isLocked ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "form", ...props, ref: formRef, children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Flex,
    {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      padding: 3,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "Please hold tight while the document is synced. This usually happens right after the document has been published, and it shouldn\u2019t take more than a few seconds" })
    }
  ) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { as: "form", ...props, onSubmit: preventDefault, ref: formRef, children: ready ? formState === null ? /* @__PURE__ */ jsxRuntime.jsx(
    ui.Flex,
    {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      padding: 3,
      sizing: "border",
      children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "This form is hidden" })
    }
  ) : /* @__PURE__ */ jsxRuntime.jsx(
    sanity.FormBuilder,
    {
      __internal_patchChannel: patchChannel,
      collapsedFieldSets,
      collapsedPaths,
      focusPath: formState.focusPath,
      changed: formState.changed,
      focused: formState.focused,
      groups: formState.groups,
      id: assistFormId,
      members: formState.members,
      onChange,
      onFieldGroupSelect: onSetActiveFieldGroup,
      onPathBlur: onBlur,
      onPathFocus: onFocus,
      onPathOpen,
      onSetFieldSetCollapsed: onSetCollapsedFieldSet,
      onSetPathCollapsed: onSetCollapsedPath,
      presence,
      readOnly: formState.readOnly,
      schemaType: formState.schemaType,
      validation,
      value: formState.value
    }
  ) : /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      padding: 3,
      sizing: "border",
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 3, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", muted: !0, size: 1, children: "Loading document" }) })
      ]
    }
  ) });
}
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: sanity.fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: sanity.fromMutationPatches("remote", remotePatches).concat(
      sanity.fromMutationPatches("local", localPatches)
    )
  };
}
const AssistTypeContext = react.createContext({}), DEFAULT_MAX_DEPTH$1 = 8, ABSOLUTE_MAX_DEPTH$1 = 50;
function getConditionalMembers(docState, maxDepth2 = DEFAULT_MAX_DEPTH$1) {
  return [{
    path: "",
    hidden: !1,
    readOnly: !!docState.readOnly,
    conditional: isConditional(docState.schemaType)
  }, ...extractConditionalPaths(docState, Math.min(maxDepth2, ABSOLUTE_MAX_DEPTH$1))].filter((v) => v.conditional).map(({ conditional, ...state }) => ({ ...state }));
}
function isConditional(schemaType) {
  return typeof schemaType.hidden == "function" || typeof schemaType.readOnly == "function";
}
function conditionalState(memberState) {
  return {
    path: sanity.pathToString(memberState.path),
    readOnly: !!memberState.readOnly,
    // Use actual form state readOnly value
    hidden: !1,
    // If it's in form state members, it's not hidden
    conditional: isConditional(memberState.schemaType)
  };
}
function extractConditionalPaths(node, maxDepth2) {
  return node.path.length >= maxDepth2 ? [] : node.members.reduce((acc, member) => {
    if (member.kind === "error")
      return acc;
    if (member.kind === "field") {
      const schemaType = member.field.schemaType;
      if (schemaType.jsonType === "object") {
        const innerFields = member.field.readOnly ? [] : extractConditionalPaths(member.field, maxDepth2);
        return [...acc, conditionalState(member.field), ...innerFields];
      } else if (schemaType.jsonType === "array") {
        const array = member.field;
        let arrayPaths = [];
        const isObjectsArray = array.members.some(
          (m) => m.kind === "item" && sanity.isObjectSchemaType(m.item.schemaType)
        );
        if (!array.readOnly)
          for (const arrayMember of array.members) {
            if (arrayMember.kind === "error")
              continue;
            const innerFields = isObjectsArray && !arrayMember.item.readOnly ? extractConditionalPaths(arrayMember.item, maxDepth2) : [];
            arrayPaths = [...arrayPaths, conditionalState(arrayMember.item), ...innerFields];
          }
        return [...acc, conditionalState(array), ...arrayPaths];
      }
      return [...acc, conditionalState(member.field)];
    } else if (member.kind === "fieldSet") {
      const conditionalFieldset = !!node.schemaType?.fieldsets?.some(
        (f) => !f.single && f.name === member.fieldSet.name && typeof f.hidden == "function"
      ), innerFields = extractConditionalPaths(member.fieldSet, maxDepth2).map((f) => ({
        ...f,
        // if fieldset is conditional, visible fields must also be considered conditional
        conditional: conditionalFieldset || f.conditional
      }));
      return [...acc, ...innerFields];
    }
    return acc;
  }, []);
}
const SparklesIllustration = styledComponents.styled(icons.SparklesIcon)({
  fontSize: "3.125em",
  "& path": {
    strokeWidth: "0.6px !important"
  }
});
function InspectorOnboarding(props) {
  const { onDismiss } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Container, { width: 0, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: { textAlign: "center" }, children: /* @__PURE__ */ jsxRuntime.jsx(SparklesIllustration, {}) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { align: "center", size: 1, children: "Create reusable AI instructions that can be applied across all documents of a certain type." }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 2, justify: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Button,
        {
          as: "a",
          href: releaseAnnouncementUrl,
          rel: "noreferrer",
          target: "_blank",
          fontSize: 1,
          mode: "default",
          onClick: onDismiss,
          padding: 2,
          text: "Learn more",
          tone: "primary"
        }
      ),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, mode: "bleed", onClick: onDismiss, padding: 2, text: "Dismiss" })
    ] })
  ] }) }) });
}
function FieldAutocomplete(props) {
  const { id, schemaType, fieldPath, onSelect, includeDocument, filter } = props, { getFieldRefs: getFieldRefs2 } = useAiAssistanceConfig(), fieldRefs = react.useMemo(() => {
    const refs = getFieldRefs2(schemaType.name);
    return includeDocument ? [getDocumentFieldRef(schemaType), ...refs] : refs;
  }, [schemaType, includeDocument, getFieldRefs2]), currentField = react.useMemo(
    () => fieldRefs.find((f) => f.key === fieldPath),
    [fieldPath, fieldRefs]
  ), autocompleteOptions = react.useMemo(
    () => fieldRefs.filter((field) => filter ? filter(field) : !0).filter((f) => !isType(f.schemaType, "reference")).map((field) => ({ value: field.key, field })),
    [fieldRefs, filter]
  ), renderOption = react.useCallback((option) => {
    const { value, field } = option;
    return value ? isType(field.schemaType, "document") ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "button", padding: 3, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: "The entire document" }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "button", padding: 3, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: react.createElement(field.icon) }),
      /* @__PURE__ */ jsxRuntime.jsx(FieldTitle, { field })
    ] }) }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: "button", padding: 3, radius: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { accent: !0, size: 1, children: option.value }) });
  }, []), renderValue = react.useCallback((value, option) => option?.field.title ?? value, []), filterOption = react.useCallback((query, option) => {
    const lQuery = query.toLowerCase();
    return option?.value?.toLowerCase().includes(lQuery) || option?.field?.title?.toLowerCase().includes(lQuery);
  }, []);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Autocomplete,
    {
      fontSize: 1,
      icon: currentField ? currentField.icon : icons.SearchIcon,
      onChange: onSelect,
      openButton: !0,
      id,
      options: autocompleteOptions,
      placeholder: "Search for a field",
      radius: 2,
      renderOption,
      renderValue,
      value: currentField?.key,
      filterOption
    }
  );
}
function FieldTitle(props) {
  const splitTitle = props.field.title.split("/");
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Breadcrumbs,
    {
      style: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        marginTop: "-4px"
      },
      separator: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "/" }) }),
      space: 1,
      children: [
        splitTitle.slice(0, splitTitle.length - 1).map((pt, i) => (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: pt.trim() }) }, i)
        )),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "medium", children: splitTitle[splitTitle.length - 1] }) })
      ]
    }
  ) });
}
function useInterval(ms) {
  const [tick, update] = react.useReducer((n) => n + 1, 0);
  return react.useEffect(() => {
    const i = setInterval(update, ms);
    return () => clearInterval(i);
  }, [ms]), tick;
}
function TimeAgo({ date }) {
  useInterval(1e3);
  const timeSince = dateFns.formatDistanceToNow(date ? new Date(date) : /* @__PURE__ */ new Date());
  return /* @__PURE__ */ jsxRuntime.jsxs("span", { title: timeSince, children: [
    timeSince,
    " ago"
  ] });
}
const rotate = styledComponents.keyframes`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`, SyncSpinningIcon = styledComponents.styled(icons.SyncIcon)`
  animation: ${rotate} 1s linear infinite;
`, TASK_CONFIG = {
  aborted: {
    title: "Canceled",
    icon: icons.CloseCircleIcon,
    tone: "transparent"
  },
  error: {
    title: "Error",
    icon: icons.ErrorOutlineIcon,
    tone: "critical"
  },
  success: {
    title: "Completed",
    icon: icons.CheckmarkCircleIcon,
    tone: "positive"
  },
  timeout: {
    title: "Timeout",
    icon: icons.ClockIcon,
    tone: "caution"
  }
};
function InstructionTaskHistoryButton(props) {
  const { tasks, instructions, documentId, showTitles } = props, client = sanity.useClient({ apiVersion: "2023-01-01" }), cancelRun = react.useCallback(
    (taskKey) => {
      if (!documentId)
        return;
      const statusDocId = assistTasksStatusId(documentId), basePath2 = `${sanity.typed("tasks")}[_key=="${taskKey}"]`;
      client.patch(statusDocId).set({
        [`${basePath2}.${sanity.typed("ended")}`]: (/* @__PURE__ */ new Date()).toISOString(),
        [`${basePath2}.${sanity.typed("reason")}`]: sanity.typed("aborted")
      }).commit().catch(console.error);
    },
    [client, documentId]
  ), titledTasks = react.useMemo(() => {
    const t = tasks?.filter(
      (task) => task.started && (/* @__PURE__ */ new Date()).getTime() - new Date(task.started).getTime() < maxHistoryVisibilityMs
    ).map((task) => {
      const instruction2 = instructions?.find((i) => i._key === task.instructionKey);
      return {
        ...task,
        title: showTitles ? task.title ?? getInstructionTitle(instruction2) : void 0,
        cancel: () => cancelRun(task._key)
      };
    }) ?? [];
    return t.sort((a, b) => new Date(b.started ?? "").getTime() - new Date(a.started ?? "").getTime()), t;
  }, [tasks, instructions, cancelRun, showTitles]), isRunning = react.useMemo(() => titledTasks.some((r) => !r.ended), [titledTasks]), hasErrors = react.useMemo(
    () => titledTasks.some((r) => r.reason === "error" || r.reason === "timeout"),
    [titledTasks]
  ), [open, setOpen] = react.useState(!1), toggleOpen = react.useCallback(() => setOpen((v) => !v), []), [button, setButton] = react.useState(null), [popover, setPopover] = react.useState(null), handleClickOutside = react.useCallback(() => {
    setOpen(!1);
  }, []);
  ui.useClickOutside(handleClickOutside, [button, popover]);
  const handleEscape = react.useCallback(() => {
    setOpen(!1), button?.focus();
  }, [button]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Popover,
    {
      constrainSize: !0,
      content: /* @__PURE__ */ jsxRuntime.jsx(TaskList, { onEscape: handleEscape, tasks: titledTasks }),
      open: open && !!titledTasks?.length,
      placement: "top",
      portal: !0,
      ref: setPopover,
      width: 0,
      children: /* @__PURE__ */ jsxRuntime.jsx(
        TaskStatusButton,
        {
          disabled: !titledTasks?.length,
          hasErrors,
          isRunning,
          onClick: toggleOpen,
          ref: setButton,
          selected: open
        }
      )
    }
  );
}
const TASK_STATUS_BUTTON_TOOLTIP_PROPS = {
  placement: "top"
}, TaskStatusButton = react.forwardRef(function(props, ref) {
  const { disabled, hasErrors, isRunning, onClick, selected } = props;
  return /* @__PURE__ */ jsxRuntime.jsx(
    sanity.StatusButton,
    {
      label: `${pluginTitle} status`,
      "aria-label": `${pluginTitle} status`,
      icon: isRunning ? SyncSpinningIcon : hasErrors ? icons.ErrorOutlineIcon : icons.CheckmarkCircleIcon,
      mode: "bleed",
      onClick,
      tone: hasErrors ? "critical" : void 0,
      disabled,
      ref,
      selected,
      tooltipProps: TASK_STATUS_BUTTON_TOOLTIP_PROPS
    }
  );
});
function TaskList(props) {
  const { onEscape, tasks } = props, { isTopLayer } = ui.useLayer();
  return ui.useGlobalKeyDown(
    react.useCallback(
      (event) => {
        isTopLayer && event.key === "Escape" && onEscape();
      },
      [isTopLayer, onEscape]
    )
  ), /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { padding: 1, space: 1, children: tasks.map((task) => /* @__PURE__ */ jsxRuntime.jsx(TaskItem, { task }, task._key)) });
}
function TaskItem(props) {
  const { task } = props, taskType = task.reason && TASK_CONFIG[task.reason];
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, tone: taskType && taskType?.tone, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", gap: 1, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "flex-start", flex: 1, gap: 3, padding: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, children: [
        taskType && react.createElement(taskType.icon),
        !task.reason && /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {})
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, space: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "medium", children: [
          taskType ? taskType.title : "Running",
          task.title && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
            ": ",
            task.title
          ] })
        ] }),
        task.message ? /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: task.message }) : null,
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(TimeAgo, { date: task.ended ?? task.started }) })
      ] })
    ] }),
    !task.ended && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, mode: "bleed", onClick: task.cancel, text: "Cancel" }) })
  ] }) });
}
const CardWithShadowBelow = styledComponents.styled(ui.Card)`
  position: relative;

  &:after {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    bottom: -1px;
    border-bottom: 1px solid var(--card-border-color);
    opacity: 0.5;
    z-index: 100;
  }
`, CardWithShadowAbove = styledComponents.styled(ui.Card)`
  position: relative;

  &:after {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -1px;
    border-top: 1px solid var(--card-border-color);
    opacity: 0.5;
    z-index: 100;
  }
`;
function AssistInspectorWrapper(props) {
  const context = useAiAssistanceConfig();
  if (context.statusLoading)
    return /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 3, style: { textAlign: "center" }, children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { muted: !0 }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
        "Loading ",
        pluginTitle,
        "..."
      ] })
    ] }) });
  const status = context.status;
  return status?.enabled ? !status?.initialized || !status.validToken ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      structure.DocumentInspectorHeader,
      {
        closeButtonLabel: "Close",
        onClose: props.onClose,
        title: pluginTitle
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { padding: 4, space: 3, children: [
      context.error ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "semibold", children: [
        "Failed to start ",
        pluginTitle
      ] }) : null,
      !context.error && !status?.initialized ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, weight: "semibold", children: [
        pluginTitle,
        " is not enabled"
      ] }) : null,
      !context.error && status?.initialized && !status.validToken ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: "Invalid token" }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "The token used by the AI Assistant is not valid and has to be regenerated." })
      ] }) : null,
      context.error && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "Something went wrong. See console for details." }),
      !context.error && !status?.initialized && /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { size: 1, muted: !0, children: [
        "Please enable ",
        pluginTitle,
        "."
      ] }),
      /* @__PURE__ */ jsxRuntime.jsx(
        ui.Button,
        {
          fontSize: 1,
          icon: context.initLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {}) }) : context.error ? icons.RetryIcon : void 0,
          text: context.error ? "Retry" : status?.initialized && !status.validToken ? `Restore ${pluginTitle}` : `Enable ${pluginTitle} now`,
          tone: "primary",
          onClick: context.init,
          disabled: context.initLoading
        }
      )
    ] })
  ] }) : /* @__PURE__ */ jsxRuntime.jsx(AssistInspector, { ...props }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", height: "fill", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      structure.DocumentInspectorHeader,
      {
        closeButtonLabel: "Close",
        onClose: props.onClose,
        title: pluginTitle
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { flex: 1, overflow: "auto", padding: 4, space: 3, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "p", size: 1, weight: "semibold", children: [
        pluginTitle,
        " is not available"
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { as: "p", muted: !0, size: 1, children: [
        "Please get in touch with a Sanity account manager or",
        " ",
        /* @__PURE__ */ jsxRuntime.jsx("a", { href: salesUrl, target: "_blank", rel: "noreferrer", children: "contact our sales team" }),
        " ",
        "to get started with ",
        pluginTitle,
        ".",
        " ",
        /* @__PURE__ */ jsxRuntime.jsx("a", { href: releaseAnnouncementUrl, target: "_blank", rel: "noreferrer", children: "Learn more \u2192" })
      ] })
    ] })
  ] });
}
function AssistInspector(props) {
  const { params } = useAiPaneRouter(), boundary = react.useRef(null), pathKey = params?.[fieldPathParam], instructionKey = params?.[instructionParam], documentPane = structure.useDocumentPane(), {
    documentId,
    documentType,
    value: docValue,
    schemaType,
    onChange: documentOnChange,
    formState
  } = documentPane, { assistableDocumentId, documentIsAssistable } = useAssistDocumentContext(), formStateRef = react.useRef(formState);
  formStateRef.current = formState;
  const { instructionLoading, requestRunInstruction } = useRequestRunInstruction({
    documentOnChange,
    isDocAssistable: documentIsAssistable
  }), typePath = useTypePath(docValue, pathKey ?? ""), selectedField = useSelectedField(schemaType, typePath), aiDocId = assistDocumentId(documentType), assistDocument = useStudioAssistDocument({ documentId, schemaType, initDoc: !0 }), instruction2 = assistDocument?.fields?.find((f) => f.path === typePath)?.instructions?.find((i) => i._key === instructionKey), tasks = react.useMemo(
    () => assistDocument?.tasks?.filter((i) => !instructionKey || i.instructionKey === instructionKey),
    [assistDocument?.tasks, instructionKey]
  ), instructions = react.useMemo(
    () => assistDocument?.fields?.flatMap((f) => f.instructions ?? []),
    [assistDocument?.fields]
  ), promptValue = instruction2?.prompt, isEmptyPrompt = react.useMemo(() => {
    if (!promptValue?.length)
      return !0;
    const children = promptValue[0]?.children;
    return promptValue.length == 1 && children?.length === 1 && !children?.[0]?.text?.length;
  }, [promptValue]), paneNode = react.useMemo(
    () => ({
      type: "document",
      id: aiDocId,
      title: pluginTitle,
      options: {
        id: aiDocId,
        type: assistDocumentTypeName
      }
    }),
    [aiDocId]
  ), runCurrentInstruction = react.useCallback(
    () => instruction2 && pathKey && typePath && requestRunInstruction({
      documentId: assistableDocumentId,
      path: pathKey,
      typePath,
      assistDocumentId: assistDocumentId(documentType),
      instruction: instruction2,
      conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current) : []
    }),
    [pathKey, instruction2, typePath, documentType, assistableDocumentId, requestRunInstruction]
  ), Region = react.useCallback((_props) => /* @__PURE__ */ jsxRuntime.jsx("div", { ..._props, style: { height: "100%", flex: 1, overflow: "auto" } }), []), assistTypeContext = react.useMemo(() => ({ typePath, documentType }), [typePath, documentType]);
  return !documentId || !schemaType || schemaType.jsonType !== "object" ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { flex: 1, padding: 4, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "Document not ready yet." }) }) : /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      ref: boundary,
      direction: "column",
      height: "fill",
      overflow: "hidden",
      sizing: "border",
      style: { lineHeight: 0 },
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          AiInspectorHeader,
          {
            onClose: props.onClose,
            field: selectedField,
            fieldTitle: getFieldTitle(selectedField)
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { as: Region, flex: 1, overflow: "auto", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { direction: "column", style: { minHeight: "100%" }, children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.PresenceOverlay, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { padding: 4, children: selectedField && /* @__PURE__ */ jsxRuntime.jsx(AssistTypeContext.Provider, { value: assistTypeContext, children: /* @__PURE__ */ jsxRuntime.jsx(
            sanity.VirtualizerScrollInstanceProvider,
            {
              scrollElement: boundary.current,
              containerElement: boundary,
              children: /* @__PURE__ */ jsxRuntime.jsx(
                structure.DocumentPaneProvider,
                {
                  paneKey: documentPane.paneKey,
                  index: documentPane.index,
                  itemId: "ai",
                  pane: paneNode,
                  forcedVersion: {
                    isReleaseLocked: !1,
                    selectedPerspectiveName: "published",
                    selectedReleaseId: void 0
                  },
                  children: /* @__PURE__ */ jsxRuntime.jsx(DocumentForm, {})
                }
              )
            }
          ) }) }) }) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", padding: 4, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Text, { muted: !0, size: 1, children: [
            "How is Sanity AI Assist working for you?",
            " ",
            /* @__PURE__ */ jsxRuntime.jsxs(
              "a",
              {
                href: giveFeedbackUrl,
                target: "_blank",
                rel: "noreferrer",
                style: { whiteSpace: "nowrap" },
                children: [
                  "Let us know ",
                  /* @__PURE__ */ jsxRuntime.jsx(icons.ArrowRightIcon, {})
                ]
              }
            )
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntime.jsx(CardWithShadowAbove, { flex: "none", paddingX: 4, paddingY: 3, style: { justifySelf: "flex-end" }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, flex: 1, justify: "flex-end", children: [
          schemaType?.name && pathKey && instructionKey && /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
            ui.Button,
            {
              mode: "ghost",
              disabled: isEmptyPrompt || instructionLoading,
              fontSize: 1,
              icon: instructionLoading ? /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { marginTop: 3 } }) : icons.PlayIcon,
              onClick: runCurrentInstruction,
              padding: 3,
              text: "Run instruction"
            }
          ) }),
          /* @__PURE__ */ jsxRuntime.jsx(
            InstructionTaskHistoryButton,
            {
              documentId: assistableDocumentId,
              tasks,
              instructions,
              showTitles: !instructionKey
            }
          )
        ] }) })
      ]
    }
  );
}
function AiInspectorHeader(props) {
  const { onClose, field, fieldTitle } = props, { showOnboarding, dismissOnboarding } = useOnboardingFeature(inspectorOnboardingKey);
  return /* @__PURE__ */ jsxRuntime.jsxs(CardWithShadowBelow, { flex: "none", padding: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { flex: 1, align: "center", children: [
      /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, padding: 3, gap: 2, align: "center", children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 1, align: "center", wrap: "wrap", style: { marginTop: "-4px" }, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginTop: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: "AI instructions for" }) }),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { radius: 2, border: !0, padding: 1, marginTop: 1, children: field ? /* @__PURE__ */ jsxRuntime.jsx(FieldTitle, { field }) : /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, weight: "semibold", children: fieldTitle }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { fontSize: 1, icon: icons.CloseIcon, mode: "bleed", onClick: onClose }) })
    ] }),
    showOnboarding && /* @__PURE__ */ jsxRuntime.jsx(InspectorOnboarding, { onDismiss: dismissOnboarding })
  ] });
}
const aiInspectorId = "ai-assistance", assistInspector = {
  name: aiInspectorId,
  useMenuItem: () => ({
    icon: icons.SparklesIcon,
    title: pluginTitle,
    hidden: !0,
    showAsAction: !1
  }),
  component: AssistInspectorWrapper,
  onClose({ params }) {
    return {
      params: sanity.typed({
        ...params,
        [fieldPathParam]: void 0,
        [instructionParam]: void 0
      })
    };
  }
};
function arrowPath(options2, x, y, dir) {
  return [
    `M ${x - options2.arrow.size} ${y - options2.arrow.size * dir} `,
    `L ${x} ${y}`,
    `L ${x + options2.arrow.size} ${y - options2.arrow.size * dir}`
  ].join("");
}
function moveTo(x, y) {
  return `M${x} ${y}`;
}
function lineTo(x, y) {
  return `L${x} ${y}`;
}
function join(strings, delim = "") {
  return strings.join(delim);
}
function quadCurve(x1, y1, x, y) {
  return `Q${x1} ${y1} ${x} ${y}`;
}
function drawConnectorPath(options2, line) {
  const { cornerRadius } = options2.path, { from, to } = line, { x: fromX, y: fromY } = from, { x: _toX, y: toY } = to, toX = _toX - 1, dividerX = to.bounds.x + options2.divider.offsetX, fromPathX = from.isAbove || from.isBelow ? fromX + options2.arrow.marginX : fromX, r0 = Math.min(cornerRadius, Math.abs(fromPathX - dividerX) / 2), r1 = Math.min(cornerRadius, Math.abs(fromY - toY) / 2), cmds = [];
  return from.isAbove ? cmds.push(
    moveTo(
      fromX + options2.arrow.marginX,
      fromY - options2.arrow.threshold + options2.arrow.marginY
    ),
    lineTo(fromX + options2.arrow.marginX, fromY - r0),
    quadCurve(fromX + options2.arrow.marginX, fromY, fromX + options2.arrow.marginX + r0, fromY)
  ) : from.isBelow ? cmds.push(
    moveTo(
      fromX + options2.arrow.marginX,
      fromY + options2.arrow.threshold - options2.arrow.marginY
    ),
    lineTo(fromX + options2.arrow.marginX, fromY + r0),
    quadCurve(fromX + options2.arrow.marginX, fromY, fromX + options2.arrow.marginX + r0, fromY)
  ) : cmds.push(moveTo(fromX, fromY)), to.isAbove ? fromY < to.bounds.y ? cmds.push(
    lineTo(dividerX - r1, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY + r1),
    lineTo(dividerX, toY - r1),
    quadCurve(dividerX, toY, dividerX + r1, toY),
    lineTo(dividerX - cornerRadius, toY),
    quadCurve(dividerX, toY, dividerX, toY - cornerRadius),
    lineTo(dividerX, toY - options2.arrow.threshold + options2.arrow.marginY)
  ) : cmds.push(
    lineTo(dividerX - cornerRadius, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY - cornerRadius),
    lineTo(dividerX, toY - options2.arrow.threshold + options2.arrow.marginY)
  ) : to.isBelow ? fromY > to.bounds.y + to.bounds.h ? cmds.push(
    lineTo(dividerX - options2.arrow.marginX - r1, fromY),
    quadCurve(
      dividerX - options2.arrow.marginX,
      fromY,
      dividerX - options2.arrow.marginX,
      fromY - r1
    ),
    lineTo(dividerX - options2.arrow.marginX, toY + r1),
    quadCurve(
      dividerX - options2.arrow.marginX,
      toY,
      dividerX - options2.arrow.marginX + r1,
      toY
    ),
    lineTo(dividerX - cornerRadius, toY),
    quadCurve(dividerX, toY, dividerX, toY + cornerRadius),
    lineTo(dividerX, toY + options2.arrow.threshold - options2.arrow.marginY)
  ) : cmds.push(
    lineTo(dividerX - cornerRadius, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY + cornerRadius),
    lineTo(dividerX, toY + options2.arrow.threshold - options2.arrow.marginY)
  ) : fromY < toY ? cmds.push(
    lineTo(dividerX - r0, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY + r1),
    lineTo(dividerX, toY - r1),
    quadCurve(dividerX, toY, dividerX + r1, toY),
    lineTo(toX, toY)
  ) : cmds.push(
    lineTo(dividerX - Math.min(r0, r1), fromY),
    quadCurve(dividerX, fromY, dividerX, fromY - Math.min(r0, r1)),
    lineTo(dividerX, toY + r1),
    quadCurve(dividerX, toY, dividerX + r1, toY),
    lineTo(toX, toY)
  ), join(cmds);
}
function ConnectorPath(props) {
  const { from, options: options2, to } = props, { strokeWidth } = options2.path, theme = ui.useTheme(), line = react.useMemo(() => mapConnectorToLine(options2, { from, to }), [from, options2, to]);
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: drawConnectorPath(options2, line),
        stroke: theme.sanity.color.base.bg,
        strokeWidth: strokeWidth + 4
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: drawConnectorPath(options2, line),
        stroke: ui.rgba(theme.sanity.color.base.border, 0.5),
        strokeWidth
      }
    ),
    line.from.isAbove && /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: arrowPath(
          options2,
          line.from.x + options2.arrow.marginX,
          line.from.bounds.y - options2.arrow.threshold + options2.arrow.marginY,
          -1
        ),
        stroke: theme.sanity.color.base.border,
        strokeWidth
      }
    ),
    line.from.isBelow && /* @__PURE__ */ jsxRuntime.jsx(
      "path",
      {
        d: arrowPath(
          options2,
          line.from.x + options2.arrow.marginX,
          line.from.bounds.y + line.from.bounds.h + options2.arrow.threshold - options2.arrow.marginY,
          1
        ),
        stroke: theme.sanity.color.base.border,
        strokeWidth
      }
    )
  ] });
}
const DEBUG = !1, options = {
  arrow: {
    marginX: 10.5,
    marginY: 5,
    size: 4,
    threshold: 16.5
  },
  divider: {
    offsetX: -10.5
  },
  path: {
    cornerRadius: 3,
    marginY: 10.5,
    strokeWidth: 1
  }
};
function AssistConnectorsOverlay(props) {
  const { connectors } = props, [, setRedraw] = react.useState(!1);
  return react.useEffect(() => {
    setRedraw(!0);
  }, []), /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      "svg",
      {
        fill: "none",
        width: window.innerWidth,
        height: window.innerHeight,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          zIndex: 150
          // zIndex,
        },
        children: connectors.map((connector) => /* @__PURE__ */ jsxRuntime.jsx(
          ConnectorPath,
          {
            from: connector.from,
            options,
            to: connector.to
          },
          connector.key
        ))
      }
    ),
    DEBUG
  ] });
}
function validateStyleguide(styleguide) {
  if (styleguide && styleguide.length > 2e3)
    throw new Error(
      `[${packageName}]: \`translate.styleguide\` value is too long. It must be 2000 characters or less, but was ${styleguide.length} characters`
    );
  return styleguide;
}
function createStyleGuideResolver(styleguide, context) {
  return async () => {
    if (typeof styleguide != "function")
      return styleguide;
    const styleguideResult = await styleguide(context);
    return validateStyleguide(styleguideResult);
  };
}
const getLanguageParams = (select, document2) => {
  if (!select || !document2)
    return {};
  const selection = select || {}, selectedValue = {};
  for (const [key, path] of Object.entries(selection)) {
    let value = get__default.default(document2, path);
    Array.isArray(value) && (value = value.filter(
      (item) => typeof item == "object" ? item?._type !== "reference" || "_ref" in item : !0
    )), selectedValue[key] = value;
  }
  return selectedValue;
}, toFieldLanguagesKeyPrefix = "sanityStudio:assist:field-languages:from:";
function getPreferredToFieldLanguages(fromLanguageId) {
  if (typeof localStorage > "u")
    return [];
  const value = localStorage.getItem(`${toFieldLanguagesKeyPrefix}${fromLanguageId}`);
  return value ? JSON.parse(value) : [];
}
function setPreferredToFieldLanguages(fromLanguageId, languageIds) {
  typeof localStorage > "u" || localStorage.setItem(`${toFieldLanguagesKeyPrefix}${fromLanguageId}`, JSON.stringify(languageIds));
}
const DEFAULT_MAX_DEPTH = 6, ABSOLUTE_MAX_DEPTH = 50;
function getDocumentMembersFlat(doc, schemaType, maxDepth2 = DEFAULT_MAX_DEPTH) {
  return sanity.isDocumentSchemaType(schemaType) ? extractPaths(doc, schemaType, [], Math.min(maxDepth2, ABSOLUTE_MAX_DEPTH)) : (console.error("Schema type is not a document"), []);
}
function extractPaths(doc, schemaType, path, maxDepth2) {
  return path.length >= maxDepth2 ? [] : schemaType.fields.reduce((acc, field) => {
    const fieldPath = [...path, field.name], fieldSchema = field.type, { value } = mutator.extractWithPath(sanity.pathToString(fieldPath), doc)[0] ?? {};
    if (!value)
      return acc;
    const thisFieldWithPath = {
      path: fieldPath,
      name: field.name,
      schemaType: fieldSchema,
      value
    };
    if (fieldSchema.jsonType === "object") {
      const innerFields = extractPaths(doc, fieldSchema, fieldPath, maxDepth2);
      return [...acc, thisFieldWithPath, ...innerFields];
    } else if (fieldSchema.jsonType === "array" && fieldSchema.of.length && fieldSchema.of.some((item) => "fields" in item) && // no reason to drill into arrays if the item fields will be culled by maxDepth, ie we need 1 extra path headroom
    path.length + 1 < maxDepth2) {
      const { value: arrayValue } = mutator.extractWithPath(sanity.pathToString(fieldPath), doc)[0] ?? {};
      let arrayPaths = [];
      if (arrayValue?.length)
        for (const item of arrayValue) {
          const itemPath = [...fieldPath, { _key: item._key }];
          let itemSchema = fieldSchema.of.find((t) => t.name === item._type);
          if (item._type || (itemSchema = fieldSchema.of[0], console.warn(
            "Array item is missing _type - using the first defined type in the array.of schema",
            {
              itemPath,
              item,
              itemSchema
            }
          )), item._key && itemSchema) {
            const innerFields = extractPaths(
              doc,
              itemSchema,
              itemPath,
              maxDepth2
            ), arrayMember = {
              path: itemPath,
              name: item._key,
              schemaType: itemSchema,
              value: item
            };
            arrayPaths = [...arrayPaths, arrayMember, ...innerFields];
          }
        }
      return [...acc, thisFieldWithPath, ...arrayPaths];
    }
    return [...acc, thisFieldWithPath];
  }, []);
}
const defaultLanguageOutputs = function(member, enclosingType, translateFromLanguageId, translateToLanguageIds) {
  if (member.schemaType.jsonType === "object" && member.schemaType.name.startsWith("internationalizedArray")) {
    const pathEnd = member.path.slice(-1);
    return (sanity.isKeySegment(pathEnd[0]) ? pathEnd[0]._key : null) === translateFromLanguageId ? translateToLanguageIds.map((translateToId) => ({
      id: translateToId,
      outputPath: [...member.path.slice(0, -1), { _key: translateToId }]
    })) : void 0;
  }
  if (enclosingType.jsonType === "object" && enclosingType.name.startsWith("locale"))
    return translateFromLanguageId === member.name ? translateToLanguageIds.map((translateToId) => ({
      id: translateToId,
      outputPath: [...member.path.slice(0, -1), translateToId]
    })) : void 0;
};
function getFieldLanguageMap(documentSchema, documentMembers, translateFromLanguageId, outputLanguageIds, langFn) {
  const translationMaps = [];
  for (const member of documentMembers) {
    const parentPath = member.path.slice(0, -1), enclosingType = documentMembers.find((m) => sanity.pathToString(m.path) === sanity.pathToString(parentPath))?.schemaType ?? documentSchema, translations = langFn(
      member,
      enclosingType,
      translateFromLanguageId,
      outputLanguageIds
    )?.filter((translation) => translation.id !== translateFromLanguageId);
    translations && translationMaps.push({
      inputLanguageId: translateFromLanguageId,
      inputPath: member.path,
      outputs: translations
    });
  }
  return translationMaps;
}
const FieldTranslationContext = react.createContext({
  openFieldTranslation: () => {
  },
  translationLoading: !1
});
function useFieldTranslation() {
  return react.useContext(FieldTranslationContext);
}
function hasValuesToTranslate(fieldLanguageMaps, fromLanguage, basePath2) {
  return fieldLanguageMaps?.some(
    (map) => map.inputLanguageId === fromLanguage?.id && map.inputPath && sanity.pathToString(map.inputPath).startsWith(sanity.pathToString(basePath2))
  );
}
function FieldTranslationProvider(props) {
  const { config: assistConfig } = useAiAssistanceConfig(), apiClient = useApiClient(assistConfig.__customApiClient), styleguide = assistConfig.translate?.styleguide, config = assistConfig.translate?.field, { translate: runTranslate } = useTranslate(apiClient), [dialogOpen, setDialogOpen] = react.useState(!1), [fieldTranslationParams, setFieldTranslationParams] = react.useState(), [languages, setLanguages] = react.useState(), [fromLanguage, setFromLanguage] = react.useState(void 0), [toLanguages, setToLanguages] = react.useState(void 0), [fieldLanguageMaps, setFieldLanguageMaps] = react.useState(), close = react.useCallback(() => {
    setDialogOpen(!1), setLanguages(void 0), setFieldTranslationParams(void 0);
  }, []), languageClient = sanity.useClient({
    apiVersion: config?.apiVersion ?? API_VERSION_WITH_EXTENDED_TYPES
  }), documentId = fieldTranslationParams?.document?._id, id = react.useId(), selectFromLanguage = react.useCallback(
    (from, languages2, params) => {
      const { document: document2, documentSchema } = params ?? {};
      if (setFromLanguage(from), !document2 || !documentSchema || !params || !languages2) {
        setFieldLanguageMaps(void 0);
        return;
      }
      const preferred = getPreferredToFieldLanguages(from.id), allToLanguages = languages2.filter((l) => l.id !== from?.id), filteredToLanguages = allToLanguages.filter(
        (l) => !preferred.length || preferred.includes(l.id)
      );
      setToLanguages(filteredToLanguages);
      const fromId = from?.id, allToIds = allToLanguages?.map((l) => l.id) ?? [], docMembers = getDocumentMembersFlat(document2, documentSchema, config?.maxPathDepth);
      if (fromId && allToIds?.length) {
        const transMap = getFieldLanguageMap(
          documentSchema,
          docMembers,
          fromId,
          allToIds.filter((toId) => fromId !== toId),
          config?.translationOutputs ?? defaultLanguageOutputs
        );
        setFieldLanguageMaps(transMap);
      } else
        setFieldLanguageMaps(void 0);
    },
    [config]
  ), toggleToLanguage = react.useCallback(
    (toggledLang, toLanguages2, languages2) => {
      if (!languages2 || !fromLanguage)
        return;
      const wasSelected = !!toLanguages2?.find((l) => l.id === toggledLang.id), newToLangs = languages2.filter(
        (anyLang) => !!toLanguages2?.find(
          (selectedLang) => toggledLang.id !== selectedLang.id && selectedLang.id === anyLang.id
        ) || toggledLang.id === anyLang.id && !wasSelected
      );
      setToLanguages(newToLangs), setPreferredToFieldLanguages(
        fromLanguage.id,
        newToLangs.map((l) => l.id)
      );
    },
    [fromLanguage]
  ), openFieldTranslation = react.useCallback(
    async (params) => {
      setDialogOpen(!0);
      const languageParams = getLanguageParams(config?.selectLanguageParams, params.document), languages2 = await (typeof config?.languages == "function" ? config?.languages(languageClient, languageParams) : Promise.resolve(config?.languages));
      setLanguages(languages2), setFieldTranslationParams(params);
      const fromLanguage2 = languages2?.[0];
      fromLanguage2 ? selectFromLanguage(fromLanguage2, languages2, params) : console.error("No languages available for selected language params", languageParams);
    },
    [selectFromLanguage, config, languageClient]
  ), contextValue = react.useMemo(() => ({
    openFieldTranslation,
    translationLoading: !1
  }), [openFieldTranslation]), runDisabled = !fromLanguage || !toLanguages?.length || !fieldLanguageMaps?.length || !documentId || !hasValuesToTranslate(fieldLanguageMaps, fromLanguage, fieldTranslationParams.translatePath), onRunTranslation = react.useCallback(() => {
    const translatePath = fieldTranslationParams?.translatePath;
    fieldLanguageMaps && documentId && translatePath && runTranslate({
      documentId,
      translatePath,
      styleguide: createStyleGuideResolver(styleguide, {
        client: languageClient,
        documentId,
        schemaType: fieldTranslationParams?.documentSchema,
        translatePath
      }),
      fieldLanguageMap: fieldLanguageMaps.map((map) => ({
        ...map,
        // eslint-disable-next-line max-nested-callbacks
        outputs: map.outputs.filter((out) => !!toLanguages?.find((l) => l.id === out.id))
      })),
      conditionalMembers: fieldTranslationParams?.conditionalMembers
    }), close();
  }, [
    fieldLanguageMaps,
    documentId,
    runTranslate,
    styleguide,
    close,
    toLanguages,
    fieldTranslationParams?.translatePath,
    fieldTranslationParams?.conditionalMembers,
    fieldTranslationParams?.documentSchema,
    languageClient
  ]), runButton = /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      text: "Translate",
      tone: "primary",
      icon: icons.PlayIcon,
      style: { width: "100%" },
      disabled: runDisabled,
      onClick: onRunTranslation
    }
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(FieldTranslationContext.Provider, { value: contextValue, children: [
    dialogOpen ? /* @__PURE__ */ jsxRuntime.jsx(
      ui.Dialog,
      {
        id,
        width: 1,
        open: dialogOpen,
        onClose: close,
        header: "Translate fields",
        footer: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { justify: "space-between", padding: 2, flex: 1, children: runDisabled ? /* @__PURE__ */ jsxRuntime.jsx(
          ui.Tooltip,
          {
            content: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "There is nothing to translate in the selected from-language." }) }),
            placement: "top",
            children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, children: runButton })
          }
        ) : runButton }),
        children: languages ? /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 4, gap: 5, align: "flex-start", justify: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "semibold", children: "From" }) }),
            languages?.map((radioLanguage) => /* @__PURE__ */ jsxRuntime.jsx(
              FromLanguageRadio,
              {
                radioLanguage,
                fromLanguage,
                selectFromLanguage,
                languages,
                fieldTranslationParams
              },
              radioLanguage.id
            ))
          ] }),
          /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
            /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { marginBottom: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { weight: "semibold", children: "To" }) }),
            languages.map((checkboxLanguage) => /* @__PURE__ */ jsxRuntime.jsx(
              ToLanguageCheckbox,
              {
                checkboxLanguage,
                fromLanguage,
                toLanguages,
                toggleToLanguage,
                languages
              },
              checkboxLanguage.id
            ))
          ] })
        ] }) : /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { padding: 4, gap: 2, align: "flex-start", justify: "center", children: [
          /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, {}) }),
          /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: "Loading languages..." })
        ] })
      }
    ) : null,
    props.children
  ] });
}
function ToLanguageCheckbox(props) {
  const { checkboxLanguage, fromLanguage, toLanguages, toggleToLanguage, languages } = props, langId = checkboxLanguage.id, onChange = react.useCallback(
    () => toggleToLanguage(checkboxLanguage, toLanguages, languages),
    [toggleToLanguage, checkboxLanguage, toLanguages, languages]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(
    ui.Flex,
    {
      gap: 3,
      align: "center",
      as: "label",
      style: langId === fromLanguage?.id ? { opacity: 0.5 } : void 0,
      children: [
        /* @__PURE__ */ jsxRuntime.jsx(
          ui.Checkbox,
          {
            name: "toLang",
            value: langId,
            checked: langId !== fromLanguage?.id && !!toLanguages?.find((tl) => tl.id === langId),
            onChange,
            disabled: langId === fromLanguage?.id
          }
        ),
        /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: langId === fromLanguage?.id, children: checkboxLanguage.title ?? langId })
      ]
    },
    langId
  );
}
function FromLanguageRadio(props) {
  const { languages, radioLanguage, selectFromLanguage, fromLanguage, fieldTranslationParams } = props, langId = radioLanguage.id, onChange = react.useCallback(
    () => selectFromLanguage(radioLanguage, languages, fieldTranslationParams),
    [selectFromLanguage, radioLanguage, languages, fieldTranslationParams]
  );
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, align: "center", as: "label", children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      ui.Radio,
      {
        name: "fromLang",
        value: langId,
        checked: langId === fromLanguage?.id,
        onChange
      }
    ),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { children: radioLanguage.title ?? radioLanguage.id })
  ] }, langId);
}
const hiddenTypes = [
  "any",
  "array",
  "block",
  "boolean",
  "crossDatasetReference",
  "date",
  "datetime",
  "document",
  "email",
  "file",
  "globalDocumentReference",
  "image",
  "number",
  "object",
  "reference",
  "span",
  "string",
  "text",
  "url",
  "slug",
  "geopoint",
  "sanity.assetSourceData",
  "sanity.imageAsset",
  "sanity.fileAsset",
  "sanity.imageCrop",
  "sanity.imageHotspot",
  "sanity.imageMetadata",
  "sanity.imageDimensions",
  "sanity.imagePalette",
  "sanity.imagePaletteSwatch",
  assistSerializedTypeName,
  assistSerializedFieldTypeName,
  "sanity-agent.job.document"
], inlineTypes = ["document", "object", "image", "file"];
function serializeSchema(schema, options2) {
  const list = schema.getTypeNames().filter((t) => !(hiddenTypes.includes(t) || t.startsWith("sanity."))).map((t) => schema.get(t)).filter((t) => !!t).map((t) => getSchemaStub(t, schema, options2)).filter((t) => !("to" in t && t.to && !t.to.length || "of" in t && t.of && !t.of.length || "fields" in t && t.fields && !t.fields.length));
  return list.sort((a, b) => (a?.name ?? "").localeCompare(b?.name ?? "")), list;
}
function getSchemaStub(schemaType, schema, options2) {
  if (!schemaType.type?.name)
    throw console.error("Missing type name", schemaType.type), new Error("Type is missing name!");
  const baseSchema = {
    // we dont need type or id when we send using POST, so leave these out to save bandwidth
    ...options2?.leanFormat ? {} : { _id: `${assistSchemaIdPrefix}${schemaType.name}`, _type: assistSerializedTypeName },
    name: schemaType.name,
    title: schemaType.title,
    type: schemaType.type.name,
    ...getBaseFields(schema, schemaType, schemaType.type.name, options2)
  };
  return removeUndef(baseSchema);
}
function getBaseFields(schema, type, typeName, options2) {
  const schemaOptions = removeUndef({
    imagePromptField: type.options?.aiAssist?.imageInstructionField,
    embeddingsIndex: type.options?.aiAssist?.embeddingsIndex
  });
  return removeUndef({
    options: Object.keys(schemaOptions).length ? schemaOptions : void 0,
    values: Array.isArray(type?.options?.list) ? type?.options?.list.map(
      (v) => typeof v == "string" ? v : v.value ?? `${v.title}`
    ) : void 0,
    of: "of" in type && typeName === "array" ? arrayOf(type, schema, options2) : void 0,
    to: "to" in type && typeName === "reference" ? refToTypeNames(type) : void 0,
    fields: "fields" in type && inlineTypes.includes(typeName) ? serializeFields(schema, type, options2) : void 0,
    annotations: typeName === "block" && "fields" in type ? serializeAnnotations(type, schema, options2) : void 0,
    inlineOf: typeName === "block" && "fields" in type ? serializeInlineOf(type, schema, options2) : void 0,
    hidden: typeof type.hidden == "function" ? "function" : type.hidden ? !0 : void 0,
    readOnly: typeof type.readOnly == "function" ? "function" : type.readOnly ? !0 : void 0
  });
}
function serializeFields(schema, schemaType, options2) {
  return (schemaType.fieldsets ? schemaType.fieldsets.flatMap(
    (fs) => fs.single ? fs.field : fs.fields.map((f) => ({
      ...f,
      type: {
        ...f.type,
        // if fieldset is (conditionally) hidden, the field must be considered the same way
        // ie, if the field does not show up in conditionalMembers, it is hidden
        // regardless of weather or not it is the field function or the fieldset function that hides it
        hidden: typeof fs.hidden == "function" ? fs.hidden : fs.hidden ? !0 : f.type.hidden
      }
    }))
  ) : schemaType.fields).filter((f) => !["sanity.imageHotspot", "sanity.imageCrop"].includes(f.type?.name ?? "")).filter((f) => isAssistSupported(f.type)).map((field) => serializeMember(schema, field.type, field.name, options2));
}
function serializeMember(schema, type, name, options2) {
  const typeName = schema.get(type?.name) ? type.name : type.type?.name ?? "";
  return removeUndef({
    ...options2?.leanFormat ? {} : { _type: assistSerializedFieldTypeName },
    name,
    type: typeName,
    title: type.title,
    ...getBaseFields(schema, type, typeName, options2)
  });
}
function serializeInlineOf(blockSchemaType, schema, options2) {
  const childrenType = blockSchemaType.fields.find((f) => f.name === "children")?.type;
  if (!(!childrenType || !sanity.isArraySchemaType(childrenType)))
    return arrayOf(
      {
        of: childrenType.of.filter((t) => !isType(t, "span"))
      },
      schema,
      options2
    );
}
function serializeAnnotations(blockSchemaType, schema, options2) {
  const marksType = blockSchemaType.fields.find((f) => f.name === "markDefs")?.type;
  if (!(!marksType || !sanity.isArraySchemaType(marksType)))
    return arrayOf(marksType, schema, options2);
}
function arrayOf(arrayType, schema, options2) {
  return arrayType.of.filter((type) => isAssistSupported(type)).map((t) => serializeMember(schema, t, t.name, options2));
}
function refToTypeNames(type) {
  return type.to.map((t) => ({
    type: sanity.typed(t.name)
  }));
}
function removeUndef(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {}), obj;
}
function createFieldRefCache() {
  const byType = {};
  function getRefsForType(schemaType) {
    const documentType = schemaType.name, cached = byType[documentType];
    if (cached) return cached;
    const fieldRefs = getFieldRefs(schemaType), fieldRefsByTypePath = asFieldRefsByTypePath(fieldRefs), refs = {
      fieldRefs,
      fieldRefsByTypePath
    };
    return byType[documentType] = refs, refs;
  }
  return getRefsForType;
}
function AiAssistanceConfigProvider(props) {
  const [status, setStatus] = react.useState(), [error, setError] = react.useState(), apiClient = useApiClient(props.config?.__customApiClient), { getInstructStatus, loading: statusLoading } = useGetInstructStatus(apiClient), { initInstruct, loading: initLoading } = useInitInstruct(apiClient), schema = sanity.useSchema(), serializedTypes = react.useMemo(() => serializeSchema(schema, { leanFormat: !0 }), [schema]), { getFieldRefs: getFieldRefs2, getFieldRefsByTypePath } = useFieldRefGetters(schema);
  react.useEffect(() => {
    getInstructStatus().then((s) => setStatus(s)).catch((e) => {
      console.error(e), setError(e);
    });
  }, [getInstructStatus]);
  const init = react.useCallback(async () => {
    setError(void 0);
    try {
      await initInstruct();
      const status2 = await getInstructStatus();
      setStatus(status2);
    } catch (e) {
      console.error("Failed to init ai assistance", e), setError(e);
    }
  }, [initInstruct, getInstructStatus, setStatus]), { config, children } = props, context = react.useMemo(() => ({
    config,
    status,
    statusLoading,
    init,
    initLoading,
    error,
    serializedTypes,
    getFieldRefs: getFieldRefs2,
    getFieldRefsByTypePath
  }), [
    config,
    status,
    init,
    statusLoading,
    initLoading,
    error,
    serializedTypes,
    getFieldRefs2,
    getFieldRefsByTypePath
  ]);
  return /* @__PURE__ */ jsxRuntime.jsx(AiAssistanceConfigContext.Provider, { value: context, children });
}
function useFieldRefGetters(schema) {
  return react.useMemo(() => {
    const getForSchemaType = createFieldRefCache();
    function getRefsForType(documentType) {
      const schemaType = schema.get(documentType);
      if (!schemaType)
        throw new Error(`Schema type "${documentType}" not found`);
      return getForSchemaType(schemaType);
    }
    return {
      getFieldRefs: (documentType) => getRefsForType(documentType).fieldRefs,
      getFieldRefsByTypePath: (documentType) => getRefsForType(documentType).fieldRefsByTypePath
    };
  }, [schema]);
}
function AssistLayout(props) {
  const [connectors, setConnectors] = react.useState([]);
  return /* @__PURE__ */ jsxRuntime.jsx(AiAssistanceConfigProvider, { config: props.config, children: /* @__PURE__ */ jsxRuntime.jsx(RunInstructionProvider, { children: /* @__PURE__ */ jsxRuntime.jsx(FieldTranslationProvider, { children: /* @__PURE__ */ jsxRuntime.jsxs(ConnectorsProvider, { onConnectorsChange: setConnectors, children: [
    props.renderDefault(props),
    /* @__PURE__ */ jsxRuntime.jsx(ui.ThemeProvider, { tone: "default", children: /* @__PURE__ */ jsxRuntime.jsx(AssistConnectorsOverlay, { connectors }) })
  ] }) }) }) });
}
const ImageContext = react.createContext({});
function ImageContextProvider(props) {
  const { schemaType, path, value, readOnly } = props, assetRef = value?.asset?._ref, { selectedReleaseId } = structure.useDocumentPane(), [assetRefState, setAssetRefState] = react.useState(assetRef), { assistableDocumentId, documentSchemaType } = useAssistDocumentContext(), { config, status } = useAiAssistanceConfig(), apiClient = useApiClient(config?.__customApiClient), { generateCaption } = useGenerateCaption(apiClient), { isSyncing } = sanity.useSyncState(
    sanity.getPublishedId(assistableDocumentId),
    documentSchemaType.name,
    selectedReleaseId
  ), isShowingOlderRevision = !!structure.usePaneRouter().params?.rev;
  react.useEffect(() => {
    const descriptionField = getDescriptionFieldOption(schemaType);
    assetRef && assistableDocumentId && descriptionField?.updateOnImageChange && assetRef !== assetRefState && !isSyncing && !isShowingOlderRevision && !readOnly && (setAssetRefState(assetRef), canUseAssist(status) && generateCaption({
      path: sanity.pathToString([...path, descriptionField.path]),
      documentId: assistableDocumentId
    }));
  }, [
    schemaType,
    path,
    assetRef,
    assetRefState,
    assistableDocumentId,
    generateCaption,
    isSyncing,
    status,
    readOnly,
    isShowingOlderRevision
  ]);
  const context = react.useMemo(() => {
    const descriptionField = getDescriptionFieldOption(schemaType), imageInstructionField = getImageInstructionFieldOption(schemaType);
    return {
      imageDescriptionPath: descriptionField?.path ? sanity.pathToString([...path, descriptionField.path]) : void 0,
      imageInstructionPath: imageInstructionField ? sanity.pathToString([...path, imageInstructionField]) : void 0,
      assetRef
    };
  }, [schemaType, path, assetRef]);
  return /* @__PURE__ */ jsxRuntime.jsx(ImageContext.Provider, { value: context, children: props.renderDefault(props) });
}
function IconInput(props) {
  const { value, onChange } = props, id = react.useId(), items = react.useMemo(
    () => Object.entries(icons.icons).map(([key, icon]) => /* @__PURE__ */ jsxRuntime.jsx(IconItem, { iconKey: key, icon, onChange }, key)),
    [onChange]
  ), selectedIcon = react.useMemo(() => getIcon(value), [value]);
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.MenuButton,
    {
      button: /* @__PURE__ */ jsxRuntime.jsx(ui.Button, { icon: selectedIcon, title: "Select icon", padding: 3, mode: "ghost", radius: 1 }),
      id,
      menu: /* @__PURE__ */ jsxRuntime.jsx(ui.Menu, { style: { maxHeight: 300 }, children: items }),
      popover: { portal: !0 }
    }
  );
}
function IconItem({
  icon,
  iconKey: key,
  onChange
}) {
  const onClick = react.useCallback(() => onChange(sanity.set(key)), [onChange, key]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.MenuItem, { icon, title: key, text: key, onClick });
}
function getIcon(iconName) {
  return Object.entries(icons.icons).find(([key]) => key === iconName)?.[1] ?? icons.icons.sparkles;
}
function useAssistSupported(path, schemaType) {
  return react.useMemo(() => isAssistSupported(schemaType), [schemaType]);
}
const translateActions = {
  name: "sanity-assist-translate",
  useAction(props) {
    const { config, status } = useAiAssistanceConfig(), apiClient = useApiClient(config?.__customApiClient), client = sanity.useClient({ apiVersion: API_VERSION_WITH_EXTENDED_TYPES }), {
      schemaType: fieldSchemaType,
      path,
      documentId,
      documentSchemaType,
      documentIsAssistable
    } = props, isDocumentLevel = path.length === 0, readOnly = fieldSchemaType.readOnly === !0, docTransTypes = config.translate?.document?.documentTypes, options2 = fieldSchemaType?.options, addFieldAction = isDocumentLevel || options2?.aiAssist?.translateAction, fieldTransEnabled = addFieldAction && documentSchemaType && config.translate?.field?.documentTypes?.includes(documentSchemaType.name), documentTranslationEnabled = addFieldAction && documentSchemaType && (!docTransTypes && isAssistSupported(fieldSchemaType) || docTransTypes?.includes(documentSchemaType.name));
    if (documentSchemaType && (documentTranslationEnabled || fieldTransEnabled)) {
      const { value: documentValue, onChange: documentOnChange, formState } = structure.useDocumentPane(), docRef = react.useRef(documentValue);
      docRef.current = documentValue;
      const formStateRef = react.useRef(formState);
      formStateRef.current = formState;
      const translationApi = useTranslate(apiClient), translate = useDraftDelayedTask({
        documentOnChange,
        isDocAssistable: documentIsAssistable ?? !1,
        task: translationApi.translate
      }), styleguide = config.translate?.styleguide, languagePath = config.translate?.document?.languageField, translateDocumentAction = react.useMemo(() => {
        if (!languagePath || !documentTranslationEnabled)
          return;
        const title = path.length ? "Translate" : "Translate document";
        return {
          type: "action",
          icon: translationApi.loading ? () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { height: 17 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { transform: "translateY(6px)" } }) }) : icons.TranslateIcon,
          title,
          onAction: () => {
            translationApi.loading || !languagePath || !documentId || translate({
              languagePath,
              translatePath: path,
              styleguide: createStyleGuideResolver(styleguide, {
                client,
                documentId,
                schemaType: documentSchemaType
              }),
              documentId: documentId ?? "",
              conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current) : []
            });
          },
          renderAsButton: !0,
          disabled: translationApi.loading || readOnly
        };
      }, [
        languagePath,
        translate,
        styleguide,
        documentId,
        translationApi.loading,
        documentTranslationEnabled,
        path,
        readOnly,
        client,
        documentSchemaType
      ]), fieldTranslate = useFieldTranslation(), openFieldTranslation = useDraftDelayedTask({
        documentOnChange,
        isDocAssistable: documentIsAssistable ?? !1,
        task: fieldTranslate.openFieldTranslation
      }), maxDepth2 = config.translate?.field?.maxPathDepth, translateFieldsAction = react.useMemo(
        () => fieldTransEnabled ? {
          type: "action",
          icon: fieldTranslate.translationLoading ? () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { height: 17 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { transform: "translateY(6px)" } }) }) : icons.TranslateIcon,
          title: "Translate fields...",
          onAction: () => {
            fieldTranslate.translationLoading || !documentId || (formStateRef.current && getConditionalMembers(formStateRef.current), openFieldTranslation({
              document: {
                ...docRef.current,
                _id: documentId
              },
              documentSchema: documentSchemaType,
              translatePath: path,
              conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current, maxDepth2) : []
            }));
          },
          renderAsButton: !0,
          disabled: fieldTranslate.translationLoading || readOnly
        } : void 0,
        [
          openFieldTranslation,
          documentSchemaType,
          documentId,
          fieldTranslate.translationLoading,
          fieldTransEnabled,
          path,
          readOnly,
          maxDepth2
        ]
      );
      return react.useMemo(() => {
        if (status?.initialized)
          return {
            type: "group",
            icon: () => null,
            title: "Translation",
            children: [translateDocumentAction, translateFieldsAction].filter(
              (c) => !!c
            ),
            expanded: !0
          };
      }, [translateDocumentAction, translateFieldsAction, status]);
    }
  }
}, generateCaptionsActions = {
  name: "sanity-assist-generate-captions",
  useAction(props) {
    const pathKey = usePathKey(props.path), { openInspector } = structure.useDocumentPane(), { config, status } = useAiAssistanceConfig(), apiClient = useApiClient(config?.__customApiClient), { generateCaption, loading } = useGenerateCaption(apiClient), imageContext = react.useContext(ImageContext);
    if (imageContext && pathKey === imageContext?.imageDescriptionPath) {
      const { assistableDocumentId } = useAssistDocumentContext();
      return react.useMemo(() => ({
        type: "action",
        icon: loading ? () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { height: 17 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { transform: "translateY(6px)" } }) }) : icons.ImageIcon,
        title: "Generate image description",
        onAction: () => {
          if (!loading) {
            if (!canUseAssist(status)) {
              openInspector(aiInspectorId, {
                [fieldPathParam]: pathKey,
                [instructionParam]: void 0
              });
              return;
            }
            generateCaption({ path: pathKey, documentId: assistableDocumentId });
          }
        },
        renderAsButton: !0,
        disabled: loading,
        hidden: !imageContext.assetRef
      }), [
        generateCaption,
        pathKey,
        assistableDocumentId,
        loading,
        imageContext,
        status,
        openInspector
      ]);
    }
  }
}, generateImagActions = {
  name: "sanity-assist-generate-image",
  useAction(props) {
    const pathKey = usePathKey(props.path), { config } = useAiAssistanceConfig(), apiClient = useApiClient(config?.__customApiClient), { generateImage, loading } = useGenerateImage(apiClient), imageContext = react.useContext(ImageContext);
    if (imageContext && pathKey === imageContext?.imageInstructionPath) {
      const { assistableDocumentId } = useAssistDocumentContext();
      return react.useMemo(() => ({
        type: "action",
        icon: loading ? () => /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { height: 17 }, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { transform: "translateY(6px)" } }) }) : icons.ImageIcon,
        title: "Generate image from prompt",
        onAction: () => {
          loading || generateImage({ path: pathKey, documentId: assistableDocumentId });
        },
        renderAsButton: !0,
        disabled: loading
      }), [generateImage, pathKey, assistableDocumentId, loading]);
    }
  }
};
function PrivateIcon() {
  return /* @__PURE__ */ jsxRuntime.jsx(
    ui.Tooltip,
    {
      content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, style: { whiteSpace: "nowrap" }, children: "Only visible to you" }),
      fallbackPlacements: ["bottom"],
      padding: 2,
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsxRuntime.jsx(icons.LockIcon, {})
    }
  );
}
function getRandomValues(typedArray) {
  const crypto = typeof window < "u" && "crypto" in window ? window.crypto : globalThis.crypto;
  if (!crypto || !crypto.getRandomValues)
    throw new Error("WebCrypto not available in this environment");
  return crypto.getRandomValues(typedArray);
}
function whatwgRNG(length = 16) {
  const rnds8 = new Uint8Array(length);
  return getRandomValues(rnds8), rnds8;
}
const getByteHexTable = /* @__PURE__ */ (() => {
  let table;
  return () => {
    if (table)
      return table;
    table = [];
    for (let i = 0; i < 256; ++i)
      table[i] = (i + 256).toString(16).substring(1);
    return table;
  };
})();
function randomKey(length) {
  const table = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table[n], "").slice(0, length);
}
function defineAssistFieldAction(action) {
  return {
    ...action,
    type: "action"
  };
}
function defineFieldActionDivider() {
  return {
    type: "divider"
  };
}
function defineAssistFieldActionGroup(group) {
  return {
    ...group,
    type: "group"
  };
}
function useCustomFieldActions(props) {
  const {
    config: { fieldActions }
  } = useAiAssistanceConfig(), { addSyntheticTask, removeSyntheticTask } = useAssistDocumentContext(), schemaId = sanity.useWorkspaceSchemaId(), { push: pushToast } = ui.useToast(), configActions = fieldActions?.useFieldActions?.({
    ...props,
    schemaId,
    path: props.path
  });
  return react.useMemo(() => {
    const title = fieldActions?.title, customActions = configActions?.filter(isDefined).map((node) => createSafeNode({
      node,
      pushToast,
      addSyntheticTask,
      removeSyntheticTask
    })).filter(isDefined), onlyGroups = customActions?.length && customActions?.every((node) => node.type === "group");
    return (customActions?.length ? onlyGroups ? customActions : [
      {
        type: "group",
        title: title || "Custom actions",
        children: customActions,
        expanded: !0
      }
    ] : []) ?? [];
  }, [configActions, fieldActions, pushToast]);
}
function createSafeNode(args) {
  const { node } = args;
  switch (node.type) {
    case "action":
      return createSafeAction({ ...args, action: node });
    case "group":
      const children = node.children?.filter(isDefined).map((child) => createSafeNode({ ...args, node: child })).filter(isDefined);
      return children?.length ? {
        ...node,
        renderAsButton: !1,
        expanded: !0,
        children
      } : void 0;
    case "divider":
    default:
      return node;
  }
}
function createSafeAction(args) {
  const { action, pushToast, addSyntheticTask, removeSyntheticTask } = args;
  return {
    ...action,
    onAction: () => {
      async function runAction() {
        const task = {
          _type: instructionTaskTypeName,
          _key: randomKey(12),
          started: (/* @__PURE__ */ new Date()).toISOString(),
          presence: [
            {
              _type: fieldPresenceTypeName,
              _key: randomKey(12),
              path: documentRootKey,
              started: (/* @__PURE__ */ new Date()).toISOString()
            }
          ]
        };
        try {
          addSyntheticTask(task);
          const actionResult = action.onAction?.();
          actionResult instanceof Promise && await actionResult;
        } catch (err) {
          console.error("Failed to execute action", action, err), pushToast({
            title: "Failed to execute action",
            description: err?.message,
            status: "error"
          });
        } finally {
          removeSyntheticTask(task);
        }
      }
      runAction();
    },
    renderAsButton: !1,
    selected: !1
  };
}
const assistFieldActions = {
  name: "sanity-assist-actions",
  useAction(props) {
    const { schemaType } = props, {
      assistDocument,
      documentIsNew,
      documentIsAssistable,
      openInspector,
      closeInspector,
      inspector,
      documentOnChange,
      documentSchemaType,
      selectedPath,
      assistableDocumentId,
      fieldRefsByTypePath
    } = useAssistDocumentContext(), { value: docValue, formState } = structure.useDocumentPane(), docValueRef = react.useRef(docValue), formStateRef = react.useRef(formState);
    formStateRef.current = formState;
    const currentUser = sanity.useCurrentUser(), isHidden = !assistDocument, pathKey = usePathKey(props.path), typePath = useTypePath(docValue, pathKey), assistDocumentId2 = assistDocument?._id, { requestRunInstruction } = useRequestRunInstruction({
      documentOnChange,
      isDocAssistable: documentIsAssistable ?? !1
    }), isSelectable = !!useSelectedField(documentSchemaType, typePath), assistSupported = useAssistSupported(props.path, schemaType) && isSelectable && isSchemaAssistEnabled(documentSchemaType) && schemaType.readOnly !== !0, fieldAssist = react.useMemo(
      () => (assistDocument?.fields ?? []).find(
        (f) => f.path === typePath || pathKey === documentRootKey && f.path === pathKey
      ),
      [assistDocument?.fields, pathKey, typePath]
    ), fieldAssistKey = fieldAssist?._key, isSelected = inspector?.name === aiInspectorId && pathKey === selectedPath, imageCaptionAction = generateCaptionsActions.useAction(props), imageGenAction = generateImagActions.useAction(props), translateAction = translateActions.useAction(
      sanity.typed({
        ...props,
        documentId: assistableDocumentId,
        documentIsAssistable,
        documentSchemaType
      })
    ), manageInstructions = react.useCallback(
      () => isSelected ? closeInspector(aiInspectorId) : openInspector(aiInspectorId, {
        [fieldPathParam]: pathKey,
        [instructionParam]: void 0
      }),
      [openInspector, closeInspector, isSelected, pathKey]
    ), onInstructionAction = react.useCallback(
      (instruction2) => {
        !pathKey || !fieldAssistKey || !assistDocumentId2 || !assistableDocumentId || requestRunInstruction({
          documentId: assistableDocumentId,
          assistDocumentId: assistDocumentId2,
          path: pathKey,
          typePath,
          instruction: instruction2,
          conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current) : []
        });
      },
      [
        requestRunInstruction,
        assistableDocumentId,
        pathKey,
        typePath,
        assistDocumentId2,
        fieldAssistKey
      ]
    ), privateInstructions = react.useMemo(
      () => fieldAssist?.instructions?.filter((i) => i.userId && i.userId === currentUser?.id) || [],
      [fieldAssist?.instructions, currentUser]
    ), sharedInstructions = react.useMemo(
      () => fieldAssist?.instructions?.filter((i) => !i.userId) || [],
      [fieldAssist?.instructions]
    ), instructions = react.useMemo(
      () => [...privateInstructions, ...sharedInstructions],
      [privateInstructions, sharedInstructions]
    ), runInstructionsGroup = react.useMemo(() => instructions?.length || imageCaptionAction || translateAction || imageGenAction ? {
      type: "group",
      icon: () => null,
      title: "Run instructions",
      children: [
        ...instructions?.map(
          (instruction2) => instructionItem({
            instruction: instruction2,
            isPrivate: !!(instruction2.userId && instruction2.userId === currentUser?.id),
            onInstructionAction,
            hidden: isHidden,
            assistSupported
          })
        ) || [],
        imageCaptionAction,
        imageGenAction
      ].filter((a) => !!a),
      expanded: !0
    } : void 0, [
      instructions,
      currentUser?.id,
      onInstructionAction,
      isHidden,
      documentIsNew,
      assistSupported,
      imageCaptionAction,
      translateAction,
      imageGenAction
    ]), getDocumentValue = react.useCallback(() => docValueRef.current, []), getConditionalPaths = react.useCallback(() => (formStateRef.current ? getConditionalMembers(formStateRef.current) : []).flatMap(
      (cm) => {
        const path = sanity.stringToPath(cm.path);
        return path.some((s) => typeof s == "number") ? [] : {
          ...cm,
          path
        };
      }
    ), []), parentSchemaType = react.useMemo(() => {
      if (props.path.length) {
        if (props.path.length === 1)
          return documentSchemaType;
      } else return;
      const parentPath = props.path.slice(0, -1), typePath2 = getTypePath(docValueRef.current, sanity.pathToString(parentPath));
      return typePath2 ? fieldRefsByTypePath[typePath2]?.schemaType : void 0;
    }, [fieldRefsByTypePath, props.path, documentSchemaType]), customActions = useCustomFieldActions({
      actionType: props.path.length ? "field" : "document",
      documentIdForAction: assistableDocumentId,
      schemaType,
      documentSchemaType,
      path: props.path,
      getDocumentValue,
      getConditionalPaths,
      parentSchemaType
    }), manageInstructionsItem = react.useMemo(
      () => ({
        type: "action",
        icon: icons.ControlsIcon,
        title: "Manage instructions",
        onAction: manageInstructions,
        selected: isSelected
      }),
      [manageInstructions, isSelected]
    ), group = react.useMemo(
      () => ({
        type: "group",
        icon: icons.SparklesIcon,
        title: pluginTitleShort,
        children: [
          runInstructionsGroup,
          translateAction,
          ...customActions,
          assistSupported && manageInstructionsItem
        ].filter((c) => !!c).filter((c) => c.type === "group" ? c.children.length : !0),
        expanded: !1,
        renderAsButton: !0,
        hidden: !assistSupported && !imageCaptionAction && !translateAction && !imageGenAction
      }),
      [
        //documentIsNew,
        runInstructionsGroup,
        manageInstructionsItem,
        assistSupported,
        imageCaptionAction,
        translateAction,
        imageGenAction,
        customActions
      ]
    ), emptyAction = react.useMemo(
      () => ({
        type: "action",
        hidden: !assistSupported,
        icon: icons.SparklesIcon,
        onAction: manageInstructions,
        renderAsButton: !0,
        title: pluginTitleShort,
        selected: isSelected
      }),
      [assistSupported, manageInstructions, isSelected]
    );
    return !instructions?.length && !imageCaptionAction && !translateAction && !imageGenAction && !customActions.length ? emptyAction : group;
  }
};
function instructionItem(props) {
  const { hidden, isPrivate, onInstructionAction, assistSupported, instruction: instruction2 } = props;
  return {
    type: "action",
    icon: getIcon(instruction2.icon),
    iconRight: isPrivate ? PrivateIcon : void 0,
    title: getInstructionTitle(instruction2),
    onAction: () => onInstructionAction(instruction2),
    disabled: !assistSupported,
    hidden
  };
}
function createAssistDocumentPresence(documentId) {
  return function() {
    return documentId ? /* @__PURE__ */ jsxRuntime.jsx(AssistDocumentPresence, {}) : null;
  };
}
function AssistDocumentPresence() {
  const { assistDocument, syntheticTasks } = useAssistDocumentContext(), anyPresence = react.useMemo(() => {
    const anyPresence2 = [...assistDocument?.tasks ?? [], ...syntheticTasks ?? []].filter((run) => !run.ended && !run.reason)?.flatMap((run) => run.presence ?? []).find((f) => f.started && (/* @__PURE__ */ new Date()).getTime() - new Date(f.started).getTime() < 3e4);
    if (anyPresence2)
      return aiPresence(anyPresence2, []);
    const anyRun = assistDocument?.tasks?.filter((run) => !run.ended && !run.reason)?.find((f) => f.started && (/* @__PURE__ */ new Date()).getTime() - new Date(f.started).getTime() < 3e4);
    return anyRun ? aiPresence(
      {
        started: anyRun.started,
        _key: anyRun._key
      },
      []
    ) : void 0;
  }, [assistDocument?.tasks, syntheticTasks]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, justify: "flex-end", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { gap: 2, align: "center", children: anyPresence && /* @__PURE__ */ jsxRuntime.jsx(AiFieldPresence, { presence: anyPresence }) }) }) });
}
function BackToInstructionListLink() {
  const { openInspector } = structure.useDocumentPane(), goBack = react.useCallback(
    () => openInspector(aiInspectorId, { [instructionParam]: void 0 }),
    [openInspector]
  );
  return /* @__PURE__ */ jsxRuntime.jsx("div", { children: /* @__PURE__ */ jsxRuntime.jsx(
    ui.Button,
    {
      as: "a",
      fontSize: 1,
      icon: icons.ArrowLeftIcon,
      mode: "bleed",
      padding: 1,
      space: 2,
      onClick: goBack,
      text: "  Instructions",
      textAlign: "left"
    }
  ) });
}
const SelectedFieldContext = react.createContext(void 0), SelectedFieldContextProvider = SelectedFieldContext.Provider, EMPTY_FIELDS = [];
function AssistDocumentForm(props) {
  return props.readOnly ? /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { border: !0, tone: "caution", padding: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: " You do not have sufficient permissions to manage instructions." }) }) : /* @__PURE__ */ jsxRuntime.jsx(AssistDocumentFormEditable, { ...props });
}
function AssistDocumentFormEditable(props) {
  const { onChange } = props, value = props.value, id = value?._id, fields = value?.fields, { params, setParams } = useAiPaneRouter(), pathKey = params[fieldPathParam], { typePath, documentType: targetDocumentType } = react.useContext(AssistTypeContext), instruction2 = params[instructionParam], activeKey = react.useMemo(() => {
    if (typePath)
      return (fields ?? EMPTY_FIELDS).find((f) => f.path === typePath)?._key;
  }, [fields, typePath]), activePath = react.useMemo(() => {
    if (!activeKey)
      return;
    const base = ["fields", { _key: activeKey }];
    return instruction2 ? [...base, "instructions", { _key: instruction2 }] : base;
  }, [activeKey, instruction2]), schema = sanity.useSchema(), documentSchema = react.useMemo(() => {
    if (targetDocumentType)
      return schema.get(targetDocumentType);
  }, [schema, targetDocumentType]), fieldSchema = useSelectedSchema(pathKey, documentSchema), context = react.useMemo(
    () => ({
      documentSchema,
      fieldSchema: fieldSchema ?? documentSchema
    }),
    [fieldSchema, documentSchema]
  ), title = value?.title;
  react.useEffect(() => {
    !title && documentSchema && !id?.startsWith("drafts.") && onChange(sanity.set(documentSchema.title ?? documentSchema.name, ["title"]));
  }, [title, documentSchema, onChange, id]);
  const { onPathOpen, ...formCallbacks } = sanity.useFormCallbacks(), newCallbacks = react.useMemo(
    () => ({
      ...formCallbacks,
      onPathOpen: (path) => {
        !instruction2 && path.length === 4 && path[2] === "instructions" ? (setParams(
          sanity.typed({
            ...params,
            [instructionParam]: path[3]?._key
          })
        ), onPathOpen([])) : setTimeout(() => onPathOpen(path), 0);
      }
    }),
    [formCallbacks, onPathOpen, params, setParams, instruction2]
  );
  react.useEffect(() => {
    activePath && !instruction2 && onPathOpen([]);
  }, [activePath, instruction2, onPathOpen]);
  const fieldError = react.useMemo(() => {
    const fieldError2 = props.members.find(
      (m) => m.kind === "error" && m.fieldName === "fields"
    );
    if (fieldError2)
      return /* @__PURE__ */ jsxRuntime.jsx(sanity.MemberFieldError, { member: fieldError2 });
  }, [props.members]);
  return /* @__PURE__ */ jsxRuntime.jsx(SelectedFieldContextProvider, { value: context, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 5, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      FieldsInitializer,
      {
        pathKey: typePath,
        activePath,
        fields,
        documentSchema,
        onChange
      },
      typePath
    ),
    instruction2 && /* @__PURE__ */ jsxRuntime.jsx(BackToInstructionListLink, {}),
    activePath && !fieldError && /* @__PURE__ */ jsxRuntime.jsx(sanity.FormCallbacksProvider, { ...newCallbacks, children: /* @__PURE__ */ jsxRuntime.jsx("div", { style: { lineHeight: "1.25em" }, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.FormInput, { ...props, absolutePath: activePath }) }) }),
    fieldError,
    !activePath && props.renderDefault(props)
  ] }) });
}
function useSelectedSchema(fieldPath, documentSchema) {
  return react.useMemo(() => {
    if (!fieldPath)
      return;
    if (fieldPath === documentRootKey)
      return documentSchema;
    const path = sanity.stringToPath(fieldPath);
    let currentSchema = documentSchema;
    for (let i = 0; i < path.length; i++) {
      const segment = path[i], field = currentSchema?.fields.find((f) => f.name === segment);
      if (!field)
        return;
      if (i === path.length - 1)
        return field.type;
      if (field.type.jsonType !== "object")
        return;
      currentSchema = field.type;
    }
    return currentSchema;
  }, [documentSchema, fieldPath]);
}
function FieldsInitializer({
  pathKey,
  activePath,
  fields,
  documentSchema,
  onChange
}) {
  const {
    config: { __presets: presets }
  } = useAiAssistanceConfig(), existingField = fields?.find((f) => f._key === pathKey), documentPresets = !!documentSchema?.name && presets?.[documentSchema?.name], missingPresetInstructions = react.useMemo(() => {
    if (!documentPresets || !pathKey)
      return;
    const existingInstructions = existingField?.instructions;
    return documentPresets.fields?.find((f) => f.path === pathKey)?.instructions?.filter(
      (i) => !existingInstructions?.some((ei) => ei._key === i._key)
    );
  }, [documentPresets, pathKey, existingField]), initialized = react.useRef(!1);
  return react.useEffect(() => {
    if (initialized.current || !pathKey || existingField && !missingPresetInstructions?.length)
      return;
    let event = sanity.PatchEvent.from([sanity.setIfMissing([], ["fields"])]);
    existingField || (event = event.append(
      sanity.insert(
        [
          sanity.typed({
            _key: pathKey,
            _type: assistFieldTypeName,
            path: pathKey,
            instructions: []
          })
        ],
        "after",
        ["fields", -1]
      )
    )), existingField?.instructions?.length || (event = event.append([sanity.setIfMissing([], ["fields", { _key: pathKey }, "instructions"])])), missingPresetInstructions?.length && (event = event.append(
      sanity.insert(
        missingPresetInstructions.map(
          (preset) => ({
            ...preset,
            _type: "sanity.assist.instruction",
            prompt: preset.prompt?.map((p) => ({ markDefs: [], ...p }))
          })
        ),
        "after",
        ["fields", { _key: pathKey }, "instructions", -1]
      )
    )), onChange(event), initialized.current = !0;
  }, [activePath, onChange, pathKey, existingField, missingPresetInstructions]), null;
}
function FieldRefPreview(props) {
  const { actions } = props, documentSchema = react.useContext(SelectedFieldContext)?.documentSchema, path = react.useContext(InlineBlockValueContext)?.path ?? props.path, selectedField = useSelectedField(documentSchema, path);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, align: "center", style: { width: "100%" }, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { flex: 1, gap: 2, align: "center", paddingY: 3, paddingX: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", children: selectedField?.title ?? "Select field" }) }) }),
    actions
  ] });
}
function HiddenFieldTitle(props) {
  return props.renderDefault({ ...props, title: "", level: props.level - 2, changed: !1 });
}
function InstructionVisibility(props) {
  const { value, onChange } = props, user = sanity.useCurrentUser(), handleChange = react.useCallback(() => {
    const newValue = value ? "" : user?.id ?? "";
    onChange(newValue ? sanity.set(newValue) : sanity.unset());
  }, [onChange, user, value]), id = react.useId();
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, align: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { style: { margin: "-3px 0" }, children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Switch,
      {
        ...props.elementProps,
        id,
        value: `${!value}`,
        checked: !value,
        onChange: handleChange,
        disabled: props.elementProps.readOnly
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, weight: "medium", children: /* @__PURE__ */ jsxRuntime.jsx("label", { htmlFor: id, children: "Make visible to all Studio members" }) })
  ] }) });
}
function FieldRefPathInput(props) {
  const documentSchema = react.useContext(SelectedFieldContext)?.documentSchema, { typePath } = react.useContext(AssistTypeContext), ref = react.useRef(null), id = react.useId(), { onChange } = props;
  react.useEffect(() => {
    ref.current?.querySelector("input")?.focus();
  }, []);
  const onSelect = react.useCallback((path) => onChange(sanity.set(path)), [onChange]), filter = react.useCallback(
    (field) => {
      if (!field.key.includes("|") || !typePath)
        return !0;
      if (field.key.includes("|") && !typePath.includes("|"))
        return !1;
      const fieldSegments = field.key.split("."), lastArrayItemIndex = fieldSegments.findLastIndex((s) => s.includes("|")), mustStartWith = fieldSegments.slice(0, lastArrayItemIndex + 1).join(".");
      return typePath.startsWith(mustStartWith);
    },
    [typePath]
  );
  return documentSchema ? /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, style: { minWidth: 300 }, ref, children: /* @__PURE__ */ jsxRuntime.jsx(
    FieldAutocomplete,
    {
      id,
      schemaType: documentSchema,
      onSelect,
      fieldPath: props.value,
      filter
    }
  ) }) : props.renderDefault(props);
}
function findFieldMember(members, fieldName) {
  return members.find(
    (m) => m.kind === "field" && m.name === fieldName || m.kind === "error" && m.fieldName === fieldName
  );
}
function findFieldsetMember(members, fieldsetName) {
  return members.find(
    (m) => m.kind === "fieldSet" && m.fieldSet.name === fieldsetName
  );
}
function InstructionInput(props) {
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: [4, 4, 4, 5], children: [
    /* @__PURE__ */ jsxRuntime.jsx(NameField, { ...props }),
    /* @__PURE__ */ jsxRuntime.jsx(ShareField, { ...props }),
    /* @__PURE__ */ jsxRuntime.jsx(ObjectMember, { fieldName: "prompt", ...props }),
    /* @__PURE__ */ jsxRuntime.jsx(ObjectMember, { fieldName: "output", ...props })
  ] });
}
function ObjectMember({ fieldName, ...props }) {
  const member = findFieldMember(props.members, fieldName);
  return member ? /* @__PURE__ */ jsxRuntime.jsx(sanity.ObjectInputMember, { ...props, member }) : null;
}
const NONE = [];
function NameField(props) {
  const fieldsetMember = findFieldsetMember(props.members, "appearance"), titleId = react.useId(), members = fieldsetMember?.fieldSet.members ?? NONE, iconMember = findFieldMember(members, "icon"), titleMember = findFieldMember(members, "title"), titlePlaceholder = "Untitled", moddedTitleMember = react.useMemo(() => {
    if (titleMember)
      return titleMember.kind === "error" ? titleMember : {
        ...titleMember,
        field: {
          ...titleMember?.field,
          schemaType: {
            ...titleMember?.field.schemaType,
            placeholder: titlePlaceholder
          }
        }
      };
  }, [titleMember, titlePlaceholder]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 5, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { gap: 1, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { as: "label", weight: "semibold", size: 1, htmlFor: titleId, children: "Name" }) }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { muted: !0, size: 1, children: "How this instruction appears in menus" }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { align: "center", children: [
      iconMember && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(sanity.ObjectInputMember, { ...props, member: iconMember }) }),
      moddedTitleMember && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: 1, style: { marginLeft: -1 }, children: /* @__PURE__ */ jsxRuntime.jsx(sanity.ObjectInputMember, { ...props, member: moddedTitleMember }) })
    ] })
  ] }) });
}
function ShareField(props) {
  const members = findFieldsetMember(props.members, "appearance")?.fieldSet.members ?? NONE, visibilityMember = findFieldMember(members, "userId");
  return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: visibilityMember && /* @__PURE__ */ jsxRuntime.jsx(sanity.ObjectInputMember, { ...props, member: visibilityMember }) });
}
function InstructionOutputField(props) {
  const { fieldSchema } = react.useContext(SelectedFieldContext) ?? {};
  return !fieldSchema || !(sanity.isObjectSchemaType(fieldSchema) || sanity.isArrayOfObjectsSchemaType(fieldSchema)) ? null : /* @__PURE__ */ jsxRuntime.jsx(EnabledOutputField, { ...props, fieldSchema, children: props.children });
}
function EnabledOutputField({
  fieldSchema,
  ...props
}) {
  const [open, setOpen] = react.useState(!!props.value?.length), onExpand = react.useCallback(() => setOpen(!0), []), onCollapse = react.useCallback(() => setOpen(!1), []);
  return props.renderDefault({
    ...props,
    collapsible: !0,
    onExpand,
    onCollapse,
    collapsed: !open,
    level: 1,
    title: sanity.isObjectSchemaType(fieldSchema) ? "Allowed fields" : "Allowed types"
  });
}
function InstructionOutputInput(props) {
  const { fieldSchema } = react.useContext(SelectedFieldContext) ?? {};
  return fieldSchema ? sanity.isObjectSchemaType(fieldSchema) ? /* @__PURE__ */ jsxRuntime.jsx(ObjectOutputInput, { ...props, fieldSchema }) : sanity.isArrayOfObjectsSchemaType(fieldSchema) ? /* @__PURE__ */ jsxRuntime.jsx(ArrayOutputInput, { ...props, fieldSchema }) : null : null;
}
function useEmptySelectAllValue(value, allowedValues, onChange) {
  react.useEffect(() => {
    const validValues = value?.filter(
      (v) => allowedValues.find(
        (f) => f.name === (v._type === outputFieldTypeName ? v.relativePath : v.type)
      )
    ), valueLength = value?.length ?? 0, validLength = validValues?.length ?? 0;
    (!validLength && valueLength || validLength >= allowedValues.length) && onChange(sanity.PatchEvent.from([sanity.unset()]));
  }, [allowedValues, value, onChange]);
}
function ObjectOutputInput({
  fieldSchema,
  ...props
}) {
  const { value, onChange } = props, fields = react.useMemo(
    () => fieldSchema.fields.filter((field) => isAssistSupported(field.type)),
    [fieldSchema.fields]
  );
  useEmptySelectAllValue(value, fields, onChange);
  const onSelectChange = react.useCallback(
    (checked, selectedValue) => {
      if (checked)
        if (value?.length)
          onChange(sanity.PatchEvent.from(sanity.unset([{ _key: selectedValue }])));
        else {
          const items = fields.filter((f) => f.name !== selectedValue).map(
            (field) => sanity.typed({
              _key: field.name,
              _type: "sanity.assist.output.field",
              relativePath: field.name
            })
          );
          onChange(sanity.PatchEvent.from([sanity.setIfMissing([]), sanity.insert(items, "after", [-1])]));
        }
      else {
        const patchValue = {
          _key: selectedValue,
          _type: "sanity.assist.output.field",
          relativePath: selectedValue
        };
        onChange(sanity.PatchEvent.from([sanity.setIfMissing([]), sanity.insert([patchValue], "after", [-1])]));
      }
    },
    [onChange, value, fields]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: fields.map((field) => /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { align: "center", gap: 2, children: /* @__PURE__ */ jsxRuntime.jsx(
    Selectable,
    {
      value: field.name,
      title: field.type.title ?? field.name,
      arrayValue: value,
      onChange: onSelectChange
    }
  ) }, field.name)) });
}
function ArrayOutputInput({
  fieldSchema,
  ...props
}) {
  const { value, onChange } = props, ofItems = react.useMemo(
    () => fieldSchema.of.filter((itemType) => isAssistSupported(itemType)),
    [fieldSchema.of]
  );
  useEmptySelectAllValue(value, ofItems, onChange);
  const onSelectChange = react.useCallback(
    (checked, selectedValue) => {
      if (checked)
        if (value?.length)
          onChange(sanity.PatchEvent.from(sanity.unset([{ _key: selectedValue }])));
        else {
          const items = ofItems.filter((f) => f.name !== selectedValue).map(
            (field) => sanity.typed({
              _key: field.name,
              _type: "sanity.assist.output.type",
              type: field.name
            })
          );
          onChange(sanity.PatchEvent.from([sanity.setIfMissing([]), sanity.insert(items, "after", [-1])]));
        }
      else {
        const patchValue = {
          _key: selectedValue,
          _type: "sanity.assist.output.type",
          type: selectedValue
        };
        onChange(sanity.PatchEvent.from([sanity.setIfMissing([]), sanity.insert([patchValue], "after", [-1])]));
      }
    },
    [onChange, value, ofItems]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { space: 2, children: ofItems.map((itemType) => /* @__PURE__ */ jsxRuntime.jsx(ui.Flex, { children: /* @__PURE__ */ jsxRuntime.jsx(
    Selectable,
    {
      value: itemType.name,
      title: isType(itemType, "block") ? "Text" : itemType.title ?? itemType.name,
      arrayValue: value,
      onChange: onSelectChange
    }
  ) }, itemType.name)) });
}
function Selectable({
  title,
  arrayValue,
  value,
  onChange
}) {
  const checked = !arrayValue?.length || !!arrayValue?.find((v) => v._key === value), handleChange = react.useCallback(() => onChange(checked, value), [onChange, checked, value]);
  return /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, align: "flex-start", children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Checkbox, { checked, onChange: handleChange }),
    /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { marginTop: 1, onClick: handleChange, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { style: { cursor: "default" }, size: 1, children: title }) })
  ] });
}
const PteMods = styledComponents.styled(ui.Box)`
  & [data-testid='pt-editor__toolbar-card'] > div > div:last-child {
    display: none;
  }
  & [data-testid='pt-editor'] {
    min-height: 300px;
  }
  & [data-testid='pt-editor'] .pt-inline-object * {
    max-width: 400px;
  }
`;
function PromptInput(props) {
  return useOnlyInlineBlocks(props), /* @__PURE__ */ jsxRuntime.jsx(PteMods, { children: props.renderDefault(props) });
}
function useOnlyInlineBlocks(props) {
  react.useEffect(() => {
    let needsFix = !1;
    const val = (props.value ?? []).map((block) => block._type === "block" ? block : (needsFix = !0, sanity.typed({
      _key: randomKey(12),
      _type: "block",
      level: 0,
      markDefs: [],
      style: "normal",
      children: [block]
    })));
    needsFix && props.onChange(sanity.set(val));
  }, []);
}
function InstructionsArrayField(props) {
  return props.renderDefault({
    ...props,
    title: " "
  });
}
function InstructionsArrayInput(props) {
  const user = sanity.useCurrentUser(), originalValue = props.value, originalMembers = props.members, value = react.useMemo(
    () => (originalValue ?? []).filter((v) => !v.userId || v.userId === user?.id),
    [originalValue, user]
  ), members = react.useMemo(
    () => (originalMembers ?? []).filter((v) => {
      if (v.kind === "error")
        return !0;
      const value2 = v?.item?.value;
      return !value2.userId || value2.userId === user?.id;
    }),
    [originalMembers, user]
  );
  return props.renderDefault({ ...props, value, members });
}
function HideReferenceChangedBannerInput(props) {
  const ref = react.useRef(null);
  return react.useEffect(() => {
    const parent = ref.current?.closest('[data-testid="pane-content"]');
    if (!parent)
      return;
    const style = document.createElement("style"), parentId = `id-${Math.random()}`.replace(".", "-");
    parent.id = parentId, style.innerText = `
      #${parentId} [data-testid="reference-changed-banner"] { display: none; }
    `, parent.prepend(style);
  }, [ref]), /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { ref, children: props.renderDefault(props) });
}
const contextDocumentSchema = sanity.defineType({
  type: "document",
  name: contextDocumentTypeName,
  title: "AI context",
  liveEdit: !0,
  icon: icons.TokenIcon,
  components: {
    input: HideReferenceChangedBannerInput
  },
  fields: [
    sanity.defineField({
      type: "string",
      name: "title",
      title: "Title"
    }),
    sanity.defineField({
      name: "context",
      type: "array",
      title: "Context",
      of: [
        sanity.defineArrayMember({
          type: "block",
          styles: [{ title: "Normal", value: "normal" }],
          lists: [],
          marks: {
            decorators: [],
            annotations: []
          }
        })
      ]
    })
  ],
  preview: {
    select: {
      title: "title",
      context: "context"
    },
    prepare({ title, context }) {
      const words = context?.flatMap((block) => block?.children).flatMap((child) => child?.text?.split(" ")).filter(Boolean)?.length ?? 0;
      return {
        title,
        subtitle: `Words: ${words}`,
        media: icons.DocumentTextIcon
      };
    }
  }
}), fieldReference = sanity.defineType({
  type: "object",
  name: fieldReferenceTypeName,
  title: "Field",
  icon: icons.ThListIcon,
  fields: [
    sanity.defineField({
      type: "string",
      name: "path",
      title: "Field",
      components: {
        input: FieldRefPathInput
      },
      validation: (rule) => {
        const getForSchemaType = createFieldRefCache();
        return rule.custom((value, context) => {
          if (!value)
            return "Please select a field";
          try {
            const docId = context.document?._id;
            if (!docId)
              return "Field reference cannot be used outside document inspector context. Could not resolve document id.";
            const targetDocType = docId.replace(new RegExp(`^${assistDocumentIdPrefix}`), ""), schema = context.schema.get(targetDocType);
            if (!schema)
              return `Field reference cannot be used outside document inspector context. Could not resolve schema: ${targetDocType}`;
            const { fieldRefs } = getForSchemaType(schema);
            return fieldRefs.find((r) => r.key === value) ? !0 : `Field with path "${value}" does not exist in the schema.`;
          } catch (e) {
            return console.error("Failed to resolve field reference", e), "Invalid field reference.";
          }
        });
      }
    })
  ],
  preview: {
    select: {
      path: "path"
    },
    prepare({ path }) {
      return {
        title: path,
        path,
        icon: icons.CodeIcon
      };
    }
  },
  components: {
    preview: FieldRefPreview
  },
  options: {
    modal: {
      type: "popover"
    }
  }
}), userInput = sanity.defineType({
  type: "object",
  name: userInputTypeName,
  title: "User input",
  icon: icons.ComposeIcon,
  fields: [
    sanity.defineField({
      type: "string",
      name: "message",
      title: "User input title",
      placeholder: "Provide instruction text",
      description: "The header above the user input text field",
      validation: (rule) => rule.required()
    }),
    sanity.defineField({
      type: "text",
      rows: 3,
      name: "description",
      title: "User input description",
      description: "The description above the user input text field"
    })
  ],
  preview: {
    select: {
      title: "message"
    }
  },
  options: {
    modal: {
      type: "popover",
      width: 1
    }
  }
}), promptContext = sanity.defineType({
  type: "object",
  name: instructionContextTypeName,
  title: contextDocumentSchema.title,
  icon: contextDocumentSchema.icon,
  fields: [
    sanity.defineField({
      type: "reference",
      name: "reference",
      to: [{ type: contextDocumentSchema.name }],
      title: "Context",
      description: "The referenced context will be inserted into the instruction",
      validation: (rule) => rule.required(),
      components: {
        input: function(props) {
          return /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { style: { maxWidth: 300 }, children: props.renderDefault(props) });
        }
      }
    })
  ],
  preview: {
    select: {
      ref: "reference._ref",
      title: "reference.title",
      context: "reference.context"
    },
    prepare(select) {
      return select.ref ? contextDocumentSchema?.preview?.prepare?.(select) ?? select : { title: "No reference selected", media: contextDocumentSchema.icon };
    }
  },
  options: {
    modal: {
      type: "popover",
      width: "auto"
    }
  }
}), prompt = sanity.defineType({
  type: "array",
  name: promptTypeName,
  title: "Prompt",
  of: [
    sanity.defineArrayMember({
      type: "block",
      styles: [{ title: "Normal", value: "normal" }],
      lists: [],
      marks: {
        decorators: [],
        annotations: []
      },
      of: [
        sanity.defineArrayMember({
          type: fieldReference.name
        }),
        sanity.defineArrayMember({
          type: promptContext.name
        }),
        sanity.defineArrayMember({
          type: userInput.name
        })
      ]
    })
    /*    defineArrayMember({
      type: fieldReference.name,
    }),
    defineArrayMember({
      type: promptContext.name,
    }),
    defineArrayMember({
      type: userInput.name,
    }),*/
  ]
}), outputFieldType = sanity.defineType({
  type: "object",
  name: outputFieldTypeName,
  title: "Output field",
  fields: [
    sanity.defineField({
      type: "string",
      name: "path",
      title: "Path"
    })
  ]
}), outputTypeType = sanity.defineType({
  type: "object",
  name: outputTypeTypeName,
  title: "Output type",
  fields: [
    sanity.defineField({
      type: "string",
      name: "type",
      title: "Type"
    })
  ]
}), instruction = sanity.defineType({
  type: "object",
  name: instructionTypeName,
  title: "Instruction",
  fieldsets: [
    { name: "appearance", title: "Appearance", options: { collapsible: !0, collapsed: !0 } }
  ],
  preview: {
    select: {
      icon: "icon",
      title: "title",
      userId: "userId"
    },
    prepare: ({ icon, title, userId }) => ({
      title,
      icon: icon ? icons.icons[icon] : icons.SparklesIcon,
      userId
    })
  },
  components: {
    input: InstructionInput,
    preview: (props) => /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 3, align: "center", padding: 2, children: [
      props.icon && /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: react.createElement(props.icon) }) }),
      /* @__PURE__ */ jsxRuntime.jsx(ui.Stack, { flex: 1, space: 2, children: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: getInstructionTitle(props) }) }),
      props.userId && /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: /* @__PURE__ */ jsxRuntime.jsx(
        ui.Tooltip,
        {
          content: /* @__PURE__ */ jsxRuntime.jsx(ui.Text, { size: 1, children: "Only visible to you" }),
          padding: 2,
          placement: "top",
          portal: !0,
          children: /* @__PURE__ */ jsxRuntime.jsx(icons.LockIcon, {})
        }
      ) })
    ] })
  },
  fields: [
    sanity.defineField({
      type: prompt.name,
      name: "prompt",
      title: "Instruction",
      description: /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        "Learn from",
        " ",
        /* @__PURE__ */ jsxRuntime.jsxs("a", { href: instructionGuideUrl, target: "_blank", rel: "noreferrer", children: [
          "our instruction guide ",
          /* @__PURE__ */ jsxRuntime.jsx(icons.ArrowRightIcon, {})
        ] })
      ] }),
      components: {
        input: PromptInput
      }
    }),
    sanity.defineField({
      type: "string",
      name: "icon",
      title: "Icon",
      fieldset: "appearance",
      components: {
        field: HiddenFieldTitle,
        input: IconInput
      }
    }),
    sanity.defineField({
      type: "string",
      name: "title",
      title: "Title",
      fieldset: "appearance",
      components: {
        field: HiddenFieldTitle
      }
    }),
    sanity.defineField({
      type: "string",
      name: "userId",
      title: "Visibility",
      fieldset: "appearance",
      components: {
        field: HiddenFieldTitle,
        input: InstructionVisibility
      },
      initialValue: (params, context) => context.currentUser?.id ?? "",
      readOnly: (context) => !!(context.parent?.createdById && context.parent?.createdById !== context.currentUser?.id)
    }),
    sanity.defineField({
      type: "string",
      name: "createdById",
      title: "Created by",
      hidden: !0,
      fieldset: "appearance",
      initialValue: (params, context) => context.currentUser?.id ?? ""
    }),
    sanity.defineField({
      type: "array",
      name: "output",
      title: "Output filter",
      components: {
        input: InstructionOutputInput,
        field: InstructionOutputField
      },
      of: [
        sanity.defineArrayMember({ type: outputFieldType.name }),
        sanity.defineArrayMember({ type: outputTypeType.name })
      ]
    })
  ]
}), fieldInstructions = sanity.defineType({
  type: "object",
  name: assistFieldTypeName,
  title: "Field prompt",
  /*  components: {
    input: FieldPromptInput,
  },*/
  fields: [
    sanity.defineField({
      type: "string",
      name: "path",
      title: "Path",
      readOnly: !0,
      hidden: !0
    }),
    sanity.defineField({
      type: "array",
      name: "instructions",
      title: "Instructions",
      of: [{ type: instruction.name }],
      components: {
        field: InstructionsArrayField,
        input: InstructionsArrayInput
      }
    })
  ],
  preview: {
    select: {
      title: "path"
    }
  }
}), assistDocumentSchema = sanity.defineType({
  //NOTE: this is a document type. Using object here ensures it does not appear in structure menus
  type: "object",
  liveEdit: !0,
  name: assistDocumentTypeName,
  title: "AI Document",
  components: {
    input: AssistDocumentForm,
    field: (props) => props.renderDefault({ ...props, title: "" })
  },
  fields: [
    sanity.defineField({
      type: "string",
      name: "title",
      title: "Title"
    }),
    sanity.defineField({
      type: "array",
      name: "fields",
      title: "Fields",
      of: [{ type: fieldInstructions.name }]
    })
  ],
  preview: {
    select: {
      title: "title"
    }
  }
}), instructionTask = sanity.defineType({
  type: "object",
  name: instructionTaskTypeName,
  title: "Instruction task",
  fields: [
    sanity.defineField({
      type: "string",
      name: "path",
      title: "Path"
    }),
    sanity.defineField({
      type: "string",
      name: "instructionKey",
      title: "Instruction key"
    }),
    sanity.defineField({
      type: "datetime",
      name: "started",
      title: "Started"
    }),
    sanity.defineField({
      type: "datetime",
      name: "updated",
      title: "Updated"
    }),
    sanity.defineField({
      type: "string",
      name: "info",
      title: "Info"
    })
  ]
}), documentInstructionStatus = sanity.defineType({
  //NOTE: this is a document type. Using object here ensures it does not appear in structure menus
  type: "object",
  liveEdit: !0,
  name: assistTasksStatusTypeName,
  title: "Document instruction status",
  fields: [
    sanity.defineField({
      type: "array",
      name: "tasks",
      title: "Tasks",
      of: [{ type: instructionTask.name }]
    })
  ]
});
function excludeComments(type) {
  const existingRender = type?.components?.field;
  return {
    ...type,
    ..."components" in type ? {
      components: {
        ...type.components,
        field: (props) => {
          const newProps = { ...props, __internal_comments: void 0 };
          return typeof existingRender == "function" ? existingRender(newProps) : props.renderDefault(newProps);
        }
      }
    } : {},
    ..."fields" in type ? {
      // recursively disable comments in fields
      fields: type.fields?.map((field) => excludeComments(field))
    } : {},
    ..."of" in type ? {
      // recursively disable comments in array items
      of: type.of?.map((arrayItemType) => excludeComments(arrayItemType))
    } : {}
  };
}
const instructionForm = [
  fieldInstructions,
  instruction,
  fieldReference,
  prompt,
  userInput,
  promptContext
].map(excludeComments), schemaTypes = [
  ...instructionForm,
  outputFieldType,
  outputTypeType,
  assistDocumentSchema,
  documentInstructionStatus,
  instructionTask,
  contextDocumentSchema
], assist = sanity.definePlugin((config) => {
  const configWithDefaults = config ?? {}, styleguide = configWithDefaults.translate?.styleguide || "", maxPathDepth = configWithDefaults.assist?.maxPathDepth, temperature = configWithDefaults.assist?.temperature;
  if (typeof styleguide == "string" && validateStyleguide(styleguide), maxPathDepth !== void 0 && (maxPathDepth < 1 || maxPathDepth > 12))
    throw new Error(
      `[${packageName}]: \`assist.maxPathDepth\` must be be in the range [1,12] inclusive, but was ${maxPathDepth}`
    );
  if (temperature !== void 0 && (temperature < 0 || temperature > 1))
    throw new Error(
      `[${packageName}]: \`assist.maxPathDepth\` must be be in the range [0,1] inclusive, but was ${temperature}`
    );
  return {
    name: packageName,
    handlesGDR: !0,
    schema: {
      types: schemaTypes
    },
    i18n: {
      bundles: [{}]
    },
    document: {
      inspectors: (prev, context) => {
        const documentType = context.documentType, docSchema = context.schema.get(documentType);
        return docSchema && isSchemaAssistEnabled(docSchema) ? [...prev, assistInspector] : prev;
      },
      unstable_fieldActions: (prev, { documentType, schema }) => {
        if (documentType === assistDocumentTypeName)
          return [];
        const docSchema = schema.get(documentType);
        return docSchema && isSchemaAssistEnabled(docSchema) ? [...prev, assistFieldActions] : prev;
      },
      unstable_languageFilter: (prev, { documentId, schema, schemaType }) => {
        if (schemaType === assistDocumentTypeName)
          return [];
        const docSchema = schema.get(schemaType);
        return docSchema && sanity.isObjectSchemaType(docSchema) && isSchemaAssistEnabled(docSchema) ? [...prev, createAssistDocumentPresence(documentId)] : prev;
      },
      components: {
        unstable_layout: AssistDocumentLayout
      }
    },
    studio: {
      components: {
        layout: function(props) {
          return /* @__PURE__ */ jsxRuntime.jsx(AssistLayout, { ...props, config: configWithDefaults });
        }
      }
    },
    form: {
      components: {
        input: AssistDocumentInputWrapper,
        field: AssistFieldWrapper,
        item: AssistItem,
        block: AssistFormBlock,
        inlineBlock: AssistInlineFormBlock
      }
    },
    plugins: [
      sanity.definePlugin({
        name: `${packageName}/safe-value-input`,
        form: { components: { input: SafeValueInput } }
      })(),
      sanity.definePlugin({
        name: `${packageName}/generate-caption`,
        form: {
          components: {
            input: (props) => {
              const { schemaType } = props;
              return isImage(schemaType) ? /* @__PURE__ */ jsxRuntime.jsx(ImageContextProvider, { ...props }) : props.renderDefault(props);
            }
          }
        }
      })()
    ]
  };
}), fetch = (client, query, params, options2) => rxjs.defer(
  () => (
    // getVersionedClient(options.apiVersion)
    client.observable.fetch(query, params, {
      tag: options2.tag,
      filterResponse: !0
    })
  )
), listen = (client, query, params, options2) => rxjs.defer(
  () => (
    // getVersionedClient(options.apiVersion)
    client.listen(query, params, {
      events: ["welcome", "mutation", "reconnect"],
      includeResult: !1,
      visibility: "query",
      tag: options2.tag
    })
  )
);
function isWelcomeEvent(event) {
  return event.type === "welcome";
}
const listenQuery = (client, query, params = {}, options2 = {}) => {
  const fetchQuery = query, listenerQuery = query, fetchOnce$ = fetch(client, fetchQuery, params, options2), events$ = listen(client, listenerQuery, params, options2).pipe(
    operators.mergeMap((ev, i) => i === 0 && !isWelcomeEvent(ev) ? rxjs.throwError(
      new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : rxjs.of(ev)),
    operators.share()
  ), [welcome$, mutationAndReconnect$] = rxjs.partition(events$, isWelcomeEvent), isRelevantEvent = (event) => !options2.transitions || event.type !== "mutation" ? !0 : options2.transitions.includes(event.transition);
  return rxjs.merge(
    welcome$.pipe(operators.take(1)),
    mutationAndReconnect$.pipe(
      operators.filter(isRelevantEvent),
      rxjs.switchMap((event) => rxjs.merge(rxjs.of(event), rxjs.of(event).pipe(rxjs.delay(options2.throttleTime || 1e3))))
    )
  ).pipe(rxjsExhaustmapWithTrailing.exhaustMapToWithTrailing(fetchOnce$));
}, DEFAULT_PARAMS = {}, DEFAULT_OPTIONS = { apiVersion: "v2022-05-09" };
function useListeningQuery(query, params = DEFAULT_PARAMS, options2 = DEFAULT_OPTIONS) {
  const [loading, setLoading] = react.useState(!0), [error, setError] = react.useState(!1), [data, setData] = react.useState(null), subscription = react.useRef(null), client = sanity.useClient({ apiVersion: "v2022-05-09" });
  return react.useEffect(() => (subscription.current = listenQuery(client, query, params, options2).pipe(
    operators.distinctUntilChanged(isEqual__default.default),
    operators.catchError((err) => (console.error(err), setError(err), setLoading(!1), setData(null), err))
  ).subscribe((documents) => {
    setData((current) => isEqual__default.default(current, documents) ? current : documents), setLoading(!1), setError(!1);
  }), () => subscription.current ? subscription.current.unsubscribe() : void 0), [query, params, options2, client]), { loading, error, data };
}
const NO_DATA = [], defaultTitle = "Sync schema";
function SchemaTypeTool() {
  const schema = sanity.useSchema(), client = sanity.useClient({ apiVersion: "2023-01-01" }), [saving, setSaving] = react.useState(!1), [syncTitle, setSyncTitle] = react.useState(defaultTitle), { data } = useListeningQuery("*[_type==$type] | order(_type)", {
    type: assistSerializedTypeName
  }), types = react.useMemo(() => serializeSchema(schema), [schema]), storeTypes = react.useCallback(() => {
    setSaving(!0);
    let canSave = !0;
    async function store() {
      setSyncTitle(`Syncing 0/${types.length}`);
      const transaction = client.transaction();
      for (let i = 0; i < types.length && canSave; i++) {
        const type = types[i];
        await transaction.createOrReplace(type), i > 0 && i % 50 === 0 && (await transaction.commit(), transaction.reset(), setSyncTitle(`Syncing ${i}/${types.length}`));
      }
      await transaction.commit();
    }
    return store().catch(console.error).finally(() => {
      setSaving(!1), setSyncTitle(defaultTitle);
    }), () => {
      canSave = !1, setSaving(!1), setSyncTitle(defaultTitle);
    };
  }, [types, client, setSaving, setSyncTitle]);
  return /* @__PURE__ */ jsxRuntime.jsx(ui.Card, { padding: 4, overflow: "auto", style: { height: "calc(100vh - 81px)" }, children: /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 4, children: [
    /* @__PURE__ */ jsxRuntime.jsx(ui.Box, { children: /* @__PURE__ */ jsxRuntime.jsx(
      ui.Button,
      {
        icon: saving ? /* @__PURE__ */ jsxRuntime.jsx(ui.Spinner, { style: { marginTop: 5 } }) : icons.SyncIcon,
        text: syncTitle,
        disabled: saving,
        onClick: storeTypes
      }
    ) }),
    /* @__PURE__ */ jsxRuntime.jsxs(ui.Flex, { gap: 2, children: [
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { children: "Studio schema" }),
        /* @__PURE__ */ jsxRuntime.jsx("ul", { children: types.map((type) => /* @__PURE__ */ jsxRuntime.jsx("li", { children: /* @__PURE__ */ jsxRuntime.jsx(SchemaEntry, { schemaStub: type }) }, type.name)) })
      ] }),
      /* @__PURE__ */ jsxRuntime.jsxs(ui.Stack, { space: 2, children: [
        /* @__PURE__ */ jsxRuntime.jsx(ui.Label, { children: "Stored schema" }),
        /* @__PURE__ */ jsxRuntime.jsx("ul", { children: (data ?? NO_DATA).map((type) => /* @__PURE__ */ jsxRuntime.jsx("li", { children: /* @__PURE__ */ jsxRuntime.jsx(SchemaEntry, { schemaStub: type }) }, type.name)) })
      ] })
    ] })
  ] }) });
}
function SchemaEntry({ schemaStub }) {
  const out = react.useMemo(() => JSON.stringify(schemaStub, null, 2), [schemaStub]);
  return /* @__PURE__ */ jsxRuntime.jsx("pre", { children: out });
}
function useUserInput() {
  const { getUserInput } = useRunInstruction();
  return getUserInput;
}
exports.SchemaTypeTool = SchemaTypeTool;
exports.assist = assist;
exports.contextDocumentTypeName = contextDocumentTypeName;
exports.defaultLanguageOutputs = defaultLanguageOutputs;
exports.defineAssistFieldAction = defineAssistFieldAction;
exports.defineAssistFieldActionGroup = defineAssistFieldActionGroup;
exports.defineFieldActionDivider = defineFieldActionDivider;
exports.isType = isType;
exports.useUserInput = useUserInput;
//# sourceMappingURL=index.js.map
