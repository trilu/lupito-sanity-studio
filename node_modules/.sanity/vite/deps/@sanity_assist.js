import {
  Autocomplete,
  Badge,
  Box,
  Breadcrumbs,
  Button,
  Card,
  Checkbox,
  Container,
  Dialog,
  ErrorBoundary,
  Flex,
  Label,
  Menu,
  MenuButton,
  MenuItem,
  Popover,
  Radio,
  Spinner,
  Stack,
  Switch,
  Text,
  TextArea,
  ThemeProvider,
  Tooltip,
  focusFirstDescendant,
  rgba,
  useClickOutside,
  useGlobalKeyDown,
  useLayer,
  useTheme,
  useToast
} from "./chunk-SI7WLV7N.js";
import "./chunk-XCTHCOCC.js";
import {
  DocumentInspectorHeader,
  DocumentPaneProviderWrapper,
  useDocumentPane,
  usePaneRouter
} from "./chunk-57HG47OU.js";
import "./chunk-LGPJGGGV.js";
import {
  FormBuilder,
  FormCallbacksProvider,
  FormFieldHeaderText,
  FormInput,
  MemberFieldError,
  ObjectInputMember,
  PatchEvent,
  PresenceOverlay,
  StatusButton,
  VirtualizerScrollInstanceProvider,
  catchError,
  createPatchChannel,
  defer,
  defineArrayMember,
  defineField,
  definePlugin,
  defineType,
  delay,
  distinctUntilChanged,
  exhaustMapToWithTrailing,
  filter,
  fromMutationPatches,
  getDraftId,
  getPublishedId,
  getVersionFromId,
  getVersionId,
  insert$1,
  isArrayOfObjectsSchemaType,
  isArraySchemaType,
  isDocumentSchemaType,
  isKeySegment,
  isObjectSchemaType,
  isVersionId,
  merge,
  mergeMap,
  of,
  partition,
  pathToString$1,
  require_browser,
  require_compact,
  require_flatten,
  require_isEqual,
  require_max,
  require_min,
  require_react_fast_compare,
  set,
  setIfMissing,
  share,
  stringToPath,
  switchMap,
  take,
  tap,
  throwError,
  typed,
  unset,
  useClient,
  useColorSchemeValue,
  useCurrentUser,
  useDocumentPresence,
  useDocumentStore,
  useEditState,
  useFormCallbacks,
  useSchema,
  useSyncState,
  useWorkspaceSchemaId
} from "./chunk-FHVXKJW5.js";
import {
  ArrowLeftIcon,
  ArrowRightIcon,
  BlockContentIcon,
  BlockquoteIcon,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ClockIcon,
  CloseCircleIcon,
  CloseIcon,
  CodeIcon,
  ComposeIcon,
  ControlsIcon,
  DocumentIcon,
  DocumentTextIcon,
  ErrorOutlineIcon,
  ImageIcon,
  LinkIcon,
  LockIcon,
  OlistIcon,
  PlayIcon,
  RetryIcon,
  SearchIcon,
  SparklesIcon,
  StringIcon,
  SyncIcon,
  ThListIcon,
  TokenIcon,
  TranslateIcon,
  dt,
  icons,
  mt
} from "./chunk-PQROEMTX.js";
import "./chunk-WJLLNO3V.js";
import "./chunk-IXSRL44D.js";
import "./chunk-6IWEX3NL.js";
import "./chunk-QCUVG3AT.js";
import "./chunk-CDX2NSI4.js";
import "./chunk-ZPM4MNTQ.js";
import "./chunk-IFA4374Z.js";
import "./chunk-NEXU56M6.js";
import {
  require_jsx_runtime
} from "./chunk-LGTJEIUF.js";
import {
  require_react
} from "./chunk-VQL2BDRS.js";
import {
  __publicField,
  __toESM
} from "./chunk-HFZ37CMS.js";

// node_modules/@sanity/assist/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react = __toESM(require_react(), 1);

// node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}

// node_modules/date-fns/constructFrom.mjs
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

// node_modules/date-fns/addDays.mjs
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/addMilliseconds.mjs
function addMilliseconds(date, amount) {
  const timestamp = +toDate(date);
  return constructFrom(date, timestamp + amount);
}

// node_modules/date-fns/constants.mjs
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var minutesInMonth = 43200;
var minutesInDay = 1440;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/_lib/defaultOptions.mjs
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

// node_modules/date-fns/startOfWeek.mjs
function startOfWeek(date, options2) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfISOWeek.mjs
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}

// node_modules/date-fns/getISOWeekYear.mjs
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/startOfISOWeekYear.mjs
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/addSeconds.mjs
function addSeconds(date, amount) {
  return addMilliseconds(date, amount * 1e3);
}

// node_modules/date-fns/compareAsc.mjs
function compareAsc(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const diff = _dateLeft.getTime() - _dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}

// node_modules/date-fns/constructNow.mjs
function constructNow(date) {
  return constructFrom(date, Date.now());
}

// node_modules/date-fns/differenceInCalendarMonths.mjs
function differenceInCalendarMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const yearDiff = _dateLeft.getFullYear() - _dateRight.getFullYear();
  const monthDiff = _dateLeft.getMonth() - _dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}

// node_modules/date-fns/_lib/getRoundingMethod.mjs
function getRoundingMethod(method2) {
  return (number) => {
    const round2 = method2 ? Math[method2] : Math.trunc;
    const result2 = round2(number);
    return result2 === 0 ? 0 : result2;
  };
}

// node_modules/date-fns/differenceInMilliseconds.mjs
function differenceInMilliseconds(dateLeft, dateRight) {
  return +toDate(dateLeft) - +toDate(dateRight);
}

// node_modules/date-fns/endOfDay.mjs
function endOfDay(date) {
  const _date = toDate(date);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/endOfMonth.mjs
function endOfMonth(date) {
  const _date = toDate(date);
  const month = _date.getMonth();
  _date.setFullYear(_date.getFullYear(), month + 1, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}

// node_modules/date-fns/isLastDayOfMonth.mjs
function isLastDayOfMonth(date) {
  const _date = toDate(date);
  return +endOfDay(_date) === +endOfMonth(_date);
}

// node_modules/date-fns/differenceInMonths.mjs
function differenceInMonths(dateLeft, dateRight) {
  const _dateLeft = toDate(dateLeft);
  const _dateRight = toDate(dateRight);
  const sign = compareAsc(_dateLeft, _dateRight);
  const difference2 = Math.abs(
    differenceInCalendarMonths(_dateLeft, _dateRight)
  );
  let result2;
  if (difference2 < 1) {
    result2 = 0;
  } else {
    if (_dateLeft.getMonth() === 1 && _dateLeft.getDate() > 27) {
      _dateLeft.setDate(30);
    }
    _dateLeft.setMonth(_dateLeft.getMonth() - sign * difference2);
    let isLastMonthNotFull = compareAsc(_dateLeft, _dateRight) === -sign;
    if (isLastDayOfMonth(toDate(dateLeft)) && difference2 === 1 && compareAsc(dateLeft, _dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result2 = sign * (difference2 - Number(isLastMonthNotFull));
  }
  return result2 === 0 ? 0 : result2;
}

// node_modules/date-fns/differenceInSeconds.mjs
function differenceInSeconds(dateLeft, dateRight, options2) {
  const diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options2 == null ? void 0 : options2.roundingMethod)(diff);
}

// node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count, options2) => {
  let result2;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result2 = tokenValue;
  } else if (count === 1) {
    result2 = tokenValue.one;
  } else {
    result2 = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options2 == null ? void 0 : options2.addSuffix) {
    if (options2.comparison && options2.comparison > 0) {
      return "in " + result2;
    } else {
      return result2 + " ago";
    }
  }
  return result2;
};

// node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
function buildFormatLongFn(args) {
  return (options2 = {}) => {
    const width = options2.width ? String(options2.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
function buildLocalizeFn(args) {
  return (value, options2) => {
    const context = (options2 == null ? void 0 : options2.context) ? String(options2.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options2 == null ? void 0 : options2.width) ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options2 == null ? void 0 : options2.width) ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}

// node_modules/date-fns/locale/en-US/_lib/localize.mjs
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/_lib/buildMatchFn.mjs
function buildMatchFn(args) {
  return (string, options2 = {}) => {
    const width = options2.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options2.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options2.valueCallback(value)
    ) : value;
    const rest2 = string.slice(matchedString.length);
    return { value, rest: rest2 };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
function buildMatchPatternFn(args) {
  return (string, options2 = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options2.valueCallback ? options2.valueCallback(value) : value;
    const rest2 = string.slice(matchedString.length);
    return { value, rest: rest2 };
  };
}

// node_modules/date-fns/locale/en-US/_lib/match.mjs
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/en-US.mjs
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/date-fns/getISOWeek.mjs
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.mjs
function getWeekYear(date, options2) {
  var _a, _b, _c, _d;
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options2);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options2);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.mjs
function startOfWeekYear(date, options2) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const firstWeekContainsDate = (options2 == null ? void 0 : options2.firstWeekContainsDate) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions2.firstWeekContainsDate ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options2);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options2);
  return _date;
}

// node_modules/date-fns/getWeek.mjs
function getWeek(date, options2) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options2) - +startOfWeekYear(_date, options2);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/formatDistance.mjs
function formatDistance2(date, baseDate, options2) {
  const defaultOptions2 = getDefaultOptions();
  const locale = (options2 == null ? void 0 : options2.locale) ?? defaultOptions2.locale ?? enUS;
  const minutesInAlmostTwoDays = 2520;
  const comparison = compareAsc(date, baseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  const localizeOptions = Object.assign({}, options2, {
    addSuffix: options2 == null ? void 0 : options2.addSuffix,
    comparison
  });
  let dateLeft;
  let dateRight;
  if (comparison > 0) {
    dateLeft = toDate(baseDate);
    dateRight = toDate(date);
  } else {
    dateLeft = toDate(date);
    dateRight = toDate(baseDate);
  }
  const seconds = differenceInSeconds(dateRight, dateLeft);
  const offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
  const minutes = Math.round((seconds - offsetInSeconds) / 60);
  let months;
  if (minutes < 2) {
    if (options2 == null ? void 0 : options2.includeSeconds) {
      if (seconds < 5) {
        return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < minutesInDay) {
    const hours = Math.round(minutes / 60);
    return locale.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < minutesInAlmostTwoDays) {
    return locale.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < minutesInMonth) {
    const days = Math.round(minutes / minutesInDay);
    return locale.formatDistance("xDays", days, localizeOptions);
  } else if (minutes < minutesInMonth * 2) {
    months = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("aboutXMonths", months, localizeOptions);
  }
  months = differenceInMonths(dateRight, dateLeft);
  if (months < 12) {
    const nearestMonth = Math.round(minutes / minutesInMonth);
    return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    const monthsSinceStartOfYear = months % 12;
    const years = Math.trunc(months / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}

// node_modules/date-fns/formatDistanceToNow.mjs
function formatDistanceToNow(date, options2) {
  return formatDistance2(date, constructNow(date), options2);
}

// node_modules/date-fns/getISODay.mjs
function getISODay(date) {
  const _date = toDate(date);
  let day = _date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}

// node_modules/date-fns/isAfter.mjs
function isAfter(date, dateToCompare) {
  const _date = toDate(date);
  const _dateToCompare = toDate(dateToCompare);
  return _date.getTime() > _dateToCompare.getTime();
}

// node_modules/date-fns/parse/_lib/Setter.mjs
var Setter = class {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options2) {
    return this.validateValue(date, this.value, options2);
  }
  set(date, flags, options2) {
    return this.setValue(date, flags, this.value, options2);
  }
};

// node_modules/date-fns/parse/_lib/Parser.mjs
var Parser = class {
  run(dateString, token, match2, options2) {
    const result2 = this.parse(dateString, token, match2, options2);
    if (!result2) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result2.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result2.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/date-fns/parse/_lib/parsers/EraParser.mjs
var EraParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      // A, B
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/constants.mjs
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/parse/_lib/utils.mjs
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result2;
  if (absCurrentYear <= 50) {
    result2 = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result2 = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result2 : 1 - result2;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/parse/_lib/parsers/YearParser.mjs
var YearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.mjs
var LocalWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options2) {
    const currentYear = getWeekYear(date, options2);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options2.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options2);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options2.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options2);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.mjs
var ISOWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.mjs
var ExtendedYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.mjs
var QuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.mjs
var StandAloneQuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MonthParser.mjs
var MonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      // J, F, ..., D
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.mjs
var StandAloneMonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      // J, F, ..., D
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setWeek.mjs
function setWeek(date, week, options2) {
  const _date = toDate(date);
  const diff = getWeek(_date, options2) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.mjs
var LocalWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options2) {
    return startOfWeek(setWeek(date, value, options2), options2);
  }
};

// node_modules/date-fns/setISOWeek.mjs
function setISOWeek(date, week) {
  const _date = toDate(date);
  const diff = getISOWeek(_date) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.mjs
var ISOWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
};

// node_modules/date-fns/parse/_lib/parsers/DateParser.mjs
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.mjs
var DayOfYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setDay.mjs
function setDay(date, day, options2) {
  var _a, _b, _c, _d;
  const defaultOptions2 = getDefaultOptions();
  const weekStartsOn = (options2 == null ? void 0 : options2.weekStartsOn) ?? ((_b = (_a = options2 == null ? void 0 : options2.locale) == null ? void 0 : _a.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions2.weekStartsOn ?? ((_d = (_c = defaultOptions2.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const currentDay = _date.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(_date, diff);
}

// node_modules/date-fns/parse/_lib/parsers/DayParser.mjs
var DayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options2) {
    date = setDay(date, value, options2);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.mjs
var LocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options2) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options2) {
    date = setDay(date, value, options2);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.mjs
var StandAloneLocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options2) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options2.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      // T
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      // Tuesday
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options2) {
    date = setDay(date, value, options2);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setISODay.mjs
function setISODay(date, day) {
  const _date = toDate(date);
  const currentDay = getISODay(_date);
  const diff = day - currentDay;
  return addDays(_date, diff);
}

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.mjs
var ISODayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      // 2
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      // 2nd
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // T
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tu
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tuesday
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.mjs
var AMPMParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.mjs
var AMPMMidnightParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.mjs
var DayPeriodParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.mjs
var Hour1to12Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.mjs
var Hour0to23Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.mjs
var Hour0To11Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.mjs
var Hour1To24Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.mjs
var MinuteParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/SecondParser.mjs
var SecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.mjs
var FractionOfSecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.mjs
var ISOTimezoneWithZParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.mjs
var ISOTimezoneParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.mjs
var TimestampSecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.mjs
var TimestampMillisecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers.mjs
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/date-fns/minutesToMilliseconds.mjs
function minutesToMilliseconds(minutes) {
  return Math.trunc(minutes * millisecondsInMinute);
}

// node_modules/@sanity/mutator/lib/index.mjs
var import_isEqual = __toESM(require_isEqual(), 1);
var import_debug = __toESM(require_browser(), 1);
var import_flatten = __toESM(require_flatten(), 1);
var import_max2 = __toESM(require_max(), 1);
var import_min2 = __toESM(require_min(), 1);
var import_compact = __toESM(require_compact(), 1);
var debug = (0, import_debug.default)("mutator-document");
function isRecord(value) {
  return value !== null && typeof value == "object";
}
function descend$1(tail2) {
  const [head2, newTail] = splitIfPath(tail2);
  if (!head2)
    throw new Error("Head cannot be null");
  return spreadIfUnionHead(head2, newTail);
}
function splitIfPath(tail2) {
  if (tail2.type !== "path")
    return [tail2, null];
  const nodes = tail2.nodes;
  return nodes.length === 0 ? [null, null] : nodes.length === 1 ? [nodes[0], null] : [nodes[0], { type: "path", nodes: nodes.slice(1) }];
}
function concatPaths(path1, path2) {
  if (!path1 && !path2)
    return null;
  const nodes1 = path1 ? path1.nodes : [], nodes2 = path2 ? path2.nodes : [];
  return {
    type: "path",
    nodes: nodes1.concat(nodes2)
  };
}
function spreadIfUnionHead(head2, tail2) {
  return head2.type !== "union" ? [[head2, tail2]] : head2.nodes.map((node) => {
    if (node.type === "path") {
      const [subHead, subTail] = splitIfPath(node);
      return [subHead, concatPaths(subTail, tail2)];
    }
    return [node, tail2];
  });
}
var digitChar = /[0-9]/;
var attributeCharMatcher = /^[a-zA-Z0-9_]$/;
var attributeFirstCharMatcher = /^[a-zA-Z_]$/;
var symbols = {
  // NOTE: These are compared against in order of definition,
  // thus '==' must come before '=', '>=' before '>', etc.
  operator: ["..", ".", ",", ":", "?"],
  comparator: [">=", "<=", "<", ">", "==", "!="],
  keyword: ["$", "@"],
  boolean: ["true", "false"],
  paren: ["[", "]"]
};
var symbolClasses = Object.keys(symbols);
var Tokenizer = class {
  constructor(path) {
    __publicField(this, "source");
    __publicField(this, "i");
    __publicField(this, "length");
    __publicField(this, "tokenizers");
    this.source = path, this.length = path.length, this.i = 0, this.tokenizers = [
      this.tokenizeSymbol,
      this.tokenizeIdentifier,
      this.tokenizeNumber,
      this.tokenizeQuoted
    ].map((fn) => fn.bind(this));
  }
  tokenize() {
    const result2 = [];
    for (; !this.EOF(); ) {
      this.chompWhitespace();
      let token = null;
      if (!this.tokenizers.some((tokenizer) => (token = tokenizer(), !!token)) || !token)
        throw new Error(`Invalid tokens in jsonpath '${this.source}' @ ${this.i}`);
      result2.push(token);
    }
    return result2;
  }
  takeWhile(fn) {
    const start = this.i;
    let result2 = "";
    for (; !this.EOF(); ) {
      const nextChar = fn(this.source[this.i]);
      if (nextChar === null)
        break;
      result2 += nextChar, this.i++;
    }
    return this.i === start ? null : result2;
  }
  EOF() {
    return this.i >= this.length;
  }
  peek() {
    return this.EOF() ? null : this.source[this.i];
  }
  consume(str) {
    if (this.i + str.length > this.length)
      throw new Error(`Expected ${str} at end of jsonpath`);
    if (str === this.source.slice(this.i, this.i + str.length))
      this.i += str.length;
    else
      throw new Error(`Expected "${str}", but source contained "${this.source.slice()}`);
  }
  // Tries to match the upcoming bit of string with the provided string. If it matches, returns
  // the string, then advances the read pointer to the next bit. If not, returns null and nothing
  // happens.
  tryConsume(str) {
    if (this.i + str.length > this.length)
      return null;
    if (str === this.source.slice(this.i, this.i + str.length)) {
      if (str[0].match(attributeCharMatcher) && this.length > this.i + str.length) {
        const nextChar = this.source[this.i + str.length];
        if (nextChar && nextChar.match(attributeCharMatcher))
          return null;
      }
      return this.i += str.length, str;
    }
    return null;
  }
  chompWhitespace() {
    this.takeWhile((char) => char === " " ? "" : null);
  }
  tokenizeQuoted() {
    const quote = this.peek();
    if (quote === "'" || quote === '"') {
      this.consume(quote);
      let escape2 = false;
      const inner = this.takeWhile((char) => escape2 ? (escape2 = false, char) : char === "\\" ? (escape2 = true, "") : char != quote ? char : null);
      return this.consume(quote), {
        type: "quoted",
        value: inner,
        quote: quote === '"' ? "double" : "single"
      };
    }
    return null;
  }
  tokenizeIdentifier() {
    let first = true;
    const identifier = this.takeWhile((char) => first ? (first = false, char.match(attributeFirstCharMatcher) ? char : null) : char.match(attributeCharMatcher) ? char : null);
    return identifier !== null ? {
      type: "identifier",
      name: identifier
    } : null;
  }
  tokenizeNumber() {
    const start = this.i;
    let dotSeen = false, digitSeen = false, negative = false;
    this.peek() === "-" && (negative = true, this.consume("-"));
    const number = this.takeWhile((char) => char === "." && !dotSeen && digitSeen ? (dotSeen = true, char) : (digitSeen = true, char.match(digitChar) ? char : null));
    return number !== null ? {
      type: "number",
      value: negative ? -number : +number,
      raw: negative ? `-${number}` : number
    } : (this.i = start, null);
  }
  tokenizeSymbol() {
    for (const symbolClass of symbolClasses) {
      const symbol = symbols[symbolClass].find((pattern) => this.tryConsume(pattern));
      if (symbol)
        return {
          type: symbolClass,
          symbol
        };
    }
    return null;
  }
};
function tokenize(jsonpath) {
  return new Tokenizer(jsonpath).tokenize();
}
var Parser2 = class {
  constructor(path) {
    __publicField(this, "tokens");
    __publicField(this, "length");
    __publicField(this, "i");
    this.tokens = tokenize(path), this.length = this.tokens.length, this.i = 0;
  }
  parse() {
    return this.parsePath();
  }
  EOF() {
    return this.i >= this.length;
  }
  // Look at upcoming token
  peek() {
    return this.EOF() ? null : this.tokens[this.i];
  }
  consume() {
    const result2 = this.peek();
    return this.i += 1, result2;
  }
  // Return next token if it matches the pattern
  probe(pattern) {
    const token = this.peek();
    if (!token)
      return null;
    const record = token;
    return Object.keys(pattern).every((key) => key in token && pattern[key] === record[key]) ? token : null;
  }
  // Return and consume next token if it matches the pattern
  match(pattern) {
    return this.probe(pattern) ? this.consume() : null;
  }
  parseAttribute() {
    const token = this.match({ type: "identifier" });
    if (token && token.type === "identifier")
      return {
        type: "attribute",
        name: token.name
      };
    const quoted = this.match({ type: "quoted", quote: "single" });
    return quoted && quoted.type === "quoted" ? {
      type: "attribute",
      name: quoted.value || ""
    } : null;
  }
  parseAlias() {
    return this.match({ type: "keyword", symbol: "@" }) || this.match({ type: "keyword", symbol: "$" }) ? {
      type: "alias",
      target: "self"
    } : null;
  }
  parseNumber() {
    const token = this.match({ type: "number" });
    return token && token.type === "number" ? {
      type: "number",
      value: token.value
    } : null;
  }
  parseNumberValue() {
    const expr = this.parseNumber();
    return expr ? expr.value : null;
  }
  parseSliceSelector() {
    const start = this.i, rangeStart = this.parseNumberValue();
    if (!this.match({ type: "operator", symbol: ":" }))
      return rangeStart === null ? (this.i = start, null) : { type: "index", value: rangeStart };
    const result2 = {
      type: "range",
      start: rangeStart,
      end: this.parseNumberValue()
    };
    return this.match({ type: "operator", symbol: ":" }) && (result2.step = this.parseNumberValue()), result2.start === null && result2.end === null ? (this.i = start, null) : result2;
  }
  parseValueReference() {
    return this.parseAttribute() || this.parseSliceSelector();
  }
  parseLiteralValue() {
    const literalString = this.match({ type: "quoted", quote: "double" });
    if (literalString && literalString.type === "quoted")
      return {
        type: "string",
        value: literalString.value || ""
      };
    const literalBoolean = this.match({ type: "boolean" });
    return literalBoolean && literalBoolean.type === "boolean" ? {
      type: "boolean",
      value: literalBoolean.symbol === "true"
    } : this.parseNumber();
  }
  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
  // on lhs.
  parseFilterExpression() {
    const start = this.i, expr = this.parseAttribute() || this.parseAlias();
    if (!expr)
      return null;
    if (this.match({ type: "operator", symbol: "?" }))
      return {
        type: "constraint",
        operator: "?",
        lhs: expr
      };
    const binOp = this.match({ type: "comparator" });
    if (!binOp || binOp.type !== "comparator")
      return this.i = start, null;
    const lhs = expr, rhs = this.parseLiteralValue();
    if (!rhs)
      throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`);
    return {
      type: "constraint",
      operator: binOp.symbol,
      lhs,
      rhs
    };
  }
  parseExpression() {
    return this.parseFilterExpression() || this.parseValueReference();
  }
  parseUnion() {
    if (!this.match({ type: "paren", symbol: "[" }))
      return null;
    const terms = [];
    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference();
    for (; expr && (terms.push(expr), !this.match({ type: "paren", symbol: "]" })); ) {
      if (!this.match({ type: "operator", symbol: "," }))
        throw new Error("Expected ]");
      if (expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference(), !expr)
        throw new Error("Expected expression following ','");
    }
    return {
      type: "union",
      nodes: terms
    };
  }
  parseRecursive() {
    if (!this.match({ type: "operator", symbol: ".." }))
      return null;
    const subpath = this.parsePath();
    if (!subpath)
      throw new Error("Expected path following '..' operator");
    return {
      type: "recursive",
      term: subpath
    };
  }
  parsePath() {
    const nodes = [], expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive();
    if (!expr)
      return null;
    for (nodes.push(expr); !this.EOF(); )
      if (this.match({ type: "operator", symbol: "." })) {
        const attr = this.parseAttribute();
        if (!attr)
          throw new Error("Expected attribute name following '.");
        nodes.push(attr);
        continue;
      } else if (this.probe({ type: "paren", symbol: "[" })) {
        const union2 = this.parseUnion();
        if (!union2)
          throw new Error("Expected union following '['");
        nodes.push(union2);
      } else {
        const recursive = this.parseRecursive();
        recursive && nodes.push(recursive);
        break;
      }
    return nodes.length === 1 ? nodes[0] : {
      type: "path",
      nodes
    };
  }
};
function parseJsonPath(path) {
  const parsed = new Parser2(path).parse();
  if (!parsed)
    throw new Error(`Failed to parse JSON path "${path}"`);
  return parsed;
}
function toPath(expr) {
  return toPathInner(expr, false);
}
function toPathInner(expr, inUnion) {
  switch (expr.type) {
    case "attribute":
      return expr.name;
    case "alias":
      return expr.target === "self" ? "@" : "$";
    case "number":
      return `${expr.value}`;
    case "range": {
      const result2 = [];
      return inUnion || result2.push("["), expr.start && result2.push(`${expr.start}`), result2.push(":"), expr.end && result2.push(`${expr.end}`), expr.step && result2.push(`:${expr.step}`), inUnion || result2.push("]"), result2.join("");
    }
    case "index":
      return inUnion ? `${expr.value}` : `[${expr.value}]`;
    case "constraint": {
      const rhs = expr.rhs ? ` ${toPathInner(expr.rhs, false)}` : "", inner = `${toPathInner(expr.lhs, false)} ${expr.operator}${rhs}`;
      return inUnion ? inner : `[${inner}]`;
    }
    case "string":
      return JSON.stringify(expr.value);
    case "path": {
      const result2 = [], nodes = expr.nodes.slice();
      for (; nodes.length > 0; ) {
        const node = nodes.shift();
        node && result2.push(toPath(node));
        const upcoming = nodes[0];
        upcoming && toPathInner(upcoming, false)[0] !== "[" && result2.push(".");
      }
      return result2.join("");
    }
    case "union":
      return `[${expr.nodes.map((e) => toPathInner(e, true)).join(",")}]`;
    default:
      throw new Error(`Unknown node type ${expr.type}`);
    case "recursive":
      return `..${toPathInner(expr.term, false)}`;
  }
}
var Expression = class _Expression {
  constructor(expr) {
    __publicField(this, "expr");
    if (!expr)
      throw new Error("Attempted to create Expression from null-value");
    if ("expr" in expr ? this.expr = expr.expr : this.expr = expr, !("type" in this.expr))
      throw new Error("Attempt to create Expression for expression with no type");
  }
  isPath() {
    return this.expr.type === "path";
  }
  isUnion() {
    return this.expr.type === "union";
  }
  isCollection() {
    return this.isPath() || this.isUnion();
  }
  isConstraint() {
    return this.expr.type === "constraint";
  }
  isRecursive() {
    return this.expr.type === "recursive";
  }
  isExistenceConstraint() {
    return this.expr.type === "constraint" && this.expr.operator === "?";
  }
  isIndex() {
    return this.expr.type === "index";
  }
  isRange() {
    return this.expr.type === "range";
  }
  expandRange(probe) {
    const probeLength = () => {
      if (!probe)
        throw new Error("expandRange() required a probe that was not passed");
      return probe.length();
    };
    let start = "start" in this.expr && this.expr.start || 0;
    start = interpretNegativeIndex(start, probe);
    let end = "end" in this.expr && this.expr.end || probeLength();
    end = interpretNegativeIndex(end, probe);
    const step = "step" in this.expr && this.expr.step || 1;
    return { start, end, step };
  }
  isAttributeReference() {
    return this.expr.type === "attribute";
  }
  // Is a range or index -> something referencing indexes
  isIndexReference() {
    return this.isIndex() || this.isRange();
  }
  name() {
    return "name" in this.expr ? this.expr.name : "";
  }
  isSelfReference() {
    return this.expr.type === "alias" && this.expr.target === "self";
  }
  constraintTargetIsSelf() {
    return this.expr.type === "constraint" && this.expr.lhs.type === "alias" && this.expr.lhs.target === "self";
  }
  constraintTargetIsAttribute() {
    return this.expr.type === "constraint" && this.expr.lhs.type === "attribute";
  }
  testConstraint(probe) {
    const expr = this.expr;
    if (expr.type === "constraint" && expr.lhs.type === "alias" && expr.lhs.target === "self") {
      if (probe.containerType() !== "primitive")
        return false;
      if (expr.type === "constraint" && expr.operator === "?")
        return true;
      const lhs2 = probe.get(), rhs2 = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
      return testBinaryOperator(lhs2, expr.operator, rhs2);
    }
    if (expr.type !== "constraint")
      return false;
    const lhs = expr.lhs;
    if (!lhs)
      throw new Error("No LHS of expression");
    if (lhs.type !== "attribute")
      throw new Error(`Constraint target ${lhs.type} not supported`);
    if (probe.containerType() !== "object")
      return false;
    const lhsValue = probe.getAttribute(lhs.name);
    if (lhsValue == null || lhsValue.containerType() !== "primitive")
      return false;
    if (this.isExistenceConstraint())
      return true;
    const rhs = expr.rhs && "value" in expr.rhs ? expr.rhs.value : void 0;
    return testBinaryOperator(lhsValue.get(), expr.operator, rhs);
  }
  pathNodes() {
    return this.expr.type === "path" ? this.expr.nodes : [this.expr];
  }
  prepend(node) {
    return node ? new _Expression({
      type: "path",
      nodes: node.pathNodes().concat(this.pathNodes())
    }) : this;
  }
  concat(other) {
    return other ? other.prepend(this) : this;
  }
  descend() {
    return descend$1(this.expr).map((headTail) => {
      const [head2, tail2] = headTail;
      return {
        head: head2 ? new _Expression(head2) : null,
        tail: tail2 ? new _Expression(tail2) : null
      };
    });
  }
  unwrapRecursive() {
    if (this.expr.type !== "recursive")
      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`);
    return new _Expression(this.expr.term);
  }
  toIndicies(probe) {
    if (this.expr.type !== "index" && this.expr.type !== "range")
      throw new Error("Node cannot be converted to indexes");
    if (this.expr.type === "index")
      return [interpretNegativeIndex(this.expr.value, probe)];
    const result2 = [], range2 = this.expandRange(probe);
    let { start, end } = range2;
    range2.step < 0 && ([start, end] = [end, start]);
    for (let i = start; i < end; i++)
      result2.push(i);
    return result2;
  }
  toFieldReferences() {
    if (this.isIndexReference())
      return this.toIndicies();
    if (this.expr.type === "attribute")
      return [this.expr.name];
    throw new Error(`Can't convert ${this.expr.type} to field references`);
  }
  toString() {
    return toPath(this.expr);
  }
  static fromPath(path) {
    const parsed = parseJsonPath(path);
    if (!parsed)
      throw new Error(`Failed to parse path "${path}"`);
    return new _Expression(parsed);
  }
  static attributeReference(name) {
    return new _Expression({
      type: "attribute",
      name
    });
  }
  static indexReference(i) {
    return new _Expression({
      type: "index",
      value: i
    });
  }
};
function testBinaryOperator(lhsValue, operator, rhsValue) {
  switch (operator) {
    case ">":
      return lhsValue > rhsValue;
    case ">=":
      return lhsValue >= rhsValue;
    case "<":
      return lhsValue < rhsValue;
    case "<=":
      return lhsValue <= rhsValue;
    case "==":
      return lhsValue === rhsValue;
    case "!=":
      return lhsValue !== rhsValue;
    default:
      throw new Error(`Unsupported binary operator ${operator}`);
  }
}
function interpretNegativeIndex(index, probe) {
  if (index >= 0)
    return index;
  if (!probe)
    throw new Error("interpretNegativeIndex() must have a probe when < 0");
  return index + probe.length();
}
var Descender = class _Descender {
  constructor(head2, tail2) {
    __publicField(this, "head");
    __publicField(this, "tail");
    this.head = head2, this.tail = tail2;
  }
  // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head
  iterate(probe) {
    let result2 = [this];
    if (this.head && this.head.isConstraint()) {
      let anyConstraints = true;
      for (; anyConstraints; )
        result2 = (0, import_flatten.default)(
          result2.map((descender) => descender.iterateConstraints(probe))
        ), anyConstraints = result2.some((descender) => descender.head && descender.head.isConstraint());
    }
    return result2;
  }
  isRecursive() {
    return !!(this.head && this.head.isRecursive());
  }
  hasArrived() {
    return this.head === null && this.tail === null;
  }
  extractRecursives() {
    if (this.head && this.head.isRecursive()) {
      const term = this.head.unwrapRecursive();
      return new _Descender(null, term.concat(this.tail)).descend();
    }
    return [];
  }
  iterateConstraints(probe) {
    const head2 = this.head;
    if (head2 === null || !head2.isConstraint())
      return [this];
    const result2 = [];
    if (probe.containerType() === "primitive" && head2.constraintTargetIsSelf())
      return head2.testConstraint(probe) && result2.push(...this.descend()), result2;
    if (probe.containerType() === "array") {
      const length = probe.length();
      for (let i = 0; i < length; i++) {
        const constraint = probe.getIndex(i);
        constraint && head2.testConstraint(constraint) && result2.push(new _Descender(new Expression({ type: "index", value: i }), this.tail));
      }
      return result2;
    }
    return probe.containerType() === "object" ? head2.constraintTargetIsSelf() ? [] : head2.testConstraint(probe) ? this.descend() : result2 : result2;
  }
  descend() {
    return this.tail ? this.tail.descend().map((ht) => new _Descender(ht.head, ht.tail)) : [new _Descender(null, null)];
  }
  toString() {
    const result2 = ["<"];
    return this.head && result2.push(this.head.toString()), result2.push("|"), this.tail && result2.push(this.tail.toString()), result2.push(">"), result2.join("");
  }
};
var Matcher = class _Matcher {
  constructor(active, parent2) {
    __publicField(this, "active");
    __publicField(this, "recursives");
    __publicField(this, "payload");
    this.active = active || [], parent2 ? (this.recursives = parent2.recursives, this.payload = parent2.payload) : this.recursives = [], this.extractRecursives();
  }
  setPayload(payload) {
    return this.payload = payload, this;
  }
  // Moves any recursive descenders onto the recursive track, removing them from
  // the active set
  extractRecursives() {
    this.active = this.active.filter((descender) => descender.isRecursive() ? (this.recursives.push(...descender.extractRecursives()), false) : true);
  }
  // Find recursives that are relevant now and should be considered part of the active set
  activeRecursives(probe) {
    return this.recursives.filter((descender) => {
      const head2 = descender.head;
      return head2 ? head2.isConstraint() || probe.containerType() === "array" && head2.isIndexReference() ? true : probe.containerType() === "object" ? head2.isAttributeReference() && probe.hasAttribute(head2.name()) : false : false;
    });
  }
  match(probe) {
    return this.iterate(probe).extractMatches(probe);
  }
  iterate(probe) {
    const newActiveSet = [];
    return this.active.concat(this.activeRecursives(probe)).forEach((descender) => {
      newActiveSet.push(...descender.iterate(probe));
    }), new _Matcher(newActiveSet, this);
  }
  // Returns true if any of the descenders in the active or recursive set
  // consider the current state a final destination
  isDestination() {
    return this.active.some((descender) => descender.hasArrived());
  }
  hasRecursives() {
    return this.recursives.length > 0;
  }
  // Returns any payload delivieries and leads that needs to be followed to complete
  // the process.
  extractMatches(probe) {
    const leads = [], targets = [];
    if (this.active.forEach((descender) => {
      if (descender.hasArrived()) {
        targets.push(
          new Expression({
            type: "alias",
            target: "self"
          })
        );
        return;
      }
      const descenderHead = descender.head;
      if (descenderHead && !(probe.containerType() === "array" && !descenderHead.isIndexReference()) && !(probe.containerType() === "object" && !descenderHead.isAttributeReference()))
        if (descender.tail) {
          const matcher = new _Matcher(descender.descend(), this);
          descenderHead.toFieldReferences().forEach(() => {
            leads.push({
              target: descenderHead,
              matcher
            });
          });
        } else
          targets.push(descenderHead);
    }), this.hasRecursives()) {
      const recursivesMatcher = new _Matcher([], this);
      if (probe.containerType() === "array") {
        const length = probe.length();
        for (let i = 0; i < length; i++)
          leads.push({
            target: Expression.indexReference(i),
            matcher: recursivesMatcher
          });
      } else probe.containerType() === "object" && probe.attributeKeys().forEach((name) => {
        leads.push({
          target: Expression.attributeReference(name),
          matcher: recursivesMatcher
        });
      });
    }
    return targets.length > 0 ? { leads, delivery: { targets, payload: this.payload } } : { leads };
  }
  static fromPath(jsonpath) {
    const path = parseJsonPath(jsonpath);
    if (!path)
      throw new Error(`Failed to parse path from "${jsonpath}"`);
    const descender = new Descender(null, new Expression(path));
    return new _Matcher(descender.descend());
  }
};
var PlainProbe = class _PlainProbe {
  constructor(value, path) {
    __publicField(this, "_value");
    __publicField(this, "path");
    this._value = value, this.path = path || [];
  }
  containerType() {
    return Array.isArray(this._value) ? "array" : this._value !== null && typeof this._value == "object" ? "object" : "primitive";
  }
  length() {
    if (!Array.isArray(this._value))
      throw new Error("Won't return length of non-indexable _value");
    return this._value.length;
  }
  getIndex(i) {
    return Array.isArray(this._value) ? i >= this.length() ? null : new _PlainProbe(this._value[i], this.path.concat(i)) : false;
  }
  hasAttribute(key) {
    return isRecord(this._value) ? this._value.hasOwnProperty(key) : false;
  }
  attributeKeys() {
    return isRecord(this._value) ? Object.keys(this._value) : [];
  }
  getAttribute(key) {
    if (!isRecord(this._value))
      throw new Error("getAttribute only applies to plain objects");
    return this.hasAttribute(key) ? new _PlainProbe(this._value[key], this.path.concat(key)) : null;
  }
  get() {
    return this._value;
  }
};
function extractAccessors(path, value) {
  const result2 = [], matcher = Matcher.fromPath(path).setPayload(function(values2) {
    result2.push(...values2);
  }), accessor = new PlainProbe(value);
  return descend(matcher, accessor), result2;
}
function descend(matcher, accessor) {
  const { leads, delivery } = matcher.match(accessor);
  leads.forEach((lead) => {
    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {
      descend(lead.matcher, childAccessor);
    });
  }), delivery && delivery.targets.forEach((target) => {
    typeof delivery.payload == "function" && delivery.payload(accessorsFromTarget(target, accessor));
  });
}
function accessorsFromTarget(target, accessor) {
  const result2 = [];
  if (target.isIndexReference())
    target.toIndicies(accessor).forEach((i) => {
      result2.push(accessor.getIndex(i));
    });
  else if (target.isAttributeReference())
    result2.push(accessor.getAttribute(target.name()));
  else if (target.isSelfReference())
    result2.push(accessor);
  else
    throw new Error(`Unable to derive accessor for target ${target.toString()}`);
  return (0, import_compact.default)(result2);
}
function extractWithPath(path, value) {
  return extractAccessors(path, value).map((acc) => ({ path: acc.path, value: acc.get() }));
}
var ONE_MINUTE = 1e3 * 60;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol = root_default.Symbol;
var Symbol_default = Symbol;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result2 = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result2;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/_baseToNumber.js
var NAN = 0 / 0;
function baseToNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  return +value;
}
var baseToNumber_default = baseToNumber;

// node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee2) {
  var index = -1, length = array == null ? 0 : array.length, result2 = Array(length);
  while (++index < length) {
    result2[index] = iteratee2(array[index], index, array);
  }
  return result2;
}
var arrayMap_default = arrayMap;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
}
var baseToString_default = baseToString;

// node_modules/lodash-es/_createMathOperation.js
function createMathOperation(operator, defaultValue) {
  return function(value, other) {
    var result2;
    if (value === void 0 && other === void 0) {
      return defaultValue;
    }
    if (value !== void 0) {
      result2 = value;
    }
    if (other !== void 0) {
      if (result2 === void 0) {
        return other;
      }
      if (typeof value == "string" || typeof other == "string") {
        value = baseToString_default(value);
        other = baseToString_default(other);
      } else {
        value = baseToNumber_default(value);
        other = baseToNumber_default(other);
      }
      result2 = operator(value, other);
    }
    return result2;
  };
}
var createMathOperation_default = createMathOperation;

// node_modules/lodash-es/add.js
var add2 = createMathOperation_default(function(augend, addend) {
  return augend + addend;
}, 0);
var add_default = add2;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/toNumber.js
var NAN2 = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN2;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN2 : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result2 = toFinite_default(value), remainder = result2 % 1;
  return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
}
var toInteger_default = toInteger;

// node_modules/lodash-es/after.js
var FUNC_ERROR_TEXT = "Expected a function";
function after(n, func) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger_default(n);
  return function() {
    if (--n < 1) {
      return func.apply(this, arguments);
    }
  };
}
var after_default = after;

// node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/lodash-es/_metaMap.js
var metaMap = WeakMap_default && new WeakMap_default();
var metaMap_default = metaMap;

// node_modules/lodash-es/_baseSetData.js
var baseSetData = !metaMap_default ? identity_default : function(func, data) {
  metaMap_default.set(func, data);
  return func;
};
var baseSetData_default = baseSetData;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result2 = new object();
    object.prototype = void 0;
    return result2;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_createCtor.js
function createCtor(Ctor) {
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return new Ctor();
      case 1:
        return new Ctor(args[0]);
      case 2:
        return new Ctor(args[0], args[1]);
      case 3:
        return new Ctor(args[0], args[1], args[2]);
      case 4:
        return new Ctor(args[0], args[1], args[2], args[3]);
      case 5:
        return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7:
        return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate_default(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
    return isObject_default(result2) ? result2 : thisBinding;
  };
}
var createCtor_default = createCtor;

// node_modules/lodash-es/_createBind.js
var WRAP_BIND_FLAG = 1;
function createBind(func, bitmask, thisArg) {
  var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor_default(func);
  function wrapper() {
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}
var createBind_default = createBind;

// node_modules/lodash-es/_apply.js
function apply2(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply2;

// node_modules/lodash-es/_composeArgs.js
var nativeMax = Math.max;
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array(leftLength + rangeLength), isUncurried = !isCurried;
  while (++leftIndex < leftLength) {
    result2[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result2[leftIndex++] = args[argsIndex++];
  }
  return result2;
}
var composeArgs_default = composeArgs;

// node_modules/lodash-es/_composeArgsRight.js
var nativeMax2 = Math.max;
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array(rangeLength + rightLength), isUncurried = !isCurried;
  while (++argsIndex < rangeLength) {
    result2[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result2[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result2[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result2;
}
var composeArgsRight_default = composeArgsRight;

// node_modules/lodash-es/_countHolders.js
function countHolders(array, placeholder) {
  var length = array.length, result2 = 0;
  while (length--) {
    if (array[length] === placeholder) {
      ++result2;
    }
  }
  return result2;
}
var countHolders_default = countHolders;

// node_modules/lodash-es/_baseLodash.js
function baseLodash() {
}
var baseLodash_default = baseLodash;

// node_modules/lodash-es/_LazyWrapper.js
var MAX_ARRAY_LENGTH = 4294967295;
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}
LazyWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;
var LazyWrapper_default = LazyWrapper;

// node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// node_modules/lodash-es/_getData.js
var getData = !metaMap_default ? noop_default : function(func) {
  return metaMap_default.get(func);
};
var getData_default = getData;

// node_modules/lodash-es/_realNames.js
var realNames = {};
var realNames_default = realNames;

// node_modules/lodash-es/_getFuncName.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function getFuncName(func) {
  var result2 = func.name + "", array = realNames_default[result2], length = hasOwnProperty3.call(realNames_default, result2) ? array.length : 0;
  while (length--) {
    var data = array[length], otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result2;
}
var getFuncName_default = getFuncName;

// node_modules/lodash-es/_LodashWrapper.js
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = void 0;
}
LodashWrapper.prototype = baseCreate_default(baseLodash_default.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;
var LodashWrapper_default = LodashWrapper;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_wrapperClone.js
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper_default) {
    return wrapper.clone();
  }
  var result2 = new LodashWrapper_default(wrapper.__wrapped__, wrapper.__chain__);
  result2.__actions__ = copyArray_default(wrapper.__actions__);
  result2.__index__ = wrapper.__index__;
  result2.__values__ = wrapper.__values__;
  return result2;
}
var wrapperClone_default = wrapperClone;

// node_modules/lodash-es/wrapperLodash.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function lodash(value) {
  if (isObjectLike_default(value) && !isArray_default(value) && !(value instanceof LazyWrapper_default)) {
    if (value instanceof LodashWrapper_default) {
      return value;
    }
    if (hasOwnProperty4.call(value, "__wrapped__")) {
      return wrapperClone_default(value);
    }
  }
  return new LodashWrapper_default(value);
}
lodash.prototype = baseLodash_default.prototype;
lodash.prototype.constructor = lodash;
var wrapperLodash_default = lodash;

// node_modules/lodash-es/_isLaziable.js
function isLaziable(func) {
  var funcName = getFuncName_default(func), other = wrapperLodash_default[funcName];
  if (typeof other != "function" || !(funcName in LazyWrapper_default.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData_default(other);
  return !!data && func === data[0];
}
var isLaziable_default = isLaziable;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/lodash-es/_setData.js
var setData = shortOut_default(baseSetData_default);
var setData_default = setData;

// node_modules/lodash-es/_getWrapDetails.js
var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/;
var reSplitDetails = /,? & /;
function getWrapDetails(source) {
  var match2 = source.match(reWrapDetails);
  return match2 ? match2[1].split(reSplitDetails) : [];
}
var getWrapDetails_default = getWrapDetails;

// node_modules/lodash-es/_insertWrapDetails.js
var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
function insertWrapDetails(source, details) {
  var length = details.length;
  if (!length) {
    return source;
  }
  var lastIndex = length - 1;
  details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
  details = details.join(length > 2 ? ", " : " ");
  return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
}
var insertWrapDetails_default = insertWrapDetails;

// node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee2) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee2(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/lodash-es/_updateWrapDetails.js
var WRAP_BIND_FLAG2 = 1;
var WRAP_BIND_KEY_FLAG = 2;
var WRAP_CURRY_FLAG = 8;
var WRAP_CURRY_RIGHT_FLAG = 16;
var WRAP_PARTIAL_FLAG = 32;
var WRAP_PARTIAL_RIGHT_FLAG = 64;
var WRAP_ARY_FLAG = 128;
var WRAP_REARG_FLAG = 256;
var WRAP_FLIP_FLAG = 512;
var wrapFlags = [
  ["ary", WRAP_ARY_FLAG],
  ["bind", WRAP_BIND_FLAG2],
  ["bindKey", WRAP_BIND_KEY_FLAG],
  ["curry", WRAP_CURRY_FLAG],
  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
  ["flip", WRAP_FLIP_FLAG],
  ["partial", WRAP_PARTIAL_FLAG],
  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
  ["rearg", WRAP_REARG_FLAG]
];
function updateWrapDetails(details, bitmask) {
  arrayEach_default(wrapFlags, function(pair) {
    var value = "_." + pair[0];
    if (bitmask & pair[1] && !arrayIncludes_default(details, value)) {
      details.push(value);
    }
  });
  return details.sort();
}
var updateWrapDetails_default = updateWrapDetails;

// node_modules/lodash-es/_setWrapToString.js
function setWrapToString(wrapper, reference, bitmask) {
  var source = reference + "";
  return setToString_default(wrapper, insertWrapDetails_default(source, updateWrapDetails_default(getWrapDetails_default(source), bitmask)));
}
var setWrapToString_default = setWrapToString;

// node_modules/lodash-es/_createRecurry.js
var WRAP_BIND_FLAG3 = 1;
var WRAP_BIND_KEY_FLAG2 = 2;
var WRAP_CURRY_BOUND_FLAG = 4;
var WRAP_CURRY_FLAG2 = 8;
var WRAP_PARTIAL_FLAG2 = 32;
var WRAP_PARTIAL_RIGHT_FLAG2 = 64;
function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
  var isCurry = bitmask & WRAP_CURRY_FLAG2, newHolders = isCurry ? holders : void 0, newHoldersRight = isCurry ? void 0 : holders, newPartials = isCurry ? partials : void 0, newPartialsRight = isCurry ? void 0 : partials;
  bitmask |= isCurry ? WRAP_PARTIAL_FLAG2 : WRAP_PARTIAL_RIGHT_FLAG2;
  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG2 : WRAP_PARTIAL_FLAG2);
  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
    bitmask &= ~(WRAP_BIND_FLAG3 | WRAP_BIND_KEY_FLAG2);
  }
  var newData = [
    func,
    bitmask,
    thisArg,
    newPartials,
    newHolders,
    newPartialsRight,
    newHoldersRight,
    argPos,
    ary2,
    arity
  ];
  var result2 = wrapFunc.apply(void 0, newData);
  if (isLaziable_default(func)) {
    setData_default(result2, newData);
  }
  result2.placeholder = placeholder;
  return setWrapToString_default(result2, func, bitmask);
}
var createRecurry_default = createRecurry;

// node_modules/lodash-es/_getHolder.js
function getHolder(func) {
  var object = func;
  return object.placeholder;
}
var getHolder_default = getHolder;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/_reorder.js
var nativeMin = Math.min;
function reorder(array, indexes) {
  var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray_default(array);
  while (length--) {
    var index = indexes[length];
    array[length] = isIndex_default(index, arrLength) ? oldArray[index] : void 0;
  }
  return array;
}
var reorder_default = reorder;

// node_modules/lodash-es/_replaceHolders.js
var PLACEHOLDER = "__lodash_placeholder__";
function replaceHolders(array, placeholder) {
  var index = -1, length = array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result2[resIndex++] = index;
    }
  }
  return result2;
}
var replaceHolders_default = replaceHolders;

// node_modules/lodash-es/_createHybrid.js
var WRAP_BIND_FLAG4 = 1;
var WRAP_BIND_KEY_FLAG3 = 2;
var WRAP_CURRY_FLAG3 = 8;
var WRAP_CURRY_RIGHT_FLAG2 = 16;
var WRAP_ARY_FLAG2 = 128;
var WRAP_FLIP_FLAG2 = 512;
function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
  var isAry = bitmask & WRAP_ARY_FLAG2, isBind = bitmask & WRAP_BIND_FLAG4, isBindKey = bitmask & WRAP_BIND_KEY_FLAG3, isCurried = bitmask & (WRAP_CURRY_FLAG3 | WRAP_CURRY_RIGHT_FLAG2), isFlip = bitmask & WRAP_FLIP_FLAG2, Ctor = isBindKey ? void 0 : createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length;
    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder_default(wrapper), holdersCount = countHolders_default(args, placeholder);
    }
    if (partials) {
      args = composeArgs_default(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight_default(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders_default(args, placeholder);
      return createRecurry_default(
        func,
        bitmask,
        createHybrid,
        wrapper.placeholder,
        thisArg,
        args,
        newHolders,
        argPos,
        ary2,
        arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
    length = args.length;
    if (argPos) {
      args = reorder_default(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary2 < length) {
      args.length = ary2;
    }
    if (this && this !== root_default && this instanceof wrapper) {
      fn = Ctor || createCtor_default(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}
var createHybrid_default = createHybrid;

// node_modules/lodash-es/_createCurry.js
function createCurry(func, bitmask, arity) {
  var Ctor = createCtor_default(func);
  function wrapper() {
    var length = arguments.length, args = Array(length), index = length, placeholder = getHolder_default(wrapper);
    while (index--) {
      args[index] = arguments[index];
    }
    var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders_default(args, placeholder);
    length -= holders.length;
    if (length < arity) {
      return createRecurry_default(
        func,
        bitmask,
        createHybrid_default,
        wrapper.placeholder,
        void 0,
        args,
        holders,
        void 0,
        void 0,
        arity - length
      );
    }
    var fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    return apply_default(fn, this, args);
  }
  return wrapper;
}
var createCurry_default = createCurry;

// node_modules/lodash-es/_createPartial.js
var WRAP_BIND_FLAG5 = 1;
function createPartial(func, bitmask, thisArg, partials) {
  var isBind = bitmask & WRAP_BIND_FLAG5, Ctor = createCtor_default(func);
  function wrapper() {
    var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root_default && this instanceof wrapper ? Ctor : func;
    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply_default(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}
var createPartial_default = createPartial;

// node_modules/lodash-es/_mergeData.js
var PLACEHOLDER2 = "__lodash_placeholder__";
var WRAP_BIND_FLAG6 = 1;
var WRAP_BIND_KEY_FLAG4 = 2;
var WRAP_CURRY_BOUND_FLAG2 = 4;
var WRAP_CURRY_FLAG4 = 8;
var WRAP_ARY_FLAG3 = 128;
var WRAP_REARG_FLAG2 = 256;
var nativeMin2 = Math.min;
function mergeData(data, source) {
  var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG6 | WRAP_BIND_KEY_FLAG4 | WRAP_ARY_FLAG3);
  var isCombo = srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_CURRY_FLAG4 || srcBitmask == WRAP_ARY_FLAG3 && bitmask == WRAP_REARG_FLAG2 && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG3 | WRAP_REARG_FLAG2) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG4;
  if (!(isCommon || isCombo)) {
    return data;
  }
  if (srcBitmask & WRAP_BIND_FLAG6) {
    data[2] = source[2];
    newBitmask |= bitmask & WRAP_BIND_FLAG6 ? 0 : WRAP_CURRY_BOUND_FLAG2;
  }
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs_default(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders_default(data[3], PLACEHOLDER2) : source[4];
  }
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight_default(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders_default(data[5], PLACEHOLDER2) : source[6];
  }
  value = source[7];
  if (value) {
    data[7] = value;
  }
  if (srcBitmask & WRAP_ARY_FLAG3) {
    data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
  }
  if (data[9] == null) {
    data[9] = source[9];
  }
  data[0] = source[0];
  data[1] = newBitmask;
  return data;
}
var mergeData_default = mergeData;

// node_modules/lodash-es/_createWrap.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var WRAP_BIND_FLAG7 = 1;
var WRAP_BIND_KEY_FLAG5 = 2;
var WRAP_CURRY_FLAG5 = 8;
var WRAP_CURRY_RIGHT_FLAG3 = 16;
var WRAP_PARTIAL_FLAG3 = 32;
var WRAP_PARTIAL_RIGHT_FLAG3 = 64;
var nativeMax3 = Math.max;
function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG5;
  if (!isBindKey && typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(WRAP_PARTIAL_FLAG3 | WRAP_PARTIAL_RIGHT_FLAG3);
    partials = holders = void 0;
  }
  ary2 = ary2 === void 0 ? ary2 : nativeMax3(toInteger_default(ary2), 0);
  arity = arity === void 0 ? arity : toInteger_default(arity);
  length -= holders ? holders.length : 0;
  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG3) {
    var partialsRight = partials, holdersRight = holders;
    partials = holders = void 0;
  }
  var data = isBindKey ? void 0 : getData_default(func);
  var newData = [
    func,
    bitmask,
    thisArg,
    partials,
    holders,
    partialsRight,
    holdersRight,
    argPos,
    ary2,
    arity
  ];
  if (data) {
    mergeData_default(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] === void 0 ? isBindKey ? 0 : func.length : nativeMax3(newData[9] - length, 0);
  if (!arity && bitmask & (WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3)) {
    bitmask &= ~(WRAP_CURRY_FLAG5 | WRAP_CURRY_RIGHT_FLAG3);
  }
  if (!bitmask || bitmask == WRAP_BIND_FLAG7) {
    var result2 = createBind_default(func, bitmask, thisArg);
  } else if (bitmask == WRAP_CURRY_FLAG5 || bitmask == WRAP_CURRY_RIGHT_FLAG3) {
    result2 = createCurry_default(func, bitmask, arity);
  } else if ((bitmask == WRAP_PARTIAL_FLAG3 || bitmask == (WRAP_BIND_FLAG7 | WRAP_PARTIAL_FLAG3)) && !holders.length) {
    result2 = createPartial_default(func, bitmask, thisArg, partials);
  } else {
    result2 = createHybrid_default.apply(void 0, newData);
  }
  var setter = data ? baseSetData_default : setData_default;
  return setWrapToString_default(setter(result2, newData), func, bitmask);
}
var createWrap_default = createWrap;

// node_modules/lodash-es/ary.js
var WRAP_ARY_FLAG4 = 128;
function ary(func, n, guard) {
  n = guard ? void 0 : n;
  n = func && n == null ? func.length : n;
  return createWrap_default(func, WRAP_ARY_FLAG4, void 0, void 0, void 0, void 0, n);
}
var ary_default = ary;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_overRest.js
var nativeMax4 = Math.max;
function overRest(func, start, transform2) {
  start = nativeMax4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax4(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform2(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/lodash-es/_isPrototype.js
var objectProto7 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto7;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee2) {
  var index = -1, result2 = Array(n);
  while (++index < n) {
    result2[index] = iteratee2(index);
  }
  return result2;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
var propertyIsEnumerable = objectProto8.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType2, result2 = skipIndexes ? baseTimes_default(value.length, String) : [], length = result2.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result2.push(key);
    }
  }
  return result2;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result2 = [];
  for (var key in Object(object)) {
    if (hasOwnProperty8.call(object, key) && key != "constructor") {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/assign.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var assign = createAssigner_default(function(object, source) {
  if (isPrototype_default(source) || isArrayLike_default(source)) {
    copyObject_default(source, keys_default(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty9.call(source, key)) {
      assignValue_default(object, key, source[key]);
    }
  }
});
var assign_default = assign;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result2 = [];
  if (object != null) {
    for (var key in Object(object)) {
      result2.push(key);
    }
  }
  return result2;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto12 = Object.prototype;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result2 = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty10.call(object, key)))) {
      result2.push(key);
    }
  }
  return result2;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/assignIn.js
var assignIn = createAssigner_default(function(object, source) {
  copyObject_default(source, keysIn_default(source), object);
});
var assignIn_default = assignIn;

// node_modules/lodash-es/assignInWith.js
var assignInWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keysIn_default(source), object, customizer);
});
var assignInWith_default = assignInWith;

// node_modules/lodash-es/assignWith.js
var assignWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  copyObject_default(source, keys_default(source), object, customizer);
});
var assignWith_default = assignWith;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result2 = this.has(key) && delete this.__data__[key];
  this.size -= result2 ? 1 : 0;
  return result2;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result2 = data[key];
    return result2 === HASH_UNDEFINED ? void 0 : result2;
  }
  return hasOwnProperty11.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty12.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data = map2.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result2 = getMapData_default(this, key)["delete"](key);
  this.size -= result2 ? 1 : 0;
  return result2;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result2 = func.apply(this, args);
    memoized.cache = cache.set(key, result2) || cache;
    return result2;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result2 = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result2.cache;
  return result2;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath2 = memoizeCapped_default(function(string) {
  var result2 = [];
  if (string.charCodeAt(0) === 46) {
    result2.push("");
  }
  string.replace(rePropName, function(match2, number, quote, subString) {
    result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
  });
  return result2;
});
var stringToPath_default = stringToPath2;

// node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result2 = value + "";
  return result2 == "0" && 1 / value == -INFINITY3 ? "-0" : result2;
}
var toKey_default = toKey;

// node_modules/lodash-es/_baseGet.js
function baseGet(object, path) {
  path = castPath_default(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey_default(path[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/lodash-es/get.js
function get(object, path, defaultValue) {
  var result2 = object == null ? void 0 : baseGet_default(object, path);
  return result2 === void 0 ? defaultValue : result2;
}
var get_default = get;

// node_modules/lodash-es/_baseAt.js
function baseAt(object, paths) {
  var index = -1, length = paths.length, result2 = Array(length), skip = object == null;
  while (++index < length) {
    result2[index] = skip ? void 0 : get_default(object, paths[index]);
  }
  return result2;
}
var baseAt_default = baseAt;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values2) {
  var index = -1, length = values2.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values2[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_isFlattenable.js
var spreadableSymbol = Symbol_default ? Symbol_default.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_default(value) || isArguments_default(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var isFlattenable_default = isFlattenable;

// node_modules/lodash-es/_baseFlatten.js
function baseFlatten(array, depth, predicate, isStrict, result2) {
  var index = -1, length = array.length;
  predicate || (predicate = isFlattenable_default);
  result2 || (result2 = []);
  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result2);
      } else {
        arrayPush_default(result2, value);
      }
    } else if (!isStrict) {
      result2[result2.length] = value;
    }
  }
  return result2;
}
var baseFlatten_default = baseFlatten;

// node_modules/lodash-es/flatten.js
function flatten2(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, 1) : [];
}
var flatten_default = flatten2;

// node_modules/lodash-es/_flatRest.js
function flatRest(func) {
  return setToString_default(overRest_default(func, void 0, flatten_default), func + "");
}
var flatRest_default = flatRest;

// node_modules/lodash-es/at.js
var at = flatRest_default(baseAt_default);
var at_default = at;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto15 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty13.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/lodash-es/attempt.js
var attempt = baseRest_default(function(func, args) {
  try {
    return apply_default(func, void 0, args);
  } catch (e) {
    return isError_default(e) ? e : new Error(e);
  }
});
var attempt_default = attempt;

// node_modules/lodash-es/before.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function before(n, func) {
  var result2;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  n = toInteger_default(n);
  return function() {
    if (--n > 0) {
      result2 = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = void 0;
    }
    return result2;
  };
}
var before_default = before;

// node_modules/lodash-es/bind.js
var WRAP_BIND_FLAG8 = 1;
var WRAP_PARTIAL_FLAG4 = 32;
var bind = baseRest_default(function(func, thisArg, partials) {
  var bitmask = WRAP_BIND_FLAG8;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bind));
    bitmask |= WRAP_PARTIAL_FLAG4;
  }
  return createWrap_default(func, bitmask, thisArg, partials, holders);
});
bind.placeholder = {};
var bind_default = bind;

// node_modules/lodash-es/bindAll.js
var bindAll = flatRest_default(function(object, methodNames) {
  arrayEach_default(methodNames, function(key) {
    key = toKey_default(key);
    baseAssignValue_default(object, key, bind_default(object[key], object));
  });
  return object;
});
var bindAll_default = bindAll;

// node_modules/lodash-es/bindKey.js
var WRAP_BIND_FLAG9 = 1;
var WRAP_BIND_KEY_FLAG6 = 2;
var WRAP_PARTIAL_FLAG5 = 32;
var bindKey = baseRest_default(function(object, key, partials) {
  var bitmask = WRAP_BIND_FLAG9 | WRAP_BIND_KEY_FLAG6;
  if (partials.length) {
    var holders = replaceHolders_default(partials, getHolder_default(bindKey));
    bitmask |= WRAP_PARTIAL_FLAG5;
  }
  return createWrap_default(key, bitmask, object, partials, holders);
});
bindKey.placeholder = {};
var bindKey_default = bindKey;

// node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result2 = Array(length);
  while (++index < length) {
    result2[index] = array[index + start];
  }
  return result2;
}
var baseSlice_default = baseSlice;

// node_modules/lodash-es/_castSlice.js
function castSlice(array, start, end) {
  var length = array.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array : baseSlice_default(array, start, end);
}
var castSlice_default = castSlice;

// node_modules/lodash-es/_hasUnicode.js
var rsAstralRange = "\\ud800-\\udfff";
var rsComboMarksRange = "\\u0300-\\u036f";
var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange = "\\u20d0-\\u20ff";
var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
var rsVarRange = "\\ufe0e\\ufe0f";
var rsZWJ = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
var hasUnicode_default = hasUnicode;

// node_modules/lodash-es/_asciiToArray.js
function asciiToArray(string) {
  return string.split("");
}
var asciiToArray_default = asciiToArray;

// node_modules/lodash-es/_unicodeToArray.js
var rsAstralRange2 = "\\ud800-\\udfff";
var rsComboMarksRange2 = "\\u0300-\\u036f";
var reComboHalfMarksRange2 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange2 = "\\u20d0-\\u20ff";
var rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2;
var rsVarRange2 = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange2 + "]";
var rsCombo = "[" + rsComboRange2 + "]";
var rsFitz = "\\ud83c[\\udffb-\\udfff]";
var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
var rsNonAstral = "[^" + rsAstralRange2 + "]";
var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ2 = "\\u200d";
var reOptMod = rsModifier + "?";
var rsOptVar = "[" + rsVarRange2 + "]?";
var rsOptJoin = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
var rsSeq = rsOptVar + reOptMod + rsOptJoin;
var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
var unicodeToArray_default = unicodeToArray;

// node_modules/lodash-es/_stringToArray.js
function stringToArray(string) {
  return hasUnicode_default(string) ? unicodeToArray_default(string) : asciiToArray_default(string);
}
var stringToArray_default = stringToArray;

// node_modules/lodash-es/_createCaseFirst.js
function createCaseFirst(methodName) {
  return function(string) {
    string = toString_default(string);
    var strSymbols = hasUnicode_default(string) ? stringToArray_default(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice_default(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
var createCaseFirst_default = createCaseFirst;

// node_modules/lodash-es/upperFirst.js
var upperFirst = createCaseFirst_default("toUpperCase");
var upperFirst_default = upperFirst;

// node_modules/lodash-es/capitalize.js
function capitalize(string) {
  return upperFirst_default(toString_default(string).toLowerCase());
}
var capitalize_default = capitalize;

// node_modules/lodash-es/_arrayReduce.js
function arrayReduce(array, iteratee2, accumulator, initAccum) {
  var index = -1, length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee2(accumulator, array[index], index, array);
  }
  return accumulator;
}
var arrayReduce_default = arrayReduce;

// node_modules/lodash-es/_basePropertyOf.js
function basePropertyOf(object) {
  return function(key) {
    return object == null ? void 0 : object[key];
  };
}
var basePropertyOf_default = basePropertyOf;

// node_modules/lodash-es/_deburrLetter.js
var deburredLetters = {
  // Latin-1 Supplement block.
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "c",
  "": "D",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "N",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "o",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "Y",
  "": "y",
  "": "y",
  "": "Ae",
  "": "ae",
  "": "Th",
  "": "th",
  "": "ss",
  // Latin Extended-A block.
  "": "A",
  "": "A",
  "": "A",
  "": "a",
  "": "a",
  "": "a",
  "": "C",
  "": "C",
  "": "C",
  "": "C",
  "": "c",
  "": "c",
  "": "c",
  "": "c",
  "": "D",
  "": "D",
  "": "d",
  "": "d",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "E",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "e",
  "": "G",
  "": "G",
  "": "G",
  "": "G",
  "": "g",
  "": "g",
  "": "g",
  "": "g",
  "": "H",
  "": "H",
  "": "h",
  "": "h",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "I",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "i",
  "": "J",
  "": "j",
  "": "K",
  "": "k",
  "": "k",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "L",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "l",
  "": "N",
  "": "N",
  "": "N",
  "": "N",
  "": "n",
  "": "n",
  "": "n",
  "": "n",
  "": "O",
  "": "O",
  "": "O",
  "": "o",
  "": "o",
  "": "o",
  "": "R",
  "": "R",
  "": "R",
  "": "r",
  "": "r",
  "": "r",
  "": "S",
  "": "S",
  "": "S",
  "": "S",
  "": "s",
  "": "s",
  "": "s",
  "": "s",
  "": "T",
  "": "T",
  "": "T",
  "": "t",
  "": "t",
  "": "t",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "U",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "u",
  "": "W",
  "": "w",
  "": "Y",
  "": "y",
  "": "Y",
  "": "Z",
  "": "Z",
  "": "Z",
  "": "z",
  "": "z",
  "": "z",
  "": "IJ",
  "": "ij",
  "": "Oe",
  "": "oe",
  "": "'n",
  "": "s"
};
var deburrLetter = basePropertyOf_default(deburredLetters);
var deburrLetter_default = deburrLetter;

// node_modules/lodash-es/deburr.js
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
var rsComboMarksRange3 = "\\u0300-\\u036f";
var reComboHalfMarksRange3 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange3 = "\\u20d0-\\u20ff";
var rsComboRange3 = rsComboMarksRange3 + reComboHalfMarksRange3 + rsComboSymbolsRange3;
var rsCombo2 = "[" + rsComboRange3 + "]";
var reComboMark = RegExp(rsCombo2, "g");
function deburr(string) {
  string = toString_default(string);
  return string && string.replace(reLatin, deburrLetter_default).replace(reComboMark, "");
}
var deburr_default = deburr;

// node_modules/lodash-es/_asciiWords.js
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
var asciiWords_default = asciiWords;

// node_modules/lodash-es/_hasUnicodeWord.js
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
var hasUnicodeWord_default = hasUnicodeWord;

// node_modules/lodash-es/_unicodeWords.js
var rsAstralRange3 = "\\ud800-\\udfff";
var rsComboMarksRange4 = "\\u0300-\\u036f";
var reComboHalfMarksRange4 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange4 = "\\u20d0-\\u20ff";
var rsComboRange4 = rsComboMarksRange4 + reComboHalfMarksRange4 + rsComboSymbolsRange4;
var rsDingbatRange = "\\u2700-\\u27bf";
var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
var rsPunctuationRange = "\\u2000-\\u206f";
var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
var rsVarRange3 = "\\ufe0e\\ufe0f";
var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
var rsApos = "[']";
var rsBreak = "[" + rsBreakRange + "]";
var rsCombo3 = "[" + rsComboRange4 + "]";
var rsDigits = "\\d+";
var rsDingbat = "[" + rsDingbatRange + "]";
var rsLower = "[" + rsLowerRange + "]";
var rsMisc = "[^" + rsAstralRange3 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
var rsFitz2 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier2 = "(?:" + rsCombo3 + "|" + rsFitz2 + ")";
var rsNonAstral2 = "[^" + rsAstralRange3 + "]";
var rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsUpper = "[" + rsUpperRange + "]";
var rsZWJ3 = "\\u200d";
var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
var reOptMod2 = rsModifier2 + "?";
var rsOptVar2 = "[" + rsVarRange3 + "]?";
var rsOptJoin2 = "(?:" + rsZWJ3 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*";
var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
var rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2;
var rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2;
var reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
var unicodeWords_default = unicodeWords;

// node_modules/lodash-es/words.js
function words(string, pattern, guard) {
  string = toString_default(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord_default(string) ? unicodeWords_default(string) : asciiWords_default(string);
  }
  return string.match(pattern) || [];
}
var words_default = words;

// node_modules/lodash-es/_createCompounder.js
var rsApos2 = "[']";
var reApos = RegExp(rsApos2, "g");
function createCompounder(callback) {
  return function(string) {
    return arrayReduce_default(words_default(deburr_default(string).replace(reApos, "")), callback, "");
  };
}
var createCompounder_default = createCompounder;

// node_modules/lodash-es/camelCase.js
var camelCase = createCompounder_default(function(result2, word, index) {
  word = word.toLowerCase();
  return result2 + (index ? capitalize_default(word) : word);
});
var camelCase_default = camelCase;

// node_modules/lodash-es/castArray.js
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_default(value) ? value : [value];
}
var castArray_default = castArray;

// node_modules/lodash-es/_createRound.js
var nativeIsFinite = root_default.isFinite;
var nativeMin3 = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber_default(number);
    precision = precision == null ? 0 : nativeMin3(toInteger_default(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString_default(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString_default(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var createRound_default = createRound;

// node_modules/lodash-es/ceil.js
var ceil = createRound_default("ceil");
var ceil_default = ceil;

// node_modules/lodash-es/chain.js
function chain(value) {
  var result2 = wrapperLodash_default(value);
  result2.__chain__ = true;
  return result2;
}
var chain_default = chain;

// node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax5 = Math.max;
function chunk(array, size2, guard) {
  if (guard ? isIterateeCall_default(array, size2, guard) : size2 === void 0) {
    size2 = 1;
  } else {
    size2 = nativeMax5(toInteger_default(size2), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size2 < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result2 = Array(nativeCeil(length / size2));
  while (index < length) {
    result2[resIndex++] = baseSlice_default(array, index, index += size2);
  }
  return result2;
}
var chunk_default = chunk;

// node_modules/lodash-es/_baseClamp.js
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var baseClamp_default = baseClamp;

// node_modules/lodash-es/clamp.js
function clamp(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_default(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_default(lower);
    lower = lower === lower ? lower : 0;
  }
  return baseClamp_default(toNumber_default(number), lower, upper);
}
var clamp_default = clamp;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result2 = data["delete"](key);
  this.size = data.size;
  return result2;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack2(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack2.prototype.clear = stackClear_default;
Stack2.prototype["delete"] = stackDelete_default;
Stack2.prototype.get = stackGet_default;
Stack2.prototype.has = stackHas_default;
Stack2.prototype.set = stackSet_default;
var Stack_default = Stack2;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result2);
  return result2;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto16 = Object.prototype;
var propertyIsEnumerable2 = objectProto16.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result2 = [];
  while (object) {
    arrayPush_default(result2, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result2;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result2 = keysFunc(object);
  return isArray_default(object) ? result2 : arrayPush_default(result2, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set = getNative_default(root_default, "Set");
var Set_default = Set;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result2 = baseGetTag_default(value), Ctor = result2 == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result2;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto17 = Object.prototype;
var hasOwnProperty14 = objectProto17.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result2 = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty14.call(array, "index")) {
    result2.index = array.index;
    result2.input = array.input;
  }
  return result2;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result2).set(new Uint8Array_default(arrayBuffer));
  return result2;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result2.lastIndex = regexp.lastIndex;
  return result2;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag3] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result2 = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result2 !== void 0) {
    return result2;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result2 = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result2);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag4 || tag == argsTag3 || isFunc && !object) {
      result2 = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result2, value)) : copySymbols_default(value, baseAssign_default(result2, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result2 = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result2);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result2;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG2 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG2);
}
var clone_default = clone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/cloneDeepWith.js
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG4 = 4;
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG4, customizer);
}
var cloneDeepWith_default = cloneDeepWith;

// node_modules/lodash-es/cloneWith.js
var CLONE_SYMBOLS_FLAG5 = 4;
function cloneWith(value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseClone_default(value, CLONE_SYMBOLS_FLAG5, customizer);
}
var cloneWith_default = cloneWith;

// node_modules/lodash-es/commit.js
function wrapperCommit() {
  return new LodashWrapper_default(this.value(), this.__chain__);
}
var commit_default = wrapperCommit;

// node_modules/lodash-es/compact.js
function compact2(array) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index];
    if (value) {
      result2[resIndex++] = value;
    }
  }
  return result2;
}
var compact_default = compact2;

// node_modules/lodash-es/concat.js
function concat() {
  var length = arguments.length;
  if (!length) {
    return [];
  }
  var args = Array(length - 1), array = arguments[0], index = length;
  while (index--) {
    args[index - 1] = arguments[index];
  }
  return arrayPush_default(isArray_default(array) ? copyArray_default(array) : [array], baseFlatten_default(args, 1));
}
var concat_default = concat;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/lodash-es/_SetCache.js
function SetCache(values2) {
  var index = -1, length = values2 == null ? 0 : values2.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values2[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/lodash-es/_arraySome.js
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome;

// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result2 = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result2 = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result2 = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result2;
}
var equalArrays_default = equalArrays;

// node_modules/lodash-es/_mapToArray.js
function mapToArray(map2) {
  var index = -1, result2 = Array(map2.size);
  map2.forEach(function(value, key) {
    result2[++index] = [key, value];
  });
  return result2;
}
var mapToArray_default = mapToArray;

// node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
  var index = -1, result2 = Array(set3.size);
  set3.forEach(function(value) {
    result2[++index] = value;
  });
  return result2;
}
var setToArray_default = setToArray;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag4 = "[object Number]";
var regexpTag4 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag4 = "[object String]";
var symbolTag4 = "[object Symbol]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var symbolProto3 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf2 = symbolProto3 ? symbolProto3.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag5:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag4:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag4:
    case dateTag4:
    case numberTag4:
      return eq_default(+object, +other);
    case errorTag4:
      return object.name == other.name && object.message == other.message;
    case regexpTag4:
    case stringTag4:
      return object == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
      convert || (convert = setToArray_default);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG2;
      stack.set(object, other);
      var result2 = equalArrays_default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result2;
    case symbolTag4:
      if (symbolValueOf2) {
        return symbolValueOf2.call(object) == symbolValueOf2.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty15 = objectProto18.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty15.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result2 = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result2 = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result2 && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result2 = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result2;
}
var equalObjects_default = equalObjects;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag4 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var objectTag5 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty16 = objectProto19.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag3 : getTag_default(object), othTag = othIsArr ? arrayTag3 : getTag_default(other);
  objTag = objTag == argsTag4 ? objectTag5 : objTag;
  othTag = othTag == argsTag4 ? objectTag5 : othTag;
  var objIsObj = objTag == objectTag5, othIsObj = othTag == objectTag5, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object) ? equalArrays_default(object, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
    var objIsWrapped = objIsObj && hasOwnProperty16.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty16.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result2 = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result2 === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result2)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;

// node_modules/lodash-es/_getMatchData.js
function getMatchData(object) {
  var result2 = keys_default(object), length = result2.length;
  while (length--) {
    var key = result2[length], value = object[key];
    result2[length] = [key, value, isStrictComparable_default(value)];
  }
  return result2;
}
var getMatchData_default = getMatchData;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var matchesStrictComparable_default = matchesStrictComparable;

// node_modules/lodash-es/_baseMatches.js
function baseMatches(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch_default(object, source, matchData);
  };
}
var baseMatches_default = baseMatches;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var baseHasIn_default = baseHasIn;

// node_modules/lodash-es/_hasPath.js
function hasPath(object, path, hasFunc) {
  path = castPath_default(path, object);
  var index = -1, length = path.length, result2 = false;
  while (++index < length) {
    var key = toKey_default(path[index]);
    if (!(result2 = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result2 || ++index != length) {
    return result2;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object) || isArguments_default(object));
}
var hasPath_default = hasPath;

// node_modules/lodash-es/hasIn.js
function hasIn(object, path) {
  return object != null && hasPath_default(object, path, baseHasIn_default);
}
var hasIn_default = hasIn;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object) {
    var objValue = get_default(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4);
  };
}
var baseMatchesProperty_default = baseMatchesProperty;

// node_modules/lodash-es/_baseProperty.js
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var baseProperty_default = baseProperty;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep(path) {
  return function(object) {
    return baseGet_default(object, path);
  };
}
var basePropertyDeep_default = basePropertyDeep;

// node_modules/lodash-es/property.js
function property(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee;

// node_modules/lodash-es/cond.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function cond(pairs) {
  var length = pairs == null ? 0 : pairs.length, toIteratee = baseIteratee_default;
  pairs = !length ? [] : arrayMap_default(pairs, function(pair) {
    if (typeof pair[1] != "function") {
      throw new TypeError(FUNC_ERROR_TEXT5);
    }
    return [toIteratee(pair[0]), pair[1]];
  });
  return baseRest_default(function(args) {
    var index = -1;
    while (++index < length) {
      var pair = pairs[index];
      if (apply_default(pair[0], this, args)) {
        return apply_default(pair[1], this, args);
      }
    }
  });
}
var cond_default = cond;

// node_modules/lodash-es/_baseConformsTo.js
function baseConformsTo(object, source, props) {
  var length = props.length;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (length--) {
    var key = props[length], predicate = source[key], value = object[key];
    if (value === void 0 && !(key in object) || !predicate(value)) {
      return false;
    }
  }
  return true;
}
var baseConformsTo_default = baseConformsTo;

// node_modules/lodash-es/_baseConforms.js
function baseConforms(source) {
  var props = keys_default(source);
  return function(object) {
    return baseConformsTo_default(object, source, props);
  };
}
var baseConforms_default = baseConforms;

// node_modules/lodash-es/conforms.js
var CLONE_DEEP_FLAG4 = 1;
function conforms(source) {
  return baseConforms_default(baseClone_default(source, CLONE_DEEP_FLAG4));
}
var conforms_default = conforms;

// node_modules/lodash-es/conformsTo.js
function conformsTo(object, source) {
  return source == null || baseConformsTo_default(object, source, keys_default(source));
}
var conformsTo_default = conformsTo;

// node_modules/lodash-es/_arrayAggregator.js
function arrayAggregator(array, setter, iteratee2, accumulator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee2(value), array);
  }
  return accumulator;
}
var arrayAggregator_default = arrayAggregator;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee2, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee2(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee2) {
  return object && baseFor_default(object, iteratee2, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee2) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee2);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee2(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach;

// node_modules/lodash-es/_baseEach.js
var baseEach = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach;

// node_modules/lodash-es/_baseAggregator.js
function baseAggregator(collection, setter, iteratee2, accumulator) {
  baseEach_default(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee2(value), collection2);
  });
  return accumulator;
}
var baseAggregator_default = baseAggregator;

// node_modules/lodash-es/_createAggregator.js
function createAggregator(setter, initializer) {
  return function(collection, iteratee2) {
    var func = isArray_default(collection) ? arrayAggregator_default : baseAggregator_default, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee_default(iteratee2, 2), accumulator);
  };
}
var createAggregator_default = createAggregator;

// node_modules/lodash-es/countBy.js
var objectProto20 = Object.prototype;
var hasOwnProperty17 = objectProto20.hasOwnProperty;
var countBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty17.call(result2, key)) {
    ++result2[key];
  } else {
    baseAssignValue_default(result2, key, 1);
  }
});
var countBy_default = countBy;

// node_modules/lodash-es/create.js
function create(prototype, properties) {
  var result2 = baseCreate_default(prototype);
  return properties == null ? result2 : baseAssign_default(result2, properties);
}
var create_default = create;

// node_modules/lodash-es/curry.js
var WRAP_CURRY_FLAG6 = 8;
function curry(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_FLAG6, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curry.placeholder;
  return result2;
}
curry.placeholder = {};
var curry_default = curry;

// node_modules/lodash-es/curryRight.js
var WRAP_CURRY_RIGHT_FLAG4 = 16;
function curryRight(func, arity, guard) {
  arity = guard ? void 0 : arity;
  var result2 = createWrap_default(func, WRAP_CURRY_RIGHT_FLAG4, void 0, void 0, void 0, void 0, void 0, arity);
  result2.placeholder = curryRight.placeholder;
  return result2;
}
curryRight.placeholder = {};
var curryRight_default = curryRight;

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT6 = "Expected a function";
var nativeMax6 = Math.max;
var nativeMin4 = Math.min;
function debounce(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT6);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax6(toNumber_default(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result2 = func.apply(thisArg, args);
    return result2;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result2;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin4(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result2;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result2 : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result2;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/lodash-es/defaultTo.js
function defaultTo(value, defaultValue) {
  return value == null || value !== value ? defaultValue : value;
}
var defaultTo_default = defaultTo;

// node_modules/lodash-es/defaults.js
var objectProto21 = Object.prototype;
var hasOwnProperty18 = objectProto21.hasOwnProperty;
var defaults = baseRest_default(function(object, sources) {
  object = Object(object);
  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index < length) {
    var source = sources[index];
    var props = keysIn_default(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];
      if (value === void 0 || eq_default(value, objectProto21[key]) && !hasOwnProperty18.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_default = defaults;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/lodash-es/_customDefaultsMerge.js
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_default(objValue) && isObject_default(srcValue)) {
    stack.set(srcValue, objValue);
    baseMerge_default(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var customDefaultsMerge_default = customDefaultsMerge;

// node_modules/lodash-es/mergeWith.js
var mergeWith = createAssigner_default(function(object, source, srcIndex, customizer) {
  baseMerge_default(object, source, srcIndex, customizer);
});
var mergeWith_default = mergeWith;

// node_modules/lodash-es/defaultsDeep.js
var defaultsDeep = baseRest_default(function(args) {
  args.push(void 0, customDefaultsMerge_default);
  return apply_default(mergeWith_default, void 0, args);
});
var defaultsDeep_default = defaultsDeep;

// node_modules/lodash-es/_baseDelay.js
var FUNC_ERROR_TEXT7 = "Expected a function";
function baseDelay(func, wait, args) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT7);
  }
  return setTimeout(function() {
    func.apply(void 0, args);
  }, wait);
}
var baseDelay_default = baseDelay;

// node_modules/lodash-es/defer.js
var defer2 = baseRest_default(function(func, args) {
  return baseDelay_default(func, 1, args);
});
var defer_default = defer2;

// node_modules/lodash-es/delay.js
var delay2 = baseRest_default(function(func, wait, args) {
  return baseDelay_default(func, toNumber_default(wait) || 0, args);
});
var delay_default = delay2;

// node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/lodash-es/_baseDifference.js
var LARGE_ARRAY_SIZE2 = 200;
function baseDifference(array, values2, iteratee2, comparator) {
  var index = -1, includes2 = arrayIncludes_default, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
  if (!length) {
    return result2;
  }
  if (iteratee2) {
    values2 = arrayMap_default(values2, baseUnary_default(iteratee2));
  }
  if (comparator) {
    includes2 = arrayIncludesWith_default;
    isCommon = false;
  } else if (values2.length >= LARGE_ARRAY_SIZE2) {
    includes2 = cacheHas_default;
    isCommon = false;
    values2 = new SetCache_default(values2);
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values2[valuesIndex] === computed) {
            continue outer;
          }
        }
        result2.push(value);
      } else if (!includes2(values2, computed, comparator)) {
        result2.push(value);
      }
    }
  return result2;
}
var baseDifference_default = baseDifference;

// node_modules/lodash-es/difference.js
var difference = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true)) : [];
});
var difference_default = difference;

// node_modules/lodash-es/last.js
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_default = last;

// node_modules/lodash-es/differenceBy.js
var differenceBy = baseRest_default(function(array, values2) {
  var iteratee2 = last_default(values2);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2)) : [];
});
var differenceBy_default = differenceBy;

// node_modules/lodash-es/differenceWith.js
var differenceWith = baseRest_default(function(array, values2) {
  var comparator = last_default(values2);
  if (isArrayLikeObject_default(comparator)) {
    comparator = void 0;
  }
  return isArrayLikeObject_default(array) ? baseDifference_default(array, baseFlatten_default(values2, 1, isArrayLikeObject_default, true), void 0, comparator) : [];
});
var differenceWith_default = differenceWith;

// node_modules/lodash-es/divide.js
var divide = createMathOperation_default(function(dividend, divisor) {
  return dividend / divisor;
}, 1);
var divide_default = divide;

// node_modules/lodash-es/drop.js
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, n < 0 ? 0 : n, length);
}
var drop_default = drop;

// node_modules/lodash-es/dropRight.js
function dropRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var dropRight_default = dropRight;

// node_modules/lodash-es/_baseWhile.js
function baseWhile(array, predicate, isDrop, fromRight) {
  var length = array.length, index = fromRight ? length : -1;
  while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
  }
  return isDrop ? baseSlice_default(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice_default(array, fromRight ? index + 1 : 0, fromRight ? length : index);
}
var baseWhile_default = baseWhile;

// node_modules/lodash-es/dropRightWhile.js
function dropRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true, true) : [];
}
var dropRightWhile_default = dropRightWhile;

// node_modules/lodash-es/dropWhile.js
function dropWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), true) : [];
}
var dropWhile_default = dropWhile;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEach_default = forEach;

// node_modules/lodash-es/_arrayEachRight.js
function arrayEachRight(array, iteratee2) {
  var length = array == null ? 0 : array.length;
  while (length--) {
    if (iteratee2(array[length], length, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEachRight_default = arrayEachRight;

// node_modules/lodash-es/_baseForRight.js
var baseForRight = createBaseFor_default(true);
var baseForRight_default = baseForRight;

// node_modules/lodash-es/_baseForOwnRight.js
function baseForOwnRight(object, iteratee2) {
  return object && baseForRight_default(object, iteratee2, keys_default);
}
var baseForOwnRight_default = baseForOwnRight;

// node_modules/lodash-es/_baseEachRight.js
var baseEachRight = createBaseEach_default(baseForOwnRight_default, true);
var baseEachRight_default = baseEachRight;

// node_modules/lodash-es/forEachRight.js
function forEachRight(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayEachRight_default : baseEachRight_default;
  return func(collection, castFunction_default(iteratee2));
}
var forEachRight_default = forEachRight;

// node_modules/lodash-es/endsWith.js
function endsWith(string, target, position) {
  string = toString_default(string);
  target = baseToString_default(target);
  var length = string.length;
  position = position === void 0 ? length : baseClamp_default(toInteger_default(position), 0, length);
  var end = position;
  position -= target.length;
  return position >= 0 && string.slice(position, end) == target;
}
var endsWith_default = endsWith;

// node_modules/lodash-es/_baseToPairs.js
function baseToPairs(object, props) {
  return arrayMap_default(props, function(key) {
    return [key, object[key]];
  });
}
var baseToPairs_default = baseToPairs;

// node_modules/lodash-es/_setToPairs.js
function setToPairs(set3) {
  var index = -1, result2 = Array(set3.size);
  set3.forEach(function(value) {
    result2[++index] = [value, value];
  });
  return result2;
}
var setToPairs_default = setToPairs;

// node_modules/lodash-es/_createToPairs.js
var mapTag7 = "[object Map]";
var setTag7 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag_default(object);
    if (tag == mapTag7) {
      return mapToArray_default(object);
    }
    if (tag == setTag7) {
      return setToPairs_default(object);
    }
    return baseToPairs_default(object, keysFunc(object));
  };
}
var createToPairs_default = createToPairs;

// node_modules/lodash-es/toPairs.js
var toPairs = createToPairs_default(keys_default);
var toPairs_default = toPairs;

// node_modules/lodash-es/toPairsIn.js
var toPairsIn = createToPairs_default(keysIn_default);
var toPairsIn_default = toPairsIn;

// node_modules/lodash-es/_escapeHtmlChar.js
var htmlEscapes = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtmlChar = basePropertyOf_default(htmlEscapes);
var escapeHtmlChar_default = escapeHtmlChar;

// node_modules/lodash-es/escape.js
var reUnescapedHtml = /[&<>"']/g;
var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
function escape(string) {
  string = toString_default(string);
  return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar_default) : string;
}
var escape_default = escape;

// node_modules/lodash-es/escapeRegExp.js
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reHasRegExpChar = RegExp(reRegExpChar2.source);
function escapeRegExp(string) {
  string = toString_default(string);
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar2, "\\$&") : string;
}
var escapeRegExp_default = escapeRegExp;

// node_modules/lodash-es/_arrayEvery.js
function arrayEvery(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}
var arrayEvery_default = arrayEvery;

// node_modules/lodash-es/_baseEvery.js
function baseEvery(collection, predicate) {
  var result2 = true;
  baseEach_default(collection, function(value, index, collection2) {
    result2 = !!predicate(value, index, collection2);
    return result2;
  });
  return result2;
}
var baseEvery_default = baseEvery;

// node_modules/lodash-es/every.js
function every(collection, predicate, guard) {
  var func = isArray_default(collection) ? arrayEvery_default : baseEvery_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var every_default = every;

// node_modules/lodash-es/toLength.js
var MAX_ARRAY_LENGTH2 = 4294967295;
function toLength(value) {
  return value ? baseClamp_default(toInteger_default(value), 0, MAX_ARRAY_LENGTH2) : 0;
}
var toLength_default = toLength;

// node_modules/lodash-es/_baseFill.js
function baseFill(array, value, start, end) {
  var length = array.length;
  start = toInteger_default(start);
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end === void 0 || end > length ? length : toInteger_default(end);
  if (end < 0) {
    end += length;
  }
  end = start > end ? 0 : toLength_default(end);
  while (start < end) {
    array[start++] = value;
  }
  return array;
}
var baseFill_default = baseFill;

// node_modules/lodash-es/fill.js
function fill(array, value, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (start && typeof start != "number" && isIterateeCall_default(array, value, start)) {
    start = 0;
    end = length;
  }
  return baseFill_default(array, value, start, end);
}
var fill_default = fill;

// node_modules/lodash-es/_baseFilter.js
function baseFilter(collection, predicate) {
  var result2 = [];
  baseEach_default(collection, function(value, index, collection2) {
    if (predicate(value, index, collection2)) {
      result2.push(value);
    }
  });
  return result2;
}
var baseFilter_default = baseFilter;

// node_modules/lodash-es/filter.js
function filter2(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, baseIteratee_default(predicate, 3));
}
var filter_default = filter2;

// node_modules/lodash-es/_createFind.js
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike_default(collection)) {
      var iteratee2 = baseIteratee_default(predicate, 3);
      collection = keys_default(collection);
      predicate = function(key) {
        return iteratee2(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee2 ? collection[index] : index] : void 0;
  };
}
var createFind_default = createFind;

// node_modules/lodash-es/findIndex.js
var nativeMax7 = Math.max;
function findIndex2(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax7(length + index, 0);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index);
}
var findIndex_default = findIndex2;

// node_modules/lodash-es/find.js
var find = createFind_default(findIndex_default);
var find_default = find;

// node_modules/lodash-es/_baseFindKey.js
function baseFindKey(collection, predicate, eachFunc) {
  var result2;
  eachFunc(collection, function(value, key, collection2) {
    if (predicate(value, key, collection2)) {
      result2 = key;
      return false;
    }
  });
  return result2;
}
var baseFindKey_default = baseFindKey;

// node_modules/lodash-es/findKey.js
function findKey2(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwn_default);
}
var findKey_default = findKey2;

// node_modules/lodash-es/findLastIndex.js
var nativeMax8 = Math.max;
var nativeMin5 = Math.min;
function findLastIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length - 1;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = fromIndex < 0 ? nativeMax8(length + index, 0) : nativeMin5(index, length - 1);
  }
  return baseFindIndex_default(array, baseIteratee_default(predicate, 3), index, true);
}
var findLastIndex_default = findLastIndex;

// node_modules/lodash-es/findLast.js
var findLast = createFind_default(findLastIndex_default);
var findLast_default = findLast;

// node_modules/lodash-es/findLastKey.js
function findLastKey(object, predicate) {
  return baseFindKey_default(object, baseIteratee_default(predicate, 3), baseForOwnRight_default);
}
var findLastKey_default = findLastKey;

// node_modules/lodash-es/head.js
function head(array) {
  return array && array.length ? array[0] : void 0;
}
var head_default = head;

// node_modules/lodash-es/_baseMap.js
function baseMap(collection, iteratee2) {
  var index = -1, result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result2[++index] = iteratee2(value, key, collection2);
  });
  return result2;
}
var baseMap_default = baseMap;

// node_modules/lodash-es/map.js
function map(collection, iteratee2) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee2, 3));
}
var map_default = map;

// node_modules/lodash-es/flatMap.js
function flatMap(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), 1);
}
var flatMap_default = flatMap;

// node_modules/lodash-es/flatMapDeep.js
var INFINITY4 = 1 / 0;
function flatMapDeep(collection, iteratee2) {
  return baseFlatten_default(map_default(collection, iteratee2), INFINITY4);
}
var flatMapDeep_default = flatMapDeep;

// node_modules/lodash-es/flatMapDepth.js
function flatMapDepth(collection, iteratee2, depth) {
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(map_default(collection, iteratee2), depth);
}
var flatMapDepth_default = flatMapDepth;

// node_modules/lodash-es/flattenDeep.js
var INFINITY5 = 1 / 0;
function flattenDeep(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten_default(array, INFINITY5) : [];
}
var flattenDeep_default = flattenDeep;

// node_modules/lodash-es/flattenDepth.js
function flattenDepth(array, depth) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  depth = depth === void 0 ? 1 : toInteger_default(depth);
  return baseFlatten_default(array, depth);
}
var flattenDepth_default = flattenDepth;

// node_modules/lodash-es/flip.js
var WRAP_FLIP_FLAG3 = 512;
function flip(func) {
  return createWrap_default(func, WRAP_FLIP_FLAG3);
}
var flip_default = flip;

// node_modules/lodash-es/floor.js
var floor = createRound_default("floor");
var floor_default = floor;

// node_modules/lodash-es/_createFlow.js
var FUNC_ERROR_TEXT8 = "Expected a function";
var WRAP_CURRY_FLAG7 = 8;
var WRAP_PARTIAL_FLAG6 = 32;
var WRAP_ARY_FLAG5 = 128;
var WRAP_REARG_FLAG3 = 256;
function createFlow(fromRight) {
  return flatRest_default(function(funcs) {
    var length = funcs.length, index = length, prereq = LodashWrapper_default.prototype.thru;
    if (fromRight) {
      funcs.reverse();
    }
    while (index--) {
      var func = funcs[index];
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT8);
      }
      if (prereq && !wrapper && getFuncName_default(func) == "wrapper") {
        var wrapper = new LodashWrapper_default([], true);
      }
    }
    index = wrapper ? index : length;
    while (++index < length) {
      func = funcs[index];
      var funcName = getFuncName_default(func), data = funcName == "wrapper" ? getData_default(func) : void 0;
      if (data && isLaziable_default(data[0]) && data[1] == (WRAP_ARY_FLAG5 | WRAP_CURRY_FLAG7 | WRAP_PARTIAL_FLAG6 | WRAP_REARG_FLAG3) && !data[4].length && data[9] == 1) {
        wrapper = wrapper[getFuncName_default(data[0])].apply(wrapper, data[3]);
      } else {
        wrapper = func.length == 1 && isLaziable_default(func) ? wrapper[funcName]() : wrapper.thru(func);
      }
    }
    return function() {
      var args = arguments, value = args[0];
      if (wrapper && args.length == 1 && isArray_default(value)) {
        return wrapper.plant(value).value();
      }
      var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
      while (++index2 < length) {
        result2 = funcs[index2].call(this, result2);
      }
      return result2;
    };
  });
}
var createFlow_default = createFlow;

// node_modules/lodash-es/flow.js
var flow = createFlow_default();
var flow_default = flow;

// node_modules/lodash-es/flowRight.js
var flowRight = createFlow_default(true);
var flowRight_default = flowRight;

// node_modules/lodash-es/forIn.js
function forIn(object, iteratee2) {
  return object == null ? object : baseFor_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forIn_default = forIn;

// node_modules/lodash-es/forInRight.js
function forInRight(object, iteratee2) {
  return object == null ? object : baseForRight_default(object, castFunction_default(iteratee2), keysIn_default);
}
var forInRight_default = forInRight;

// node_modules/lodash-es/forOwn.js
function forOwn(object, iteratee2) {
  return object && baseForOwn_default(object, castFunction_default(iteratee2));
}
var forOwn_default = forOwn;

// node_modules/lodash-es/forOwnRight.js
function forOwnRight(object, iteratee2) {
  return object && baseForOwnRight_default(object, castFunction_default(iteratee2));
}
var forOwnRight_default = forOwnRight;

// node_modules/lodash-es/fromPairs.js
function fromPairs(pairs) {
  var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
  while (++index < length) {
    var pair = pairs[index];
    result2[pair[0]] = pair[1];
  }
  return result2;
}
var fromPairs_default = fromPairs;

// node_modules/lodash-es/_baseFunctions.js
function baseFunctions(object, props) {
  return arrayFilter_default(props, function(key) {
    return isFunction_default(object[key]);
  });
}
var baseFunctions_default = baseFunctions;

// node_modules/lodash-es/functions.js
function functions(object) {
  return object == null ? [] : baseFunctions_default(object, keys_default(object));
}
var functions_default = functions;

// node_modules/lodash-es/functionsIn.js
function functionsIn(object) {
  return object == null ? [] : baseFunctions_default(object, keysIn_default(object));
}
var functionsIn_default = functionsIn;

// node_modules/lodash-es/groupBy.js
var objectProto22 = Object.prototype;
var hasOwnProperty19 = objectProto22.hasOwnProperty;
var groupBy = createAggregator_default(function(result2, value, key) {
  if (hasOwnProperty19.call(result2, key)) {
    result2[key].push(value);
  } else {
    baseAssignValue_default(result2, key, [value]);
  }
});
var groupBy_default = groupBy;

// node_modules/lodash-es/_baseGt.js
function baseGt(value, other) {
  return value > other;
}
var baseGt_default = baseGt;

// node_modules/lodash-es/_createRelationalOperation.js
function createRelationalOperation(operator) {
  return function(value, other) {
    if (!(typeof value == "string" && typeof other == "string")) {
      value = toNumber_default(value);
      other = toNumber_default(other);
    }
    return operator(value, other);
  };
}
var createRelationalOperation_default = createRelationalOperation;

// node_modules/lodash-es/gt.js
var gt = createRelationalOperation_default(baseGt_default);
var gt_default = gt;

// node_modules/lodash-es/gte.js
var gte = createRelationalOperation_default(function(value, other) {
  return value >= other;
});
var gte_default = gte;

// node_modules/lodash-es/_baseHas.js
var objectProto23 = Object.prototype;
var hasOwnProperty20 = objectProto23.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty20.call(object, key);
}
var baseHas_default = baseHas;

// node_modules/lodash-es/has.js
function has(object, path) {
  return object != null && hasPath_default(object, path, baseHas_default);
}
var has_default = has;

// node_modules/lodash-es/_baseInRange.js
var nativeMax9 = Math.max;
var nativeMin6 = Math.min;
function baseInRange(number, start, end) {
  return number >= nativeMin6(start, end) && number < nativeMax9(start, end);
}
var baseInRange_default = baseInRange;

// node_modules/lodash-es/inRange.js
function inRange(number, start, end) {
  start = toFinite_default(start);
  if (end === void 0) {
    end = start;
    start = 0;
  } else {
    end = toFinite_default(end);
  }
  number = toNumber_default(number);
  return baseInRange_default(number, start, end);
}
var inRange_default = inRange;

// node_modules/lodash-es/isString.js
var stringTag5 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag5;
}
var isString_default = isString;

// node_modules/lodash-es/_baseValues.js
function baseValues(object, props) {
  return arrayMap_default(props, function(key) {
    return object[key];
  });
}
var baseValues_default = baseValues;

// node_modules/lodash-es/values.js
function values(object) {
  return object == null ? [] : baseValues_default(object, keys_default(object));
}
var values_default = values;

// node_modules/lodash-es/includes.js
var nativeMax10 = Math.max;
function includes(collection, value, fromIndex, guard) {
  collection = isArrayLike_default(collection) ? collection : values_default(collection);
  fromIndex = fromIndex && !guard ? toInteger_default(fromIndex) : 0;
  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax10(length + fromIndex, 0);
  }
  return isString_default(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf_default(collection, value, fromIndex) > -1;
}
var includes_default = includes;

// node_modules/lodash-es/indexOf.js
var nativeMax11 = Math.max;
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger_default(fromIndex);
  if (index < 0) {
    index = nativeMax11(length + index, 0);
  }
  return baseIndexOf_default(array, value, index);
}
var indexOf_default = indexOf;

// node_modules/lodash-es/initial.js
function initial(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice_default(array, 0, -1) : [];
}
var initial_default = initial;

// node_modules/lodash-es/_baseIntersection.js
var nativeMin7 = Math.min;
function baseIntersection(arrays, iteratee2, comparator) {
  var includes2 = comparator ? arrayIncludesWith_default : arrayIncludes_default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result2 = [];
  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee2) {
      array = arrayMap_default(array, baseUnary_default(iteratee2));
    }
    maxLength = nativeMin7(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache_default(othIndex && array) : void 0;
  }
  array = arrays[0];
  var index = -1, seen = caches[0];
  outer:
    while (++index < length && result2.length < maxLength) {
      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas_default(seen, computed) : includes2(result2, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas_default(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseIntersection_default = baseIntersection;

// node_modules/lodash-es/_castArrayLikeObject.js
function castArrayLikeObject(value) {
  return isArrayLikeObject_default(value) ? value : [];
}
var castArrayLikeObject_default = castArrayLikeObject;

// node_modules/lodash-es/intersection.js
var intersection = baseRest_default(function(arrays) {
  var mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped) : [];
});
var intersection_default = intersection;

// node_modules/lodash-es/intersectionBy.js
var intersectionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  if (iteratee2 === last_default(mapped)) {
    iteratee2 = void 0;
  } else {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, baseIteratee_default(iteratee2, 2)) : [];
});
var intersectionBy_default = intersectionBy;

// node_modules/lodash-es/intersectionWith.js
var intersectionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays), mapped = arrayMap_default(arrays, castArrayLikeObject_default);
  comparator = typeof comparator == "function" ? comparator : void 0;
  if (comparator) {
    mapped.pop();
  }
  return mapped.length && mapped[0] === arrays[0] ? baseIntersection_default(mapped, void 0, comparator) : [];
});
var intersectionWith_default = intersectionWith;

// node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee2, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee2(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee2) {
    return baseInverter_default(object, setter, toIteratee(iteratee2), {});
  };
}
var createInverter_default = createInverter;

// node_modules/lodash-es/invert.js
var objectProto24 = Object.prototype;
var nativeObjectToString3 = objectProto24.toString;
var invert = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString3.call(value);
  }
  result2[value] = key;
}, constant_default(identity_default));
var invert_default = invert;

// node_modules/lodash-es/invertBy.js
var objectProto25 = Object.prototype;
var hasOwnProperty21 = objectProto25.hasOwnProperty;
var nativeObjectToString4 = objectProto25.toString;
var invertBy = createInverter_default(function(result2, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString4.call(value);
  }
  if (hasOwnProperty21.call(result2, value)) {
    result2[value].push(key);
  } else {
    result2[value] = [key];
  }
}, baseIteratee_default);
var invertBy_default = invertBy;

// node_modules/lodash-es/_parent.js
function parent(object, path) {
  return path.length < 2 ? object : baseGet_default(object, baseSlice_default(path, 0, -1));
}
var parent_default = parent;

// node_modules/lodash-es/_baseInvoke.js
function baseInvoke(object, path, args) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  var func = object == null ? object : object[toKey_default(last_default(path))];
  return func == null ? void 0 : apply_default(func, object, args);
}
var baseInvoke_default = baseInvoke;

// node_modules/lodash-es/invoke.js
var invoke = baseRest_default(baseInvoke_default);
var invoke_default = invoke;

// node_modules/lodash-es/invokeMap.js
var invokeMap = baseRest_default(function(collection, path, args) {
  var index = -1, isFunc = typeof path == "function", result2 = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value) {
    result2[++index] = isFunc ? apply_default(path, value, args) : baseInvoke_default(value, path, args);
  });
  return result2;
});
var invokeMap_default = invokeMap;

// node_modules/lodash-es/_baseIsArrayBuffer.js
var arrayBufferTag5 = "[object ArrayBuffer]";
function baseIsArrayBuffer(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == arrayBufferTag5;
}
var baseIsArrayBuffer_default = baseIsArrayBuffer;

// node_modules/lodash-es/isArrayBuffer.js
var nodeIsArrayBuffer = nodeUtil_default && nodeUtil_default.isArrayBuffer;
var isArrayBuffer = nodeIsArrayBuffer ? baseUnary_default(nodeIsArrayBuffer) : baseIsArrayBuffer_default;
var isArrayBuffer_default = isArrayBuffer;

// node_modules/lodash-es/isBoolean.js
var boolTag5 = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike_default(value) && baseGetTag_default(value) == boolTag5;
}
var isBoolean_default = isBoolean;

// node_modules/lodash-es/_baseIsDate.js
var dateTag5 = "[object Date]";
function baseIsDate(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == dateTag5;
}
var baseIsDate_default = baseIsDate;

// node_modules/lodash-es/isDate.js
var nodeIsDate = nodeUtil_default && nodeUtil_default.isDate;
var isDate2 = nodeIsDate ? baseUnary_default(nodeIsDate) : baseIsDate_default;
var isDate_default = isDate2;

// node_modules/lodash-es/isElement.js
function isElement(value) {
  return isObjectLike_default(value) && value.nodeType === 1 && !isPlainObject_default(value);
}
var isElement_default = isElement;

// node_modules/lodash-es/isEmpty.js
var mapTag8 = "[object Map]";
var setTag8 = "[object Set]";
var objectProto26 = Object.prototype;
var hasOwnProperty22 = objectProto26.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag8 || tag == setTag8) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty22.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/lodash-es/isEqual.js
function isEqual2(value, other) {
  return baseIsEqual_default(value, other);
}
var isEqual_default = isEqual2;

// node_modules/lodash-es/isEqualWith.js
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  var result2 = customizer ? customizer(value, other) : void 0;
  return result2 === void 0 ? baseIsEqual_default(value, other, void 0, customizer) : !!result2;
}
var isEqualWith_default = isEqualWith;

// node_modules/lodash-es/isFinite.js
var nativeIsFinite2 = root_default.isFinite;
function isFinite(value) {
  return typeof value == "number" && nativeIsFinite2(value);
}
var isFinite_default = isFinite;

// node_modules/lodash-es/isInteger.js
function isInteger(value) {
  return typeof value == "number" && value == toInteger_default(value);
}
var isInteger_default = isInteger;

// node_modules/lodash-es/isMatch.js
function isMatch(object, source) {
  return object === source || baseIsMatch_default(object, source, getMatchData_default(source));
}
var isMatch_default = isMatch;

// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object, source, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return baseIsMatch_default(object, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;

// node_modules/lodash-es/isNumber.js
var numberTag5 = "[object Number]";
function isNumber(value) {
  return typeof value == "number" || isObjectLike_default(value) && baseGetTag_default(value) == numberTag5;
}
var isNumber_default = isNumber;

// node_modules/lodash-es/isNaN.js
function isNaN2(value) {
  return isNumber_default(value) && value != +value;
}
var isNaN_default = isNaN2;

// node_modules/lodash-es/_isMaskable.js
var isMaskable = coreJsData_default ? isFunction_default : stubFalse_default;
var isMaskable_default = isMaskable;

// node_modules/lodash-es/isNative.js
var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.";
function isNative(value) {
  if (isMaskable_default(value)) {
    throw new Error(CORE_ERROR_TEXT);
  }
  return baseIsNative_default(value);
}
var isNative_default = isNative;

// node_modules/lodash-es/isNil.js
function isNil(value) {
  return value == null;
}
var isNil_default = isNil;

// node_modules/lodash-es/isNull.js
function isNull(value) {
  return value === null;
}
var isNull_default = isNull;

// node_modules/lodash-es/_baseIsRegExp.js
var regexpTag5 = "[object RegExp]";
function baseIsRegExp(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == regexpTag5;
}
var baseIsRegExp_default = baseIsRegExp;

// node_modules/lodash-es/isRegExp.js
var nodeIsRegExp = nodeUtil_default && nodeUtil_default.isRegExp;
var isRegExp = nodeIsRegExp ? baseUnary_default(nodeIsRegExp) : baseIsRegExp_default;
var isRegExp_default = isRegExp;

// node_modules/lodash-es/isSafeInteger.js
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isSafeInteger(value) {
  return isInteger_default(value) && value >= -MAX_SAFE_INTEGER3 && value <= MAX_SAFE_INTEGER3;
}
var isSafeInteger_default = isSafeInteger;

// node_modules/lodash-es/isUndefined.js
function isUndefined(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined;

// node_modules/lodash-es/isWeakMap.js
var weakMapTag4 = "[object WeakMap]";
function isWeakMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == weakMapTag4;
}
var isWeakMap_default = isWeakMap;

// node_modules/lodash-es/isWeakSet.js
var weakSetTag = "[object WeakSet]";
function isWeakSet(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == weakSetTag;
}
var isWeakSet_default = isWeakSet;

// node_modules/lodash-es/iteratee.js
var CLONE_DEEP_FLAG5 = 1;
function iteratee(func) {
  return baseIteratee_default(typeof func == "function" ? func : baseClone_default(func, CLONE_DEEP_FLAG5));
}
var iteratee_default = iteratee;

// node_modules/lodash-es/join.js
var arrayProto2 = Array.prototype;
var nativeJoin = arrayProto2.join;
function join(array, separator) {
  return array == null ? "" : nativeJoin.call(array, separator);
}
var join_default = join;

// node_modules/lodash-es/kebabCase.js
var kebabCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? "-" : "") + word.toLowerCase();
});
var kebabCase_default = kebabCase;

// node_modules/lodash-es/keyBy.js
var keyBy = createAggregator_default(function(result2, value, key) {
  baseAssignValue_default(result2, key, value);
});
var keyBy_default = keyBy;

// node_modules/lodash-es/_strictLastIndexOf.js
function strictLastIndexOf(array, value, fromIndex) {
  var index = fromIndex + 1;
  while (index--) {
    if (array[index] === value) {
      return index;
    }
  }
  return index;
}
var strictLastIndexOf_default = strictLastIndexOf;

// node_modules/lodash-es/lastIndexOf.js
var nativeMax12 = Math.max;
var nativeMin8 = Math.min;
function lastIndexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = length;
  if (fromIndex !== void 0) {
    index = toInteger_default(fromIndex);
    index = index < 0 ? nativeMax12(length + index, 0) : nativeMin8(index, length - 1);
  }
  return value === value ? strictLastIndexOf_default(array, value, index) : baseFindIndex_default(array, baseIsNaN_default, index, true);
}
var lastIndexOf_default = lastIndexOf;

// node_modules/lodash-es/lowerCase.js
var lowerCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toLowerCase();
});
var lowerCase_default = lowerCase;

// node_modules/lodash-es/lowerFirst.js
var lowerFirst = createCaseFirst_default("toLowerCase");
var lowerFirst_default = lowerFirst;

// node_modules/lodash-es/_baseLt.js
function baseLt(value, other) {
  return value < other;
}
var baseLt_default = baseLt;

// node_modules/lodash-es/lt.js
var lt = createRelationalOperation_default(baseLt_default);
var lt_default = lt;

// node_modules/lodash-es/lte.js
var lte = createRelationalOperation_default(function(value, other) {
  return value <= other;
});
var lte_default = lte;

// node_modules/lodash-es/mapKeys.js
function mapKeys(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, iteratee2(value, key, object2), value);
  });
  return result2;
}
var mapKeys_default = mapKeys;

// node_modules/lodash-es/mapValues.js
function mapValues(object, iteratee2) {
  var result2 = {};
  iteratee2 = baseIteratee_default(iteratee2, 3);
  baseForOwn_default(object, function(value, key, object2) {
    baseAssignValue_default(result2, key, iteratee2(value, key, object2));
  });
  return result2;
}
var mapValues_default = mapValues;

// node_modules/lodash-es/matches.js
var CLONE_DEEP_FLAG6 = 1;
function matches(source) {
  return baseMatches_default(baseClone_default(source, CLONE_DEEP_FLAG6));
}
var matches_default = matches;

// node_modules/lodash-es/matchesProperty.js
var CLONE_DEEP_FLAG7 = 1;
function matchesProperty(path, srcValue) {
  return baseMatchesProperty_default(path, baseClone_default(srcValue, CLONE_DEEP_FLAG7));
}
var matchesProperty_default = matchesProperty;

// node_modules/lodash-es/_baseExtremum.js
function baseExtremum(array, iteratee2, comparator) {
  var index = -1, length = array.length;
  while (++index < length) {
    var value = array[index], current = iteratee2(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol_default(current) : comparator(current, computed))) {
      var computed = current, result2 = value;
    }
  }
  return result2;
}
var baseExtremum_default = baseExtremum;

// node_modules/lodash-es/max.js
function max3(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseGt_default) : void 0;
}
var max_default = max3;

// node_modules/lodash-es/maxBy.js
function maxBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseGt_default) : void 0;
}
var maxBy_default = maxBy;

// node_modules/lodash-es/_baseSum.js
function baseSum(array, iteratee2) {
  var result2, index = -1, length = array.length;
  while (++index < length) {
    var current = iteratee2(array[index]);
    if (current !== void 0) {
      result2 = result2 === void 0 ? current : result2 + current;
    }
  }
  return result2;
}
var baseSum_default = baseSum;

// node_modules/lodash-es/_baseMean.js
var NAN3 = 0 / 0;
function baseMean(array, iteratee2) {
  var length = array == null ? 0 : array.length;
  return length ? baseSum_default(array, iteratee2) / length : NAN3;
}
var baseMean_default = baseMean;

// node_modules/lodash-es/mean.js
function mean(array) {
  return baseMean_default(array, identity_default);
}
var mean_default = mean;

// node_modules/lodash-es/meanBy.js
function meanBy(array, iteratee2) {
  return baseMean_default(array, baseIteratee_default(iteratee2, 2));
}
var meanBy_default = meanBy;

// node_modules/lodash-es/merge.js
var merge2 = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge2;

// node_modules/lodash-es/method.js
var method = baseRest_default(function(path, args) {
  return function(object) {
    return baseInvoke_default(object, path, args);
  };
});
var method_default = method;

// node_modules/lodash-es/methodOf.js
var methodOf = baseRest_default(function(object, args) {
  return function(path) {
    return baseInvoke_default(object, path, args);
  };
});
var methodOf_default = methodOf;

// node_modules/lodash-es/min.js
function min3(array) {
  return array && array.length ? baseExtremum_default(array, identity_default, baseLt_default) : void 0;
}
var min_default = min3;

// node_modules/lodash-es/minBy.js
function minBy(array, iteratee2) {
  return array && array.length ? baseExtremum_default(array, baseIteratee_default(iteratee2, 2), baseLt_default) : void 0;
}
var minBy_default = minBy;

// node_modules/lodash-es/mixin.js
function mixin(object, source, options2) {
  var props = keys_default(source), methodNames = baseFunctions_default(source, props);
  var chain2 = !(isObject_default(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction_default(object);
  arrayEach_default(methodNames, function(methodName) {
    var func = source[methodName];
    object[methodName] = func;
    if (isFunc) {
      object.prototype[methodName] = function() {
        var chainAll = this.__chain__;
        if (chain2 || chainAll) {
          var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray_default(this.__actions__);
          actions.push({ "func": func, "args": arguments, "thisArg": object });
          result2.__chain__ = chainAll;
          return result2;
        }
        return func.apply(object, arrayPush_default([this.value()], arguments));
      };
    }
  });
  return object;
}
var mixin_default = mixin;

// node_modules/lodash-es/multiply.js
var multiply = createMathOperation_default(function(multiplier, multiplicand) {
  return multiplier * multiplicand;
}, 1);
var multiply_default = multiply;

// node_modules/lodash-es/negate.js
var FUNC_ERROR_TEXT9 = "Expected a function";
function negate(predicate) {
  if (typeof predicate != "function") {
    throw new TypeError(FUNC_ERROR_TEXT9);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0:
        return !predicate.call(this);
      case 1:
        return !predicate.call(this, args[0]);
      case 2:
        return !predicate.call(this, args[0], args[1]);
      case 3:
        return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}
var negate_default = negate;

// node_modules/lodash-es/_iteratorToArray.js
function iteratorToArray(iterator) {
  var data, result2 = [];
  while (!(data = iterator.next()).done) {
    result2.push(data.value);
  }
  return result2;
}
var iteratorToArray_default = iteratorToArray;

// node_modules/lodash-es/toArray.js
var mapTag9 = "[object Map]";
var setTag9 = "[object Set]";
var symIterator = Symbol_default ? Symbol_default.iterator : void 0;
function toArray(value) {
  if (!value) {
    return [];
  }
  if (isArrayLike_default(value)) {
    return isString_default(value) ? stringToArray_default(value) : copyArray_default(value);
  }
  if (symIterator && value[symIterator]) {
    return iteratorToArray_default(value[symIterator]());
  }
  var tag = getTag_default(value), func = tag == mapTag9 ? mapToArray_default : tag == setTag9 ? setToArray_default : values_default;
  return func(value);
}
var toArray_default = toArray;

// node_modules/lodash-es/next.js
function wrapperNext() {
  if (this.__values__ === void 0) {
    this.__values__ = toArray_default(this.value());
  }
  var done = this.__index__ >= this.__values__.length, value = done ? void 0 : this.__values__[this.__index__++];
  return { "done": done, "value": value };
}
var next_default = wrapperNext;

// node_modules/lodash-es/_baseNth.js
function baseNth(array, n) {
  var length = array.length;
  if (!length) {
    return;
  }
  n += n < 0 ? length : 0;
  return isIndex_default(n, length) ? array[n] : void 0;
}
var baseNth_default = baseNth;

// node_modules/lodash-es/nth.js
function nth(array, n) {
  return array && array.length ? baseNth_default(array, toInteger_default(n)) : void 0;
}
var nth_default = nth;

// node_modules/lodash-es/nthArg.js
function nthArg(n) {
  n = toInteger_default(n);
  return baseRest_default(function(args) {
    return baseNth_default(args, n);
  });
}
var nthArg_default = nthArg;

// node_modules/lodash-es/_baseUnset.js
function baseUnset(object, path) {
  path = castPath_default(path, object);
  object = parent_default(object, path);
  return object == null || delete object[toKey_default(last_default(path))];
}
var baseUnset_default = baseUnset;

// node_modules/lodash-es/_customOmitClone.js
function customOmitClone(value) {
  return isPlainObject_default(value) ? void 0 : value;
}
var customOmitClone_default = customOmitClone;

// node_modules/lodash-es/omit.js
var CLONE_DEEP_FLAG8 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG6 = 4;
var omit = flatRest_default(function(object, paths) {
  var result2 = {};
  if (object == null) {
    return result2;
  }
  var isDeep = false;
  paths = arrayMap_default(paths, function(path) {
    path = castPath_default(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  copyObject_default(object, getAllKeysIn_default(object), result2);
  if (isDeep) {
    result2 = baseClone_default(result2, CLONE_DEEP_FLAG8 | CLONE_FLAT_FLAG2 | CLONE_SYMBOLS_FLAG6, customOmitClone_default);
  }
  var length = paths.length;
  while (length--) {
    baseUnset_default(result2, paths[length]);
  }
  return result2;
});
var omit_default = omit;

// node_modules/lodash-es/_baseSet.js
function baseSet(object, path, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path = castPath_default(path, object);
  var index = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/lodash-es/_basePickBy.js
function basePickBy(object, paths, predicate) {
  var index = -1, length = paths.length, result2 = {};
  while (++index < length) {
    var path = paths[index], value = baseGet_default(object, path);
    if (predicate(value, path)) {
      baseSet_default(result2, castPath_default(path, object), value);
    }
  }
  return result2;
}
var basePickBy_default = basePickBy;

// node_modules/lodash-es/pickBy.js
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap_default(getAllKeysIn_default(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee_default(predicate);
  return basePickBy_default(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}
var pickBy_default = pickBy;

// node_modules/lodash-es/omitBy.js
function omitBy(object, predicate) {
  return pickBy_default(object, negate_default(baseIteratee_default(predicate)));
}
var omitBy_default = omitBy;

// node_modules/lodash-es/once.js
function once(func) {
  return before_default(2, func);
}
var once_default = once;

// node_modules/lodash-es/_baseSortBy.js
function baseSortBy(array, comparer) {
  var length = array.length;
  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}
var baseSortBy_default = baseSortBy;

// node_modules/lodash-es/_compareAscending.js
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_default(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_default(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var compareAscending_default = compareAscending;

// node_modules/lodash-es/_compareMultiple.js
function compareMultiple(object, other, orders) {
  var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result2 = compareAscending_default(objCriteria[index], othCriteria[index]);
    if (result2) {
      if (index >= ordersLength) {
        return result2;
      }
      var order = orders[index];
      return result2 * (order == "desc" ? -1 : 1);
    }
  }
  return object.index - other.index;
}
var compareMultiple_default = compareMultiple;

// node_modules/lodash-es/_baseOrderBy.js
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap_default(iteratees, function(iteratee2) {
      if (isArray_default(iteratee2)) {
        return function(value) {
          return baseGet_default(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
        };
      }
      return iteratee2;
    });
  } else {
    iteratees = [identity_default];
  }
  var index = -1;
  iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
  var result2 = baseMap_default(collection, function(value, key, collection2) {
    var criteria = arrayMap_default(iteratees, function(iteratee2) {
      return iteratee2(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy_default(result2, function(object, other) {
    return compareMultiple_default(object, other, orders);
  });
}
var baseOrderBy_default = baseOrderBy;

// node_modules/lodash-es/orderBy.js
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_default(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? void 0 : orders;
  if (!isArray_default(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy_default(collection, iteratees, orders);
}
var orderBy_default = orderBy;

// node_modules/lodash-es/_createOver.js
function createOver(arrayFunc) {
  return flatRest_default(function(iteratees) {
    iteratees = arrayMap_default(iteratees, baseUnary_default(baseIteratee_default));
    return baseRest_default(function(args) {
      var thisArg = this;
      return arrayFunc(iteratees, function(iteratee2) {
        return apply_default(iteratee2, thisArg, args);
      });
    });
  });
}
var createOver_default = createOver;

// node_modules/lodash-es/over.js
var over = createOver_default(arrayMap_default);
var over_default = over;

// node_modules/lodash-es/_castRest.js
var castRest = baseRest_default;
var castRest_default = castRest;

// node_modules/lodash-es/overArgs.js
var nativeMin9 = Math.min;
var overArgs = castRest_default(function(func, transforms) {
  transforms = transforms.length == 1 && isArray_default(transforms[0]) ? arrayMap_default(transforms[0], baseUnary_default(baseIteratee_default)) : arrayMap_default(baseFlatten_default(transforms, 1), baseUnary_default(baseIteratee_default));
  var funcsLength = transforms.length;
  return baseRest_default(function(args) {
    var index = -1, length = nativeMin9(args.length, funcsLength);
    while (++index < length) {
      args[index] = transforms[index].call(this, args[index]);
    }
    return apply_default(func, this, args);
  });
});
var overArgs_default = overArgs;

// node_modules/lodash-es/overEvery.js
var overEvery = createOver_default(arrayEvery_default);
var overEvery_default = overEvery;

// node_modules/lodash-es/overSome.js
var overSome = createOver_default(arraySome_default);
var overSome_default = overSome;

// node_modules/lodash-es/_baseRepeat.js
var MAX_SAFE_INTEGER4 = 9007199254740991;
var nativeFloor = Math.floor;
function baseRepeat(string, n) {
  var result2 = "";
  if (!string || n < 1 || n > MAX_SAFE_INTEGER4) {
    return result2;
  }
  do {
    if (n % 2) {
      result2 += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result2;
}
var baseRepeat_default = baseRepeat;

// node_modules/lodash-es/_asciiSize.js
var asciiSize = baseProperty_default("length");
var asciiSize_default = asciiSize;

// node_modules/lodash-es/_unicodeSize.js
var rsAstralRange4 = "\\ud800-\\udfff";
var rsComboMarksRange5 = "\\u0300-\\u036f";
var reComboHalfMarksRange5 = "\\ufe20-\\ufe2f";
var rsComboSymbolsRange5 = "\\u20d0-\\u20ff";
var rsComboRange5 = rsComboMarksRange5 + reComboHalfMarksRange5 + rsComboSymbolsRange5;
var rsVarRange4 = "\\ufe0e\\ufe0f";
var rsAstral2 = "[" + rsAstralRange4 + "]";
var rsCombo4 = "[" + rsComboRange5 + "]";
var rsFitz3 = "\\ud83c[\\udffb-\\udfff]";
var rsModifier3 = "(?:" + rsCombo4 + "|" + rsFitz3 + ")";
var rsNonAstral3 = "[^" + rsAstralRange4 + "]";
var rsRegional3 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
var rsSurrPair3 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
var rsZWJ4 = "\\u200d";
var reOptMod3 = rsModifier3 + "?";
var rsOptVar3 = "[" + rsVarRange4 + "]?";
var rsOptJoin3 = "(?:" + rsZWJ4 + "(?:" + [rsNonAstral3, rsRegional3, rsSurrPair3].join("|") + ")" + rsOptVar3 + reOptMod3 + ")*";
var rsSeq3 = rsOptVar3 + reOptMod3 + rsOptJoin3;
var rsSymbol2 = "(?:" + [rsNonAstral3 + rsCombo4 + "?", rsCombo4, rsRegional3, rsSurrPair3, rsAstral2].join("|") + ")";
var reUnicode2 = RegExp(rsFitz3 + "(?=" + rsFitz3 + ")|" + rsSymbol2 + rsSeq3, "g");
function unicodeSize(string) {
  var result2 = reUnicode2.lastIndex = 0;
  while (reUnicode2.test(string)) {
    ++result2;
  }
  return result2;
}
var unicodeSize_default = unicodeSize;

// node_modules/lodash-es/_stringSize.js
function stringSize(string) {
  return hasUnicode_default(string) ? unicodeSize_default(string) : asciiSize_default(string);
}
var stringSize_default = stringSize;

// node_modules/lodash-es/_createPadding.js
var nativeCeil2 = Math.ceil;
function createPadding(length, chars) {
  chars = chars === void 0 ? " " : baseToString_default(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat_default(chars, length) : chars;
  }
  var result2 = baseRepeat_default(chars, nativeCeil2(length / stringSize_default(chars)));
  return hasUnicode_default(chars) ? castSlice_default(stringToArray_default(result2), 0, length).join("") : result2.slice(0, length);
}
var createPadding_default = createPadding;

// node_modules/lodash-es/pad.js
var nativeCeil3 = Math.ceil;
var nativeFloor2 = Math.floor;
function pad(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  if (!length || strLength >= length) {
    return string;
  }
  var mid = (length - strLength) / 2;
  return createPadding_default(nativeFloor2(mid), chars) + string + createPadding_default(nativeCeil3(mid), chars);
}
var pad_default = pad;

// node_modules/lodash-es/padEnd.js
function padEnd(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? string + createPadding_default(length - strLength, chars) : string;
}
var padEnd_default = padEnd;

// node_modules/lodash-es/padStart.js
function padStart(string, length, chars) {
  string = toString_default(string);
  length = toInteger_default(length);
  var strLength = length ? stringSize_default(string) : 0;
  return length && strLength < length ? createPadding_default(length - strLength, chars) + string : string;
}
var padStart_default = padStart;

// node_modules/lodash-es/parseInt.js
var reTrimStart2 = /^\s+/;
var nativeParseInt = root_default.parseInt;
function parseInt2(string, radix, guard) {
  if (guard || radix == null) {
    radix = 0;
  } else if (radix) {
    radix = +radix;
  }
  return nativeParseInt(toString_default(string).replace(reTrimStart2, ""), radix || 0);
}
var parseInt_default = parseInt2;

// node_modules/lodash-es/partial.js
var WRAP_PARTIAL_FLAG7 = 32;
var partial = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partial));
  return createWrap_default(func, WRAP_PARTIAL_FLAG7, void 0, partials, holders);
});
partial.placeholder = {};
var partial_default = partial;

// node_modules/lodash-es/partialRight.js
var WRAP_PARTIAL_RIGHT_FLAG4 = 64;
var partialRight = baseRest_default(function(func, partials) {
  var holders = replaceHolders_default(partials, getHolder_default(partialRight));
  return createWrap_default(func, WRAP_PARTIAL_RIGHT_FLAG4, void 0, partials, holders);
});
partialRight.placeholder = {};
var partialRight_default = partialRight;

// node_modules/lodash-es/partition.js
var partition2 = createAggregator_default(function(result2, value, key) {
  result2[key ? 0 : 1].push(value);
}, function() {
  return [[], []];
});
var partition_default = partition2;

// node_modules/lodash-es/_basePick.js
function basePick(object, paths) {
  return basePickBy_default(object, paths, function(value, path) {
    return hasIn_default(object, path);
  });
}
var basePick_default = basePick;

// node_modules/lodash-es/pick.js
var pick = flatRest_default(function(object, paths) {
  return object == null ? {} : basePick_default(object, paths);
});
var pick_default = pick;

// node_modules/lodash-es/plant.js
function wrapperPlant(value) {
  var result2, parent2 = this;
  while (parent2 instanceof baseLodash_default) {
    var clone2 = wrapperClone_default(parent2);
    clone2.__index__ = 0;
    clone2.__values__ = void 0;
    if (result2) {
      previous.__wrapped__ = clone2;
    } else {
      result2 = clone2;
    }
    var previous = clone2;
    parent2 = parent2.__wrapped__;
  }
  previous.__wrapped__ = value;
  return result2;
}
var plant_default = wrapperPlant;

// node_modules/lodash-es/propertyOf.js
function propertyOf(object) {
  return function(path) {
    return object == null ? void 0 : baseGet_default(object, path);
  };
}
var propertyOf_default = propertyOf;

// node_modules/lodash-es/_baseIndexOfWith.js
function baseIndexOfWith(array, value, fromIndex, comparator) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (comparator(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var baseIndexOfWith_default = baseIndexOfWith;

// node_modules/lodash-es/_basePullAll.js
var arrayProto3 = Array.prototype;
var splice2 = arrayProto3.splice;
function basePullAll(array, values2, iteratee2, comparator) {
  var indexOf2 = comparator ? baseIndexOfWith_default : baseIndexOf_default, index = -1, length = values2.length, seen = array;
  if (array === values2) {
    values2 = copyArray_default(values2);
  }
  if (iteratee2) {
    seen = arrayMap_default(array, baseUnary_default(iteratee2));
  }
  while (++index < length) {
    var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
    while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
      if (seen !== array) {
        splice2.call(seen, fromIndex, 1);
      }
      splice2.call(array, fromIndex, 1);
    }
  }
  return array;
}
var basePullAll_default = basePullAll;

// node_modules/lodash-es/pullAll.js
function pullAll(array, values2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2) : array;
}
var pullAll_default = pullAll;

// node_modules/lodash-es/pull.js
var pull = baseRest_default(pullAll_default);
var pull_default = pull;

// node_modules/lodash-es/pullAllBy.js
function pullAllBy(array, values2, iteratee2) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, baseIteratee_default(iteratee2, 2)) : array;
}
var pullAllBy_default = pullAllBy;

// node_modules/lodash-es/pullAllWith.js
function pullAllWith(array, values2, comparator) {
  return array && array.length && values2 && values2.length ? basePullAll_default(array, values2, void 0, comparator) : array;
}
var pullAllWith_default = pullAllWith;

// node_modules/lodash-es/_basePullAt.js
var arrayProto4 = Array.prototype;
var splice3 = arrayProto4.splice;
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0, lastIndex = length - 1;
  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex_default(index)) {
        splice3.call(array, index, 1);
      } else {
        baseUnset_default(array, index);
      }
    }
  }
  return array;
}
var basePullAt_default = basePullAt;

// node_modules/lodash-es/pullAt.js
var pullAt = flatRest_default(function(array, indexes) {
  var length = array == null ? 0 : array.length, result2 = baseAt_default(array, indexes);
  basePullAt_default(array, arrayMap_default(indexes, function(index) {
    return isIndex_default(index, length) ? +index : index;
  }).sort(compareAscending_default));
  return result2;
});
var pullAt_default = pullAt;

// node_modules/lodash-es/_baseRandom.js
var nativeFloor3 = Math.floor;
var nativeRandom = Math.random;
function baseRandom(lower, upper) {
  return lower + nativeFloor3(nativeRandom() * (upper - lower + 1));
}
var baseRandom_default = baseRandom;

// node_modules/lodash-es/random.js
var freeParseFloat = parseFloat;
var nativeMin10 = Math.min;
var nativeRandom2 = Math.random;
function random(lower, upper, floating) {
  if (floating && typeof floating != "boolean" && isIterateeCall_default(lower, upper, floating)) {
    upper = floating = void 0;
  }
  if (floating === void 0) {
    if (typeof upper == "boolean") {
      floating = upper;
      upper = void 0;
    } else if (typeof lower == "boolean") {
      floating = lower;
      lower = void 0;
    }
  }
  if (lower === void 0 && upper === void 0) {
    lower = 0;
    upper = 1;
  } else {
    lower = toFinite_default(lower);
    if (upper === void 0) {
      upper = lower;
      lower = 0;
    } else {
      upper = toFinite_default(upper);
    }
  }
  if (lower > upper) {
    var temp = lower;
    lower = upper;
    upper = temp;
  }
  if (floating || lower % 1 || upper % 1) {
    var rand = nativeRandom2();
    return nativeMin10(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
  }
  return baseRandom_default(lower, upper);
}
var random_default = random;

// node_modules/lodash-es/_baseRange.js
var nativeCeil4 = Math.ceil;
var nativeMax13 = Math.max;
function baseRange(start, end, step, fromRight) {
  var index = -1, length = nativeMax13(nativeCeil4((end - start) / (step || 1)), 0), result2 = Array(length);
  while (length--) {
    result2[fromRight ? length : ++index] = start;
    start += step;
  }
  return result2;
}
var baseRange_default = baseRange;

// node_modules/lodash-es/_createRange.js
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall_default(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite_default(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite_default(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite_default(step);
    return baseRange_default(start, end, step, fromRight);
  };
}
var createRange_default = createRange;

// node_modules/lodash-es/range.js
var range = createRange_default();
var range_default = range;

// node_modules/lodash-es/rangeRight.js
var rangeRight = createRange_default(true);
var rangeRight_default = rangeRight;

// node_modules/lodash-es/rearg.js
var WRAP_REARG_FLAG4 = 256;
var rearg = flatRest_default(function(func, indexes) {
  return createWrap_default(func, WRAP_REARG_FLAG4, void 0, void 0, void 0, indexes);
});
var rearg_default = rearg;

// node_modules/lodash-es/_baseReduce.js
function baseReduce(collection, iteratee2, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection2) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee2(accumulator, value, index, collection2);
  });
  return accumulator;
}
var baseReduce_default = baseReduce;

// node_modules/lodash-es/reduce.js
function reduce(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduce_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEach_default);
}
var reduce_default = reduce;

// node_modules/lodash-es/_arrayReduceRight.js
function arrayReduceRight(array, iteratee2, accumulator, initAccum) {
  var length = array == null ? 0 : array.length;
  if (initAccum && length) {
    accumulator = array[--length];
  }
  while (length--) {
    accumulator = iteratee2(accumulator, array[length], length, array);
  }
  return accumulator;
}
var arrayReduceRight_default = arrayReduceRight;

// node_modules/lodash-es/reduceRight.js
function reduceRight(collection, iteratee2, accumulator) {
  var func = isArray_default(collection) ? arrayReduceRight_default : baseReduce_default, initAccum = arguments.length < 3;
  return func(collection, baseIteratee_default(iteratee2, 4), accumulator, initAccum, baseEachRight_default);
}
var reduceRight_default = reduceRight;

// node_modules/lodash-es/reject.js
function reject(collection, predicate) {
  var func = isArray_default(collection) ? arrayFilter_default : baseFilter_default;
  return func(collection, negate_default(baseIteratee_default(predicate, 3)));
}
var reject_default = reject;

// node_modules/lodash-es/remove.js
function remove(array, predicate) {
  var result2 = [];
  if (!(array && array.length)) {
    return result2;
  }
  var index = -1, indexes = [], length = array.length;
  predicate = baseIteratee_default(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result2.push(value);
      indexes.push(index);
    }
  }
  basePullAt_default(array, indexes);
  return result2;
}
var remove_default = remove;

// node_modules/lodash-es/repeat.js
function repeat(string, n, guard) {
  if (guard ? isIterateeCall_default(string, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  return baseRepeat_default(toString_default(string), n);
}
var repeat_default = repeat;

// node_modules/lodash-es/replace.js
function replace() {
  var args = arguments, string = toString_default(args[0]);
  return args.length < 3 ? string : string.replace(args[1], args[2]);
}
var replace_default = replace;

// node_modules/lodash-es/rest.js
var FUNC_ERROR_TEXT10 = "Expected a function";
function rest(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT10);
  }
  start = start === void 0 ? start : toInteger_default(start);
  return baseRest_default(func, start);
}
var rest_default = rest;

// node_modules/lodash-es/result.js
function result(object, path, defaultValue) {
  path = castPath_default(path, object);
  var index = -1, length = path.length;
  if (!length) {
    length = 1;
    object = void 0;
  }
  while (++index < length) {
    var value = object == null ? void 0 : object[toKey_default(path[index])];
    if (value === void 0) {
      index = length;
      value = defaultValue;
    }
    object = isFunction_default(value) ? value.call(object) : value;
  }
  return object;
}
var result_default = result;

// node_modules/lodash-es/reverse.js
var arrayProto5 = Array.prototype;
var nativeReverse = arrayProto5.reverse;
function reverse(array) {
  return array == null ? array : nativeReverse.call(array);
}
var reverse_default = reverse;

// node_modules/lodash-es/round.js
var round = createRound_default("round");
var round_default = round;

// node_modules/lodash-es/_arraySample.js
function arraySample(array) {
  var length = array.length;
  return length ? array[baseRandom_default(0, length - 1)] : void 0;
}
var arraySample_default = arraySample;

// node_modules/lodash-es/_baseSample.js
function baseSample(collection) {
  return arraySample_default(values_default(collection));
}
var baseSample_default = baseSample;

// node_modules/lodash-es/sample.js
function sample(collection) {
  var func = isArray_default(collection) ? arraySample_default : baseSample_default;
  return func(collection);
}
var sample_default = sample;

// node_modules/lodash-es/_shuffleSelf.js
function shuffleSelf(array, size2) {
  var index = -1, length = array.length, lastIndex = length - 1;
  size2 = size2 === void 0 ? length : size2;
  while (++index < size2) {
    var rand = baseRandom_default(index, lastIndex), value = array[rand];
    array[rand] = array[index];
    array[index] = value;
  }
  array.length = size2;
  return array;
}
var shuffleSelf_default = shuffleSelf;

// node_modules/lodash-es/_arraySampleSize.js
function arraySampleSize(array, n) {
  return shuffleSelf_default(copyArray_default(array), baseClamp_default(n, 0, array.length));
}
var arraySampleSize_default = arraySampleSize;

// node_modules/lodash-es/_baseSampleSize.js
function baseSampleSize(collection, n) {
  var array = values_default(collection);
  return shuffleSelf_default(array, baseClamp_default(n, 0, array.length));
}
var baseSampleSize_default = baseSampleSize;

// node_modules/lodash-es/sampleSize.js
function sampleSize(collection, n, guard) {
  if (guard ? isIterateeCall_default(collection, n, guard) : n === void 0) {
    n = 1;
  } else {
    n = toInteger_default(n);
  }
  var func = isArray_default(collection) ? arraySampleSize_default : baseSampleSize_default;
  return func(collection, n);
}
var sampleSize_default = sampleSize;

// node_modules/lodash-es/set.js
function set2(object, path, value) {
  return object == null ? object : baseSet_default(object, path, value);
}
var set_default = set2;

// node_modules/lodash-es/setWith.js
function setWith(object, path, value, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseSet_default(object, path, value, customizer);
}
var setWith_default = setWith;

// node_modules/lodash-es/_arrayShuffle.js
function arrayShuffle(array) {
  return shuffleSelf_default(copyArray_default(array));
}
var arrayShuffle_default = arrayShuffle;

// node_modules/lodash-es/_baseShuffle.js
function baseShuffle(collection) {
  return shuffleSelf_default(values_default(collection));
}
var baseShuffle_default = baseShuffle;

// node_modules/lodash-es/shuffle.js
function shuffle(collection) {
  var func = isArray_default(collection) ? arrayShuffle_default : baseShuffle_default;
  return func(collection);
}
var shuffle_default = shuffle;

// node_modules/lodash-es/size.js
var mapTag10 = "[object Map]";
var setTag10 = "[object Set]";
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike_default(collection)) {
    return isString_default(collection) ? stringSize_default(collection) : collection.length;
  }
  var tag = getTag_default(collection);
  if (tag == mapTag10 || tag == setTag10) {
    return collection.size;
  }
  return baseKeys_default(collection).length;
}
var size_default = size;

// node_modules/lodash-es/slice.js
function slice(array, start, end) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  if (end && typeof end != "number" && isIterateeCall_default(array, start, end)) {
    start = 0;
    end = length;
  } else {
    start = start == null ? 0 : toInteger_default(start);
    end = end === void 0 ? length : toInteger_default(end);
  }
  return baseSlice_default(array, start, end);
}
var slice_default = slice;

// node_modules/lodash-es/snakeCase.js
var snakeCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? "_" : "") + word.toLowerCase();
});
var snakeCase_default = snakeCase;

// node_modules/lodash-es/_baseSome.js
function baseSome(collection, predicate) {
  var result2;
  baseEach_default(collection, function(value, index, collection2) {
    result2 = predicate(value, index, collection2);
    return !result2;
  });
  return !!result2;
}
var baseSome_default = baseSome;

// node_modules/lodash-es/some.js
function some(collection, predicate, guard) {
  var func = isArray_default(collection) ? arraySome_default : baseSome_default;
  if (guard && isIterateeCall_default(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee_default(predicate, 3));
}
var some_default = some;

// node_modules/lodash-es/sortBy.js
var sortBy = baseRest_default(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall_default(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall_default(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy_default(collection, baseFlatten_default(iteratees, 1), []);
});
var sortBy_default = sortBy;

// node_modules/lodash-es/_baseSortedIndexBy.js
var MAX_ARRAY_LENGTH3 = 4294967295;
var MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH3 - 1;
var nativeFloor4 = Math.floor;
var nativeMin11 = Math.min;
function baseSortedIndexBy(array, value, iteratee2, retHighest) {
  var low = 0, high = array == null ? 0 : array.length;
  if (high === 0) {
    return 0;
  }
  value = iteratee2(value);
  var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_default(value), valIsUndefined = value === void 0;
  while (low < high) {
    var mid = nativeFloor4((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== void 0, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_default(computed);
    if (valIsNaN) {
      var setLow = retHighest || othIsReflexive;
    } else if (valIsUndefined) {
      setLow = othIsReflexive && (retHighest || othIsDefined);
    } else if (valIsNull) {
      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
    } else if (valIsSymbol) {
      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
    } else if (othIsNull || othIsSymbol) {
      setLow = false;
    } else {
      setLow = retHighest ? computed <= value : computed < value;
    }
    if (setLow) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return nativeMin11(high, MAX_ARRAY_INDEX);
}
var baseSortedIndexBy_default = baseSortedIndexBy;

// node_modules/lodash-es/_baseSortedIndex.js
var MAX_ARRAY_LENGTH4 = 4294967295;
var HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH4 >>> 1;
function baseSortedIndex(array, value, retHighest) {
  var low = 0, high = array == null ? low : array.length;
  if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
    while (low < high) {
      var mid = low + high >>> 1, computed = array[mid];
      if (computed !== null && !isSymbol_default(computed) && (retHighest ? computed <= value : computed < value)) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }
  return baseSortedIndexBy_default(array, value, identity_default, retHighest);
}
var baseSortedIndex_default = baseSortedIndex;

// node_modules/lodash-es/sortedIndex.js
function sortedIndex(array, value) {
  return baseSortedIndex_default(array, value);
}
var sortedIndex_default = sortedIndex;

// node_modules/lodash-es/sortedIndexBy.js
function sortedIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2));
}
var sortedIndexBy_default = sortedIndexBy;

// node_modules/lodash-es/sortedIndexOf.js
function sortedIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index = baseSortedIndex_default(array, value);
    if (index < length && eq_default(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var sortedIndexOf_default = sortedIndexOf;

// node_modules/lodash-es/sortedLastIndex.js
function sortedLastIndex(array, value) {
  return baseSortedIndex_default(array, value, true);
}
var sortedLastIndex_default = sortedLastIndex;

// node_modules/lodash-es/sortedLastIndexBy.js
function sortedLastIndexBy(array, value, iteratee2) {
  return baseSortedIndexBy_default(array, value, baseIteratee_default(iteratee2, 2), true);
}
var sortedLastIndexBy_default = sortedLastIndexBy;

// node_modules/lodash-es/sortedLastIndexOf.js
function sortedLastIndexOf(array, value) {
  var length = array == null ? 0 : array.length;
  if (length) {
    var index = baseSortedIndex_default(array, value, true) - 1;
    if (eq_default(array[index], value)) {
      return index;
    }
  }
  return -1;
}
var sortedLastIndexOf_default = sortedLastIndexOf;

// node_modules/lodash-es/_baseSortedUniq.js
function baseSortedUniq(array, iteratee2) {
  var index = -1, length = array.length, resIndex = 0, result2 = [];
  while (++index < length) {
    var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
    if (!index || !eq_default(computed, seen)) {
      var seen = computed;
      result2[resIndex++] = value === 0 ? 0 : value;
    }
  }
  return result2;
}
var baseSortedUniq_default = baseSortedUniq;

// node_modules/lodash-es/sortedUniq.js
function sortedUniq(array) {
  return array && array.length ? baseSortedUniq_default(array) : [];
}
var sortedUniq_default = sortedUniq;

// node_modules/lodash-es/sortedUniqBy.js
function sortedUniqBy(array, iteratee2) {
  return array && array.length ? baseSortedUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var sortedUniqBy_default = sortedUniqBy;

// node_modules/lodash-es/split.js
var MAX_ARRAY_LENGTH5 = 4294967295;
function split(string, separator, limit) {
  if (limit && typeof limit != "number" && isIterateeCall_default(string, separator, limit)) {
    separator = limit = void 0;
  }
  limit = limit === void 0 ? MAX_ARRAY_LENGTH5 : limit >>> 0;
  if (!limit) {
    return [];
  }
  string = toString_default(string);
  if (string && (typeof separator == "string" || separator != null && !isRegExp_default(separator))) {
    separator = baseToString_default(separator);
    if (!separator && hasUnicode_default(string)) {
      return castSlice_default(stringToArray_default(string), 0, limit);
    }
  }
  return string.split(separator, limit);
}
var split_default = split;

// node_modules/lodash-es/spread.js
var FUNC_ERROR_TEXT11 = "Expected a function";
var nativeMax14 = Math.max;
function spread(func, start) {
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT11);
  }
  start = start == null ? 0 : nativeMax14(toInteger_default(start), 0);
  return baseRest_default(function(args) {
    var array = args[start], otherArgs = castSlice_default(args, 0, start);
    if (array) {
      arrayPush_default(otherArgs, array);
    }
    return apply_default(func, this, otherArgs);
  });
}
var spread_default = spread;

// node_modules/lodash-es/startCase.js
var startCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + upperFirst_default(word);
});
var startCase_default = startCase;

// node_modules/lodash-es/startsWith.js
function startsWith(string, target, position) {
  string = toString_default(string);
  position = position == null ? 0 : baseClamp_default(toInteger_default(position), 0, string.length);
  target = baseToString_default(target);
  return string.slice(position, position + target.length) == target;
}
var startsWith_default = startsWith;

// node_modules/lodash-es/stubObject.js
function stubObject() {
  return {};
}
var stubObject_default = stubObject;

// node_modules/lodash-es/stubString.js
function stubString() {
  return "";
}
var stubString_default = stubString;

// node_modules/lodash-es/stubTrue.js
function stubTrue() {
  return true;
}
var stubTrue_default = stubTrue;

// node_modules/lodash-es/subtract.js
var subtract = createMathOperation_default(function(minuend, subtrahend) {
  return minuend - subtrahend;
}, 0);
var subtract_default = subtract;

// node_modules/lodash-es/sum.js
function sum(array) {
  return array && array.length ? baseSum_default(array, identity_default) : 0;
}
var sum_default = sum;

// node_modules/lodash-es/sumBy.js
function sumBy(array, iteratee2) {
  return array && array.length ? baseSum_default(array, baseIteratee_default(iteratee2, 2)) : 0;
}
var sumBy_default = sumBy;

// node_modules/lodash-es/tail.js
function tail(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseSlice_default(array, 1, length) : [];
}
var tail_default = tail;

// node_modules/lodash-es/take.js
function take2(array, n, guard) {
  if (!(array && array.length)) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  return baseSlice_default(array, 0, n < 0 ? 0 : n);
}
var take_default = take2;

// node_modules/lodash-es/takeRight.js
function takeRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = guard || n === void 0 ? 1 : toInteger_default(n);
  n = length - n;
  return baseSlice_default(array, n < 0 ? 0 : n, length);
}
var takeRight_default = takeRight;

// node_modules/lodash-es/takeRightWhile.js
function takeRightWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3), false, true) : [];
}
var takeRightWhile_default = takeRightWhile;

// node_modules/lodash-es/takeWhile.js
function takeWhile(array, predicate) {
  return array && array.length ? baseWhile_default(array, baseIteratee_default(predicate, 3)) : [];
}
var takeWhile_default = takeWhile;

// node_modules/lodash-es/tap.js
function tap2(value, interceptor) {
  interceptor(value);
  return value;
}
var tap_default = tap2;

// node_modules/lodash-es/_customDefaultsAssignIn.js
var objectProto27 = Object.prototype;
var hasOwnProperty23 = objectProto27.hasOwnProperty;
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === void 0 || eq_default(objValue, objectProto27[key]) && !hasOwnProperty23.call(object, key)) {
    return srcValue;
  }
  return objValue;
}
var customDefaultsAssignIn_default = customDefaultsAssignIn;

// node_modules/lodash-es/_escapeStringChar.js
var stringEscapes = {
  "\\": "\\",
  "'": "'",
  "\n": "n",
  "\r": "r",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
function escapeStringChar(chr) {
  return "\\" + stringEscapes[chr];
}
var escapeStringChar_default = escapeStringChar;

// node_modules/lodash-es/_reInterpolate.js
var reInterpolate = /<%=([\s\S]+?)%>/g;
var reInterpolate_default = reInterpolate;

// node_modules/lodash-es/_reEscape.js
var reEscape = /<%-([\s\S]+?)%>/g;
var reEscape_default = reEscape;

// node_modules/lodash-es/_reEvaluate.js
var reEvaluate = /<%([\s\S]+?)%>/g;
var reEvaluate_default = reEvaluate;

// node_modules/lodash-es/templateSettings.js
var templateSettings = {
  /**
   * Used to detect `data` property values to be HTML-escaped.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "escape": reEscape_default,
  /**
   * Used to detect code to be evaluated.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "evaluate": reEvaluate_default,
  /**
   * Used to detect `data` property values to inject.
   *
   * @memberOf _.templateSettings
   * @type {RegExp}
   */
  "interpolate": reInterpolate_default,
  /**
   * Used to reference the data object in the template text.
   *
   * @memberOf _.templateSettings
   * @type {string}
   */
  "variable": "",
  /**
   * Used to import variables into the compiled template.
   *
   * @memberOf _.templateSettings
   * @type {Object}
   */
  "imports": {
    /**
     * A reference to the `lodash` function.
     *
     * @memberOf _.templateSettings.imports
     * @type {Function}
     */
    "_": { "escape": escape_default }
  }
};
var templateSettings_default = templateSettings;

// node_modules/lodash-es/template.js
var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
var reEmptyStringLeading = /\b__p \+= '';/g;
var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
var reNoMatch = /($^)/;
var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
var objectProto28 = Object.prototype;
var hasOwnProperty24 = objectProto28.hasOwnProperty;
function template(string, options2, guard) {
  var settings = templateSettings_default.imports._.templateSettings || templateSettings_default;
  if (guard && isIterateeCall_default(string, options2, guard)) {
    options2 = void 0;
  }
  string = toString_default(string);
  options2 = assignInWith_default({}, options2, settings, customDefaultsAssignIn_default);
  var imports = assignInWith_default({}, options2.imports, settings.imports, customDefaultsAssignIn_default), importsKeys = keys_default(imports), importsValues = baseValues_default(imports, importsKeys);
  var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
  var reDelimiters = RegExp(
    (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate_default ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
    "g"
  );
  var sourceURL = hasOwnProperty24.call(options2, "sourceURL") ? "//# sourceURL=" + (options2.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
  string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
    interpolateValue || (interpolateValue = esTemplateValue);
    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar_default);
    if (escapeValue) {
      isEscaping = true;
      source += "' +\n__e(" + escapeValue + ") +\n'";
    }
    if (evaluateValue) {
      isEvaluating = true;
      source += "';\n" + evaluateValue + ";\n__p += '";
    }
    if (interpolateValue) {
      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
    }
    index = offset + match2.length;
    return match2;
  });
  source += "';\n";
  var variable = hasOwnProperty24.call(options2, "variable") && options2.variable;
  if (!variable) {
    source = "with (obj) {\n" + source + "\n}\n";
  } else if (reForbiddenIdentifierChars.test(variable)) {
    throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  }
  source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
  source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
  var result2 = attempt_default(function() {
    return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
  });
  result2.source = source;
  if (isError_default(result2)) {
    throw result2;
  }
  return result2;
}
var template_default = template;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT12 = "Expected a function";
function throttle(func, wait, options2) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT12);
  }
  if (isObject_default(options2)) {
    leading = "leading" in options2 ? !!options2.leading : leading;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle;

// node_modules/lodash-es/thru.js
function thru(value, interceptor) {
  return interceptor(value);
}
var thru_default = thru;

// node_modules/lodash-es/times.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
var MAX_ARRAY_LENGTH6 = 4294967295;
var nativeMin12 = Math.min;
function times(n, iteratee2) {
  n = toInteger_default(n);
  if (n < 1 || n > MAX_SAFE_INTEGER5) {
    return [];
  }
  var index = MAX_ARRAY_LENGTH6, length = nativeMin12(n, MAX_ARRAY_LENGTH6);
  iteratee2 = castFunction_default(iteratee2);
  n -= MAX_ARRAY_LENGTH6;
  var result2 = baseTimes_default(length, iteratee2);
  while (++index < n) {
    iteratee2(index);
  }
  return result2;
}
var times_default = times;

// node_modules/lodash-es/toIterator.js
function wrapperToIterator() {
  return this;
}
var toIterator_default = wrapperToIterator;

// node_modules/lodash-es/_baseWrapperValue.js
function baseWrapperValue(value, actions) {
  var result2 = value;
  if (result2 instanceof LazyWrapper_default) {
    result2 = result2.value();
  }
  return arrayReduce_default(actions, function(result3, action) {
    return action.func.apply(action.thisArg, arrayPush_default([result3], action.args));
  }, result2);
}
var baseWrapperValue_default = baseWrapperValue;

// node_modules/lodash-es/wrapperValue.js
function wrapperValue() {
  return baseWrapperValue_default(this.__wrapped__, this.__actions__);
}
var wrapperValue_default = wrapperValue;

// node_modules/lodash-es/toLower.js
function toLower(value) {
  return toString_default(value).toLowerCase();
}
var toLower_default = toLower;

// node_modules/lodash-es/toPath.js
function toPath2(value) {
  if (isArray_default(value)) {
    return arrayMap_default(value, toKey_default);
  }
  return isSymbol_default(value) ? [value] : copyArray_default(stringToPath_default(toString_default(value)));
}
var toPath_default = toPath2;

// node_modules/lodash-es/toSafeInteger.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
function toSafeInteger(value) {
  return value ? baseClamp_default(toInteger_default(value), -MAX_SAFE_INTEGER6, MAX_SAFE_INTEGER6) : value === 0 ? value : 0;
}
var toSafeInteger_default = toSafeInteger;

// node_modules/lodash-es/toUpper.js
function toUpper(value) {
  return toString_default(value).toUpperCase();
}
var toUpper_default = toUpper;

// node_modules/lodash-es/transform.js
function transform(object, iteratee2, accumulator) {
  var isArr = isArray_default(object), isArrLike = isArr || isBuffer_default(object) || isTypedArray_default(object);
  iteratee2 = baseIteratee_default(iteratee2, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject_default(object)) {
      accumulator = isFunction_default(Ctor) ? baseCreate_default(getPrototype_default(object)) : {};
    } else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach_default : baseForOwn_default)(object, function(value, index, object2) {
    return iteratee2(accumulator, value, index, object2);
  });
  return accumulator;
}
var transform_default = transform;

// node_modules/lodash-es/_charsEndIndex.js
function charsEndIndex(strSymbols, chrSymbols) {
  var index = strSymbols.length;
  while (index-- && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsEndIndex_default = charsEndIndex;

// node_modules/lodash-es/_charsStartIndex.js
function charsStartIndex(strSymbols, chrSymbols) {
  var index = -1, length = strSymbols.length;
  while (++index < length && baseIndexOf_default(chrSymbols, strSymbols[index], 0) > -1) {
  }
  return index;
}
var charsStartIndex_default = charsStartIndex;

// node_modules/lodash-es/trim.js
function trim(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return baseTrim_default(string);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), chrSymbols = stringToArray_default(chars), start = charsStartIndex_default(strSymbols, chrSymbols), end = charsEndIndex_default(strSymbols, chrSymbols) + 1;
  return castSlice_default(strSymbols, start, end).join("");
}
var trim_default = trim;

// node_modules/lodash-es/trimEnd.js
function trimEnd(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.slice(0, trimmedEndIndex_default(string) + 1);
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), end = charsEndIndex_default(strSymbols, stringToArray_default(chars)) + 1;
  return castSlice_default(strSymbols, 0, end).join("");
}
var trimEnd_default = trimEnd;

// node_modules/lodash-es/trimStart.js
var reTrimStart3 = /^\s+/;
function trimStart(string, chars, guard) {
  string = toString_default(string);
  if (string && (guard || chars === void 0)) {
    return string.replace(reTrimStart3, "");
  }
  if (!string || !(chars = baseToString_default(chars))) {
    return string;
  }
  var strSymbols = stringToArray_default(string), start = charsStartIndex_default(strSymbols, stringToArray_default(chars));
  return castSlice_default(strSymbols, start).join("");
}
var trimStart_default = trimStart;

// node_modules/lodash-es/truncate.js
var DEFAULT_TRUNC_LENGTH = 30;
var DEFAULT_TRUNC_OMISSION = "...";
var reFlags2 = /\w*$/;
function truncate(string, options2) {
  var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
  if (isObject_default(options2)) {
    var separator = "separator" in options2 ? options2.separator : separator;
    length = "length" in options2 ? toInteger_default(options2.length) : length;
    omission = "omission" in options2 ? baseToString_default(options2.omission) : omission;
  }
  string = toString_default(string);
  var strLength = string.length;
  if (hasUnicode_default(string)) {
    var strSymbols = stringToArray_default(string);
    strLength = strSymbols.length;
  }
  if (length >= strLength) {
    return string;
  }
  var end = length - stringSize_default(omission);
  if (end < 1) {
    return omission;
  }
  var result2 = strSymbols ? castSlice_default(strSymbols, 0, end).join("") : string.slice(0, end);
  if (separator === void 0) {
    return result2 + omission;
  }
  if (strSymbols) {
    end += result2.length - end;
  }
  if (isRegExp_default(separator)) {
    if (string.slice(end).search(separator)) {
      var match2, substring = result2;
      if (!separator.global) {
        separator = RegExp(separator.source, toString_default(reFlags2.exec(separator)) + "g");
      }
      separator.lastIndex = 0;
      while (match2 = separator.exec(substring)) {
        var newEnd = match2.index;
      }
      result2 = result2.slice(0, newEnd === void 0 ? end : newEnd);
    }
  } else if (string.indexOf(baseToString_default(separator), end) != end) {
    var index = result2.lastIndexOf(separator);
    if (index > -1) {
      result2 = result2.slice(0, index);
    }
  }
  return result2 + omission;
}
var truncate_default = truncate;

// node_modules/lodash-es/unary.js
function unary(func) {
  return ary_default(func, 1);
}
var unary_default = unary;

// node_modules/lodash-es/_unescapeHtmlChar.js
var htmlUnescapes = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&quot;": '"',
  "&#39;": "'"
};
var unescapeHtmlChar = basePropertyOf_default(htmlUnescapes);
var unescapeHtmlChar_default = unescapeHtmlChar;

// node_modules/lodash-es/unescape.js
var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;
var reHasEscapedHtml = RegExp(reEscapedHtml.source);
function unescape(string) {
  string = toString_default(string);
  return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar_default) : string;
}
var unescape_default = unescape;

// node_modules/lodash-es/_createSet.js
var INFINITY6 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY6) ? noop_default : function(values2) {
  return new Set_default(values2);
};
var createSet_default = createSet;

// node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE3 = 200;
function baseUniq(array, iteratee2, comparator) {
  var index = -1, includes2 = arrayIncludes_default, length = array.length, isCommon = true, result2 = [], seen = result2;
  if (comparator) {
    isCommon = false;
    includes2 = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE3) {
    var set3 = iteratee2 ? null : createSet_default(array);
    if (set3) {
      return setToArray_default(set3);
    }
    isCommon = false;
    includes2 = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee2 ? [] : result2;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee2) {
          seen.push(computed);
        }
        result2.push(value);
      } else if (!includes2(seen, computed, comparator)) {
        if (seen !== result2) {
          seen.push(computed);
        }
        result2.push(value);
      }
    }
  return result2;
}
var baseUniq_default = baseUniq;

// node_modules/lodash-es/union.js
var union = baseRest_default(function(arrays) {
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true));
});
var union_default = union;

// node_modules/lodash-es/unionBy.js
var unionBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), baseIteratee_default(iteratee2, 2));
});
var unionBy_default = unionBy;

// node_modules/lodash-es/unionWith.js
var unionWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseUniq_default(baseFlatten_default(arrays, 1, isArrayLikeObject_default, true), void 0, comparator);
});
var unionWith_default = unionWith;

// node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// node_modules/lodash-es/uniqBy.js
function uniqBy(array, iteratee2) {
  return array && array.length ? baseUniq_default(array, baseIteratee_default(iteratee2, 2)) : [];
}
var uniqBy_default = uniqBy;

// node_modules/lodash-es/uniqWith.js
function uniqWith(array, comparator) {
  comparator = typeof comparator == "function" ? comparator : void 0;
  return array && array.length ? baseUniq_default(array, void 0, comparator) : [];
}
var uniqWith_default = uniqWith;

// node_modules/lodash-es/uniqueId.js
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString_default(prefix) + id;
}
var uniqueId_default = uniqueId;

// node_modules/lodash-es/unset.js
function unset2(object, path) {
  return object == null ? true : baseUnset_default(object, path);
}
var unset_default = unset2;

// node_modules/lodash-es/unzip.js
var nativeMax15 = Math.max;
function unzip(array) {
  if (!(array && array.length)) {
    return [];
  }
  var length = 0;
  array = arrayFilter_default(array, function(group) {
    if (isArrayLikeObject_default(group)) {
      length = nativeMax15(group.length, length);
      return true;
    }
  });
  return baseTimes_default(length, function(index) {
    return arrayMap_default(array, baseProperty_default(index));
  });
}
var unzip_default = unzip;

// node_modules/lodash-es/unzipWith.js
function unzipWith(array, iteratee2) {
  if (!(array && array.length)) {
    return [];
  }
  var result2 = unzip_default(array);
  if (iteratee2 == null) {
    return result2;
  }
  return arrayMap_default(result2, function(group) {
    return apply_default(iteratee2, void 0, group);
  });
}
var unzipWith_default = unzipWith;

// node_modules/lodash-es/_baseUpdate.js
function baseUpdate(object, path, updater, customizer) {
  return baseSet_default(object, path, updater(baseGet_default(object, path)), customizer);
}
var baseUpdate_default = baseUpdate;

// node_modules/lodash-es/update.js
function update(object, path, updater) {
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater));
}
var update_default = update;

// node_modules/lodash-es/updateWith.js
function updateWith(object, path, updater, customizer) {
  customizer = typeof customizer == "function" ? customizer : void 0;
  return object == null ? object : baseUpdate_default(object, path, castFunction_default(updater), customizer);
}
var updateWith_default = updateWith;

// node_modules/lodash-es/upperCase.js
var upperCase = createCompounder_default(function(result2, word, index) {
  return result2 + (index ? " " : "") + word.toUpperCase();
});
var upperCase_default = upperCase;

// node_modules/lodash-es/valuesIn.js
function valuesIn(object) {
  return object == null ? [] : baseValues_default(object, keysIn_default(object));
}
var valuesIn_default = valuesIn;

// node_modules/lodash-es/without.js
var without = baseRest_default(function(array, values2) {
  return isArrayLikeObject_default(array) ? baseDifference_default(array, values2) : [];
});
var without_default = without;

// node_modules/lodash-es/wrap.js
function wrap(value, wrapper) {
  return partial_default(castFunction_default(wrapper), value);
}
var wrap_default = wrap;

// node_modules/lodash-es/wrapperAt.js
var wrapperAt = flatRest_default(function(paths) {
  var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
    return baseAt_default(object, paths);
  };
  if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper_default) || !isIndex_default(start)) {
    return this.thru(interceptor);
  }
  value = value.slice(start, +start + (length ? 1 : 0));
  value.__actions__.push({
    "func": thru_default,
    "args": [interceptor],
    "thisArg": void 0
  });
  return new LodashWrapper_default(value, this.__chain__).thru(function(array) {
    if (length && !array.length) {
      array.push(void 0);
    }
    return array;
  });
});
var wrapperAt_default = wrapperAt;

// node_modules/lodash-es/wrapperChain.js
function wrapperChain() {
  return chain_default(this);
}
var wrapperChain_default = wrapperChain;

// node_modules/lodash-es/wrapperReverse.js
function wrapperReverse() {
  var value = this.__wrapped__;
  if (value instanceof LazyWrapper_default) {
    var wrapped = value;
    if (this.__actions__.length) {
      wrapped = new LazyWrapper_default(this);
    }
    wrapped = wrapped.reverse();
    wrapped.__actions__.push({
      "func": thru_default,
      "args": [reverse_default],
      "thisArg": void 0
    });
    return new LodashWrapper_default(wrapped, this.__chain__);
  }
  return this.thru(reverse_default);
}
var wrapperReverse_default = wrapperReverse;

// node_modules/lodash-es/_baseXor.js
function baseXor(arrays, iteratee2, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq_default(arrays[0]) : [];
  }
  var index = -1, result2 = Array(length);
  while (++index < length) {
    var array = arrays[index], othIndex = -1;
    while (++othIndex < length) {
      if (othIndex != index) {
        result2[index] = baseDifference_default(result2[index] || array, arrays[othIndex], iteratee2, comparator);
      }
    }
  }
  return baseUniq_default(baseFlatten_default(result2, 1), iteratee2, comparator);
}
var baseXor_default = baseXor;

// node_modules/lodash-es/xor.js
var xor = baseRest_default(function(arrays) {
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default));
});
var xor_default = xor;

// node_modules/lodash-es/xorBy.js
var xorBy = baseRest_default(function(arrays) {
  var iteratee2 = last_default(arrays);
  if (isArrayLikeObject_default(iteratee2)) {
    iteratee2 = void 0;
  }
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), baseIteratee_default(iteratee2, 2));
});
var xorBy_default = xorBy;

// node_modules/lodash-es/xorWith.js
var xorWith = baseRest_default(function(arrays) {
  var comparator = last_default(arrays);
  comparator = typeof comparator == "function" ? comparator : void 0;
  return baseXor_default(arrayFilter_default(arrays, isArrayLikeObject_default), void 0, comparator);
});
var xorWith_default = xorWith;

// node_modules/lodash-es/zip.js
var zip = baseRest_default(unzip_default);
var zip_default = zip;

// node_modules/lodash-es/_baseZipObject.js
function baseZipObject(props, values2, assignFunc) {
  var index = -1, length = props.length, valsLength = values2.length, result2 = {};
  while (++index < length) {
    var value = index < valsLength ? values2[index] : void 0;
    assignFunc(result2, props[index], value);
  }
  return result2;
}
var baseZipObject_default = baseZipObject;

// node_modules/lodash-es/zipObject.js
function zipObject(props, values2) {
  return baseZipObject_default(props || [], values2 || [], assignValue_default);
}
var zipObject_default = zipObject;

// node_modules/lodash-es/zipObjectDeep.js
function zipObjectDeep(props, values2) {
  return baseZipObject_default(props || [], values2 || [], baseSet_default);
}
var zipObjectDeep_default = zipObjectDeep;

// node_modules/lodash-es/zipWith.js
var zipWith = baseRest_default(function(arrays) {
  var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : void 0;
  iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : void 0;
  return unzipWith_default(arrays, iteratee2);
});
var zipWith_default = zipWith;

// node_modules/lodash-es/array.default.js
var array_default_default = {
  chunk: chunk_default,
  compact: compact_default,
  concat: concat_default,
  difference: difference_default,
  differenceBy: differenceBy_default,
  differenceWith: differenceWith_default,
  drop: drop_default,
  dropRight: dropRight_default,
  dropRightWhile: dropRightWhile_default,
  dropWhile: dropWhile_default,
  fill: fill_default,
  findIndex: findIndex_default,
  findLastIndex: findLastIndex_default,
  first: head_default,
  flatten: flatten_default,
  flattenDeep: flattenDeep_default,
  flattenDepth: flattenDepth_default,
  fromPairs: fromPairs_default,
  head: head_default,
  indexOf: indexOf_default,
  initial: initial_default,
  intersection: intersection_default,
  intersectionBy: intersectionBy_default,
  intersectionWith: intersectionWith_default,
  join: join_default,
  last: last_default,
  lastIndexOf: lastIndexOf_default,
  nth: nth_default,
  pull: pull_default,
  pullAll: pullAll_default,
  pullAllBy: pullAllBy_default,
  pullAllWith: pullAllWith_default,
  pullAt: pullAt_default,
  remove: remove_default,
  reverse: reverse_default,
  slice: slice_default,
  sortedIndex: sortedIndex_default,
  sortedIndexBy: sortedIndexBy_default,
  sortedIndexOf: sortedIndexOf_default,
  sortedLastIndex: sortedLastIndex_default,
  sortedLastIndexBy: sortedLastIndexBy_default,
  sortedLastIndexOf: sortedLastIndexOf_default,
  sortedUniq: sortedUniq_default,
  sortedUniqBy: sortedUniqBy_default,
  tail: tail_default,
  take: take_default,
  takeRight: takeRight_default,
  takeRightWhile: takeRightWhile_default,
  takeWhile: takeWhile_default,
  union: union_default,
  unionBy: unionBy_default,
  unionWith: unionWith_default,
  uniq: uniq_default,
  uniqBy: uniqBy_default,
  uniqWith: uniqWith_default,
  unzip: unzip_default,
  unzipWith: unzipWith_default,
  without: without_default,
  xor: xor_default,
  xorBy: xorBy_default,
  xorWith: xorWith_default,
  zip: zip_default,
  zipObject: zipObject_default,
  zipObjectDeep: zipObjectDeep_default,
  zipWith: zipWith_default
};

// node_modules/lodash-es/collection.default.js
var collection_default_default = {
  countBy: countBy_default,
  each: forEach_default,
  eachRight: forEachRight_default,
  every: every_default,
  filter: filter_default,
  find: find_default,
  findLast: findLast_default,
  flatMap: flatMap_default,
  flatMapDeep: flatMapDeep_default,
  flatMapDepth: flatMapDepth_default,
  forEach: forEach_default,
  forEachRight: forEachRight_default,
  groupBy: groupBy_default,
  includes: includes_default,
  invokeMap: invokeMap_default,
  keyBy: keyBy_default,
  map: map_default,
  orderBy: orderBy_default,
  partition: partition_default,
  reduce: reduce_default,
  reduceRight: reduceRight_default,
  reject: reject_default,
  sample: sample_default,
  sampleSize: sampleSize_default,
  shuffle: shuffle_default,
  size: size_default,
  some: some_default,
  sortBy: sortBy_default
};

// node_modules/lodash-es/date.default.js
var date_default_default = {
  now: now_default
};

// node_modules/lodash-es/function.default.js
var function_default_default = {
  after: after_default,
  ary: ary_default,
  before: before_default,
  bind: bind_default,
  bindKey: bindKey_default,
  curry: curry_default,
  curryRight: curryRight_default,
  debounce: debounce_default,
  defer: defer_default,
  delay: delay_default,
  flip: flip_default,
  memoize: memoize_default,
  negate: negate_default,
  once: once_default,
  overArgs: overArgs_default,
  partial: partial_default,
  partialRight: partialRight_default,
  rearg: rearg_default,
  rest: rest_default,
  spread: spread_default,
  throttle: throttle_default,
  unary: unary_default,
  wrap: wrap_default
};

// node_modules/lodash-es/lang.default.js
var lang_default_default = {
  castArray: castArray_default,
  clone: clone_default,
  cloneDeep: cloneDeep_default,
  cloneDeepWith: cloneDeepWith_default,
  cloneWith: cloneWith_default,
  conformsTo: conformsTo_default,
  eq: eq_default,
  gt: gt_default,
  gte: gte_default,
  isArguments: isArguments_default,
  isArray: isArray_default,
  isArrayBuffer: isArrayBuffer_default,
  isArrayLike: isArrayLike_default,
  isArrayLikeObject: isArrayLikeObject_default,
  isBoolean: isBoolean_default,
  isBuffer: isBuffer_default,
  isDate: isDate_default,
  isElement: isElement_default,
  isEmpty: isEmpty_default,
  isEqual: isEqual_default,
  isEqualWith: isEqualWith_default,
  isError: isError_default,
  isFinite: isFinite_default,
  isFunction: isFunction_default,
  isInteger: isInteger_default,
  isLength: isLength_default,
  isMap: isMap_default,
  isMatch: isMatch_default,
  isMatchWith: isMatchWith_default,
  isNaN: isNaN_default,
  isNative: isNative_default,
  isNil: isNil_default,
  isNull: isNull_default,
  isNumber: isNumber_default,
  isObject: isObject_default,
  isObjectLike: isObjectLike_default,
  isPlainObject: isPlainObject_default,
  isRegExp: isRegExp_default,
  isSafeInteger: isSafeInteger_default,
  isSet: isSet_default,
  isString: isString_default,
  isSymbol: isSymbol_default,
  isTypedArray: isTypedArray_default,
  isUndefined: isUndefined_default,
  isWeakMap: isWeakMap_default,
  isWeakSet: isWeakSet_default,
  lt: lt_default,
  lte: lte_default,
  toArray: toArray_default,
  toFinite: toFinite_default,
  toInteger: toInteger_default,
  toLength: toLength_default,
  toNumber: toNumber_default,
  toPlainObject: toPlainObject_default,
  toSafeInteger: toSafeInteger_default,
  toString: toString_default
};

// node_modules/lodash-es/math.default.js
var math_default_default = {
  add: add_default,
  ceil: ceil_default,
  divide: divide_default,
  floor: floor_default,
  max: max_default,
  maxBy: maxBy_default,
  mean: mean_default,
  meanBy: meanBy_default,
  min: min_default,
  minBy: minBy_default,
  multiply: multiply_default,
  round: round_default,
  subtract: subtract_default,
  sum: sum_default,
  sumBy: sumBy_default
};

// node_modules/lodash-es/number.default.js
var number_default_default = {
  clamp: clamp_default,
  inRange: inRange_default,
  random: random_default
};

// node_modules/lodash-es/object.default.js
var object_default_default = {
  assign: assign_default,
  assignIn: assignIn_default,
  assignInWith: assignInWith_default,
  assignWith: assignWith_default,
  at: at_default,
  create: create_default,
  defaults: defaults_default,
  defaultsDeep: defaultsDeep_default,
  entries: toPairs_default,
  entriesIn: toPairsIn_default,
  extend: assignIn_default,
  extendWith: assignInWith_default,
  findKey: findKey_default,
  findLastKey: findLastKey_default,
  forIn: forIn_default,
  forInRight: forInRight_default,
  forOwn: forOwn_default,
  forOwnRight: forOwnRight_default,
  functions: functions_default,
  functionsIn: functionsIn_default,
  get: get_default,
  has: has_default,
  hasIn: hasIn_default,
  invert: invert_default,
  invertBy: invertBy_default,
  invoke: invoke_default,
  keys: keys_default,
  keysIn: keysIn_default,
  mapKeys: mapKeys_default,
  mapValues: mapValues_default,
  merge: merge_default,
  mergeWith: mergeWith_default,
  omit: omit_default,
  omitBy: omitBy_default,
  pick: pick_default,
  pickBy: pickBy_default,
  result: result_default,
  set: set_default,
  setWith: setWith_default,
  toPairs: toPairs_default,
  toPairsIn: toPairsIn_default,
  transform: transform_default,
  unset: unset_default,
  update: update_default,
  updateWith: updateWith_default,
  values: values_default,
  valuesIn: valuesIn_default
};

// node_modules/lodash-es/seq.default.js
var seq_default_default = {
  at: wrapperAt_default,
  chain: chain_default,
  commit: commit_default,
  lodash: wrapperLodash_default,
  next: next_default,
  plant: plant_default,
  reverse: wrapperReverse_default,
  tap: tap_default,
  thru: thru_default,
  toIterator: toIterator_default,
  toJSON: wrapperValue_default,
  value: wrapperValue_default,
  valueOf: wrapperValue_default,
  wrapperChain: wrapperChain_default
};

// node_modules/lodash-es/string.default.js
var string_default_default = {
  camelCase: camelCase_default,
  capitalize: capitalize_default,
  deburr: deburr_default,
  endsWith: endsWith_default,
  escape: escape_default,
  escapeRegExp: escapeRegExp_default,
  kebabCase: kebabCase_default,
  lowerCase: lowerCase_default,
  lowerFirst: lowerFirst_default,
  pad: pad_default,
  padEnd: padEnd_default,
  padStart: padStart_default,
  parseInt: parseInt_default,
  repeat: repeat_default,
  replace: replace_default,
  snakeCase: snakeCase_default,
  split: split_default,
  startCase: startCase_default,
  startsWith: startsWith_default,
  template: template_default,
  templateSettings: templateSettings_default,
  toLower: toLower_default,
  toUpper: toUpper_default,
  trim: trim_default,
  trimEnd: trimEnd_default,
  trimStart: trimStart_default,
  truncate: truncate_default,
  unescape: unescape_default,
  upperCase: upperCase_default,
  upperFirst: upperFirst_default,
  words: words_default
};

// node_modules/lodash-es/util.default.js
var util_default_default = {
  attempt: attempt_default,
  bindAll: bindAll_default,
  cond: cond_default,
  conforms: conforms_default,
  constant: constant_default,
  defaultTo: defaultTo_default,
  flow: flow_default,
  flowRight: flowRight_default,
  identity: identity_default,
  iteratee: iteratee_default,
  matches: matches_default,
  matchesProperty: matchesProperty_default,
  method: method_default,
  methodOf: methodOf_default,
  mixin: mixin_default,
  noop: noop_default,
  nthArg: nthArg_default,
  over: over_default,
  overEvery: overEvery_default,
  overSome: overSome_default,
  property: property_default,
  propertyOf: propertyOf_default,
  range: range_default,
  rangeRight: rangeRight_default,
  stubArray: stubArray_default,
  stubFalse: stubFalse_default,
  stubObject: stubObject_default,
  stubString: stubString_default,
  stubTrue: stubTrue_default,
  times: times_default,
  toPath: toPath_default,
  uniqueId: uniqueId_default
};

// node_modules/lodash-es/_lazyClone.js
function lazyClone() {
  var result2 = new LazyWrapper_default(this.__wrapped__);
  result2.__actions__ = copyArray_default(this.__actions__);
  result2.__dir__ = this.__dir__;
  result2.__filtered__ = this.__filtered__;
  result2.__iteratees__ = copyArray_default(this.__iteratees__);
  result2.__takeCount__ = this.__takeCount__;
  result2.__views__ = copyArray_default(this.__views__);
  return result2;
}
var lazyClone_default = lazyClone;

// node_modules/lodash-es/_lazyReverse.js
function lazyReverse() {
  if (this.__filtered__) {
    var result2 = new LazyWrapper_default(this);
    result2.__dir__ = -1;
    result2.__filtered__ = true;
  } else {
    result2 = this.clone();
    result2.__dir__ *= -1;
  }
  return result2;
}
var lazyReverse_default = lazyReverse;

// node_modules/lodash-es/_getView.js
var nativeMax16 = Math.max;
var nativeMin13 = Math.min;
function getView(start, end, transforms) {
  var index = -1, length = transforms.length;
  while (++index < length) {
    var data = transforms[index], size2 = data.size;
    switch (data.type) {
      case "drop":
        start += size2;
        break;
      case "dropRight":
        end -= size2;
        break;
      case "take":
        end = nativeMin13(end, start + size2);
        break;
      case "takeRight":
        start = nativeMax16(start, end - size2);
        break;
    }
  }
  return { "start": start, "end": end };
}
var getView_default = getView;

// node_modules/lodash-es/_lazyValue.js
var LAZY_FILTER_FLAG = 1;
var LAZY_MAP_FLAG = 2;
var nativeMin14 = Math.min;
function lazyValue() {
  var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_default(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView_default(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin14(length, this.__takeCount__);
  if (!isArr || !isRight && arrLength == length && takeCount == length) {
    return baseWrapperValue_default(array, this.__actions__);
  }
  var result2 = [];
  outer:
    while (length-- && resIndex < takeCount) {
      index += dir;
      var iterIndex = -1, value = array[index];
      while (++iterIndex < iterLength) {
        var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
        if (type == LAZY_MAP_FLAG) {
          value = computed;
        } else if (!computed) {
          if (type == LAZY_FILTER_FLAG) {
            continue outer;
          } else {
            break outer;
          }
        }
      }
      result2[resIndex++] = value;
    }
  return result2;
}
var lazyValue_default = lazyValue;

// node_modules/lodash-es/lodash.default.js
var VERSION = "4.17.21";
var WRAP_BIND_KEY_FLAG7 = 2;
var LAZY_FILTER_FLAG2 = 1;
var LAZY_WHILE_FLAG = 3;
var MAX_ARRAY_LENGTH7 = 4294967295;
var arrayProto6 = Array.prototype;
var objectProto29 = Object.prototype;
var hasOwnProperty25 = objectProto29.hasOwnProperty;
var symIterator2 = Symbol_default ? Symbol_default.iterator : void 0;
var nativeMax17 = Math.max;
var nativeMin15 = Math.min;
var mixin2 = /* @__PURE__ */ function(func) {
  return function(object, source, options2) {
    if (options2 == null) {
      var isObj = isObject_default(source), props = isObj && keys_default(source), methodNames = props && props.length && baseFunctions_default(source, props);
      if (!(methodNames ? methodNames.length : isObj)) {
        options2 = source;
        source = object;
        object = this;
      }
    }
    return func(object, source, options2);
  };
}(mixin_default);
wrapperLodash_default.after = function_default_default.after;
wrapperLodash_default.ary = function_default_default.ary;
wrapperLodash_default.assign = object_default_default.assign;
wrapperLodash_default.assignIn = object_default_default.assignIn;
wrapperLodash_default.assignInWith = object_default_default.assignInWith;
wrapperLodash_default.assignWith = object_default_default.assignWith;
wrapperLodash_default.at = object_default_default.at;
wrapperLodash_default.before = function_default_default.before;
wrapperLodash_default.bind = function_default_default.bind;
wrapperLodash_default.bindAll = util_default_default.bindAll;
wrapperLodash_default.bindKey = function_default_default.bindKey;
wrapperLodash_default.castArray = lang_default_default.castArray;
wrapperLodash_default.chain = seq_default_default.chain;
wrapperLodash_default.chunk = array_default_default.chunk;
wrapperLodash_default.compact = array_default_default.compact;
wrapperLodash_default.concat = array_default_default.concat;
wrapperLodash_default.cond = util_default_default.cond;
wrapperLodash_default.conforms = util_default_default.conforms;
wrapperLodash_default.constant = util_default_default.constant;
wrapperLodash_default.countBy = collection_default_default.countBy;
wrapperLodash_default.create = object_default_default.create;
wrapperLodash_default.curry = function_default_default.curry;
wrapperLodash_default.curryRight = function_default_default.curryRight;
wrapperLodash_default.debounce = function_default_default.debounce;
wrapperLodash_default.defaults = object_default_default.defaults;
wrapperLodash_default.defaultsDeep = object_default_default.defaultsDeep;
wrapperLodash_default.defer = function_default_default.defer;
wrapperLodash_default.delay = function_default_default.delay;
wrapperLodash_default.difference = array_default_default.difference;
wrapperLodash_default.differenceBy = array_default_default.differenceBy;
wrapperLodash_default.differenceWith = array_default_default.differenceWith;
wrapperLodash_default.drop = array_default_default.drop;
wrapperLodash_default.dropRight = array_default_default.dropRight;
wrapperLodash_default.dropRightWhile = array_default_default.dropRightWhile;
wrapperLodash_default.dropWhile = array_default_default.dropWhile;
wrapperLodash_default.fill = array_default_default.fill;
wrapperLodash_default.filter = collection_default_default.filter;
wrapperLodash_default.flatMap = collection_default_default.flatMap;
wrapperLodash_default.flatMapDeep = collection_default_default.flatMapDeep;
wrapperLodash_default.flatMapDepth = collection_default_default.flatMapDepth;
wrapperLodash_default.flatten = array_default_default.flatten;
wrapperLodash_default.flattenDeep = array_default_default.flattenDeep;
wrapperLodash_default.flattenDepth = array_default_default.flattenDepth;
wrapperLodash_default.flip = function_default_default.flip;
wrapperLodash_default.flow = util_default_default.flow;
wrapperLodash_default.flowRight = util_default_default.flowRight;
wrapperLodash_default.fromPairs = array_default_default.fromPairs;
wrapperLodash_default.functions = object_default_default.functions;
wrapperLodash_default.functionsIn = object_default_default.functionsIn;
wrapperLodash_default.groupBy = collection_default_default.groupBy;
wrapperLodash_default.initial = array_default_default.initial;
wrapperLodash_default.intersection = array_default_default.intersection;
wrapperLodash_default.intersectionBy = array_default_default.intersectionBy;
wrapperLodash_default.intersectionWith = array_default_default.intersectionWith;
wrapperLodash_default.invert = object_default_default.invert;
wrapperLodash_default.invertBy = object_default_default.invertBy;
wrapperLodash_default.invokeMap = collection_default_default.invokeMap;
wrapperLodash_default.iteratee = util_default_default.iteratee;
wrapperLodash_default.keyBy = collection_default_default.keyBy;
wrapperLodash_default.keys = keys_default;
wrapperLodash_default.keysIn = object_default_default.keysIn;
wrapperLodash_default.map = collection_default_default.map;
wrapperLodash_default.mapKeys = object_default_default.mapKeys;
wrapperLodash_default.mapValues = object_default_default.mapValues;
wrapperLodash_default.matches = util_default_default.matches;
wrapperLodash_default.matchesProperty = util_default_default.matchesProperty;
wrapperLodash_default.memoize = function_default_default.memoize;
wrapperLodash_default.merge = object_default_default.merge;
wrapperLodash_default.mergeWith = object_default_default.mergeWith;
wrapperLodash_default.method = util_default_default.method;
wrapperLodash_default.methodOf = util_default_default.methodOf;
wrapperLodash_default.mixin = mixin2;
wrapperLodash_default.negate = negate_default;
wrapperLodash_default.nthArg = util_default_default.nthArg;
wrapperLodash_default.omit = object_default_default.omit;
wrapperLodash_default.omitBy = object_default_default.omitBy;
wrapperLodash_default.once = function_default_default.once;
wrapperLodash_default.orderBy = collection_default_default.orderBy;
wrapperLodash_default.over = util_default_default.over;
wrapperLodash_default.overArgs = function_default_default.overArgs;
wrapperLodash_default.overEvery = util_default_default.overEvery;
wrapperLodash_default.overSome = util_default_default.overSome;
wrapperLodash_default.partial = function_default_default.partial;
wrapperLodash_default.partialRight = function_default_default.partialRight;
wrapperLodash_default.partition = collection_default_default.partition;
wrapperLodash_default.pick = object_default_default.pick;
wrapperLodash_default.pickBy = object_default_default.pickBy;
wrapperLodash_default.property = util_default_default.property;
wrapperLodash_default.propertyOf = util_default_default.propertyOf;
wrapperLodash_default.pull = array_default_default.pull;
wrapperLodash_default.pullAll = array_default_default.pullAll;
wrapperLodash_default.pullAllBy = array_default_default.pullAllBy;
wrapperLodash_default.pullAllWith = array_default_default.pullAllWith;
wrapperLodash_default.pullAt = array_default_default.pullAt;
wrapperLodash_default.range = util_default_default.range;
wrapperLodash_default.rangeRight = util_default_default.rangeRight;
wrapperLodash_default.rearg = function_default_default.rearg;
wrapperLodash_default.reject = collection_default_default.reject;
wrapperLodash_default.remove = array_default_default.remove;
wrapperLodash_default.rest = function_default_default.rest;
wrapperLodash_default.reverse = array_default_default.reverse;
wrapperLodash_default.sampleSize = collection_default_default.sampleSize;
wrapperLodash_default.set = object_default_default.set;
wrapperLodash_default.setWith = object_default_default.setWith;
wrapperLodash_default.shuffle = collection_default_default.shuffle;
wrapperLodash_default.slice = array_default_default.slice;
wrapperLodash_default.sortBy = collection_default_default.sortBy;
wrapperLodash_default.sortedUniq = array_default_default.sortedUniq;
wrapperLodash_default.sortedUniqBy = array_default_default.sortedUniqBy;
wrapperLodash_default.split = string_default_default.split;
wrapperLodash_default.spread = function_default_default.spread;
wrapperLodash_default.tail = array_default_default.tail;
wrapperLodash_default.take = array_default_default.take;
wrapperLodash_default.takeRight = array_default_default.takeRight;
wrapperLodash_default.takeRightWhile = array_default_default.takeRightWhile;
wrapperLodash_default.takeWhile = array_default_default.takeWhile;
wrapperLodash_default.tap = seq_default_default.tap;
wrapperLodash_default.throttle = function_default_default.throttle;
wrapperLodash_default.thru = thru_default;
wrapperLodash_default.toArray = lang_default_default.toArray;
wrapperLodash_default.toPairs = object_default_default.toPairs;
wrapperLodash_default.toPairsIn = object_default_default.toPairsIn;
wrapperLodash_default.toPath = util_default_default.toPath;
wrapperLodash_default.toPlainObject = lang_default_default.toPlainObject;
wrapperLodash_default.transform = object_default_default.transform;
wrapperLodash_default.unary = function_default_default.unary;
wrapperLodash_default.union = array_default_default.union;
wrapperLodash_default.unionBy = array_default_default.unionBy;
wrapperLodash_default.unionWith = array_default_default.unionWith;
wrapperLodash_default.uniq = array_default_default.uniq;
wrapperLodash_default.uniqBy = array_default_default.uniqBy;
wrapperLodash_default.uniqWith = array_default_default.uniqWith;
wrapperLodash_default.unset = object_default_default.unset;
wrapperLodash_default.unzip = array_default_default.unzip;
wrapperLodash_default.unzipWith = array_default_default.unzipWith;
wrapperLodash_default.update = object_default_default.update;
wrapperLodash_default.updateWith = object_default_default.updateWith;
wrapperLodash_default.values = object_default_default.values;
wrapperLodash_default.valuesIn = object_default_default.valuesIn;
wrapperLodash_default.without = array_default_default.without;
wrapperLodash_default.words = string_default_default.words;
wrapperLodash_default.wrap = function_default_default.wrap;
wrapperLodash_default.xor = array_default_default.xor;
wrapperLodash_default.xorBy = array_default_default.xorBy;
wrapperLodash_default.xorWith = array_default_default.xorWith;
wrapperLodash_default.zip = array_default_default.zip;
wrapperLodash_default.zipObject = array_default_default.zipObject;
wrapperLodash_default.zipObjectDeep = array_default_default.zipObjectDeep;
wrapperLodash_default.zipWith = array_default_default.zipWith;
wrapperLodash_default.entries = object_default_default.toPairs;
wrapperLodash_default.entriesIn = object_default_default.toPairsIn;
wrapperLodash_default.extend = object_default_default.assignIn;
wrapperLodash_default.extendWith = object_default_default.assignInWith;
mixin2(wrapperLodash_default, wrapperLodash_default);
wrapperLodash_default.add = math_default_default.add;
wrapperLodash_default.attempt = util_default_default.attempt;
wrapperLodash_default.camelCase = string_default_default.camelCase;
wrapperLodash_default.capitalize = string_default_default.capitalize;
wrapperLodash_default.ceil = math_default_default.ceil;
wrapperLodash_default.clamp = number_default_default.clamp;
wrapperLodash_default.clone = lang_default_default.clone;
wrapperLodash_default.cloneDeep = lang_default_default.cloneDeep;
wrapperLodash_default.cloneDeepWith = lang_default_default.cloneDeepWith;
wrapperLodash_default.cloneWith = lang_default_default.cloneWith;
wrapperLodash_default.conformsTo = lang_default_default.conformsTo;
wrapperLodash_default.deburr = string_default_default.deburr;
wrapperLodash_default.defaultTo = util_default_default.defaultTo;
wrapperLodash_default.divide = math_default_default.divide;
wrapperLodash_default.endsWith = string_default_default.endsWith;
wrapperLodash_default.eq = lang_default_default.eq;
wrapperLodash_default.escape = string_default_default.escape;
wrapperLodash_default.escapeRegExp = string_default_default.escapeRegExp;
wrapperLodash_default.every = collection_default_default.every;
wrapperLodash_default.find = collection_default_default.find;
wrapperLodash_default.findIndex = array_default_default.findIndex;
wrapperLodash_default.findKey = object_default_default.findKey;
wrapperLodash_default.findLast = collection_default_default.findLast;
wrapperLodash_default.findLastIndex = array_default_default.findLastIndex;
wrapperLodash_default.findLastKey = object_default_default.findLastKey;
wrapperLodash_default.floor = math_default_default.floor;
wrapperLodash_default.forEach = collection_default_default.forEach;
wrapperLodash_default.forEachRight = collection_default_default.forEachRight;
wrapperLodash_default.forIn = object_default_default.forIn;
wrapperLodash_default.forInRight = object_default_default.forInRight;
wrapperLodash_default.forOwn = object_default_default.forOwn;
wrapperLodash_default.forOwnRight = object_default_default.forOwnRight;
wrapperLodash_default.get = object_default_default.get;
wrapperLodash_default.gt = lang_default_default.gt;
wrapperLodash_default.gte = lang_default_default.gte;
wrapperLodash_default.has = object_default_default.has;
wrapperLodash_default.hasIn = object_default_default.hasIn;
wrapperLodash_default.head = array_default_default.head;
wrapperLodash_default.identity = identity_default;
wrapperLodash_default.includes = collection_default_default.includes;
wrapperLodash_default.indexOf = array_default_default.indexOf;
wrapperLodash_default.inRange = number_default_default.inRange;
wrapperLodash_default.invoke = object_default_default.invoke;
wrapperLodash_default.isArguments = lang_default_default.isArguments;
wrapperLodash_default.isArray = isArray_default;
wrapperLodash_default.isArrayBuffer = lang_default_default.isArrayBuffer;
wrapperLodash_default.isArrayLike = lang_default_default.isArrayLike;
wrapperLodash_default.isArrayLikeObject = lang_default_default.isArrayLikeObject;
wrapperLodash_default.isBoolean = lang_default_default.isBoolean;
wrapperLodash_default.isBuffer = lang_default_default.isBuffer;
wrapperLodash_default.isDate = lang_default_default.isDate;
wrapperLodash_default.isElement = lang_default_default.isElement;
wrapperLodash_default.isEmpty = lang_default_default.isEmpty;
wrapperLodash_default.isEqual = lang_default_default.isEqual;
wrapperLodash_default.isEqualWith = lang_default_default.isEqualWith;
wrapperLodash_default.isError = lang_default_default.isError;
wrapperLodash_default.isFinite = lang_default_default.isFinite;
wrapperLodash_default.isFunction = lang_default_default.isFunction;
wrapperLodash_default.isInteger = lang_default_default.isInteger;
wrapperLodash_default.isLength = lang_default_default.isLength;
wrapperLodash_default.isMap = lang_default_default.isMap;
wrapperLodash_default.isMatch = lang_default_default.isMatch;
wrapperLodash_default.isMatchWith = lang_default_default.isMatchWith;
wrapperLodash_default.isNaN = lang_default_default.isNaN;
wrapperLodash_default.isNative = lang_default_default.isNative;
wrapperLodash_default.isNil = lang_default_default.isNil;
wrapperLodash_default.isNull = lang_default_default.isNull;
wrapperLodash_default.isNumber = lang_default_default.isNumber;
wrapperLodash_default.isObject = isObject_default;
wrapperLodash_default.isObjectLike = lang_default_default.isObjectLike;
wrapperLodash_default.isPlainObject = lang_default_default.isPlainObject;
wrapperLodash_default.isRegExp = lang_default_default.isRegExp;
wrapperLodash_default.isSafeInteger = lang_default_default.isSafeInteger;
wrapperLodash_default.isSet = lang_default_default.isSet;
wrapperLodash_default.isString = lang_default_default.isString;
wrapperLodash_default.isSymbol = lang_default_default.isSymbol;
wrapperLodash_default.isTypedArray = lang_default_default.isTypedArray;
wrapperLodash_default.isUndefined = lang_default_default.isUndefined;
wrapperLodash_default.isWeakMap = lang_default_default.isWeakMap;
wrapperLodash_default.isWeakSet = lang_default_default.isWeakSet;
wrapperLodash_default.join = array_default_default.join;
wrapperLodash_default.kebabCase = string_default_default.kebabCase;
wrapperLodash_default.last = last_default;
wrapperLodash_default.lastIndexOf = array_default_default.lastIndexOf;
wrapperLodash_default.lowerCase = string_default_default.lowerCase;
wrapperLodash_default.lowerFirst = string_default_default.lowerFirst;
wrapperLodash_default.lt = lang_default_default.lt;
wrapperLodash_default.lte = lang_default_default.lte;
wrapperLodash_default.max = math_default_default.max;
wrapperLodash_default.maxBy = math_default_default.maxBy;
wrapperLodash_default.mean = math_default_default.mean;
wrapperLodash_default.meanBy = math_default_default.meanBy;
wrapperLodash_default.min = math_default_default.min;
wrapperLodash_default.minBy = math_default_default.minBy;
wrapperLodash_default.stubArray = util_default_default.stubArray;
wrapperLodash_default.stubFalse = util_default_default.stubFalse;
wrapperLodash_default.stubObject = util_default_default.stubObject;
wrapperLodash_default.stubString = util_default_default.stubString;
wrapperLodash_default.stubTrue = util_default_default.stubTrue;
wrapperLodash_default.multiply = math_default_default.multiply;
wrapperLodash_default.nth = array_default_default.nth;
wrapperLodash_default.noop = util_default_default.noop;
wrapperLodash_default.now = date_default_default.now;
wrapperLodash_default.pad = string_default_default.pad;
wrapperLodash_default.padEnd = string_default_default.padEnd;
wrapperLodash_default.padStart = string_default_default.padStart;
wrapperLodash_default.parseInt = string_default_default.parseInt;
wrapperLodash_default.random = number_default_default.random;
wrapperLodash_default.reduce = collection_default_default.reduce;
wrapperLodash_default.reduceRight = collection_default_default.reduceRight;
wrapperLodash_default.repeat = string_default_default.repeat;
wrapperLodash_default.replace = string_default_default.replace;
wrapperLodash_default.result = object_default_default.result;
wrapperLodash_default.round = math_default_default.round;
wrapperLodash_default.sample = collection_default_default.sample;
wrapperLodash_default.size = collection_default_default.size;
wrapperLodash_default.snakeCase = string_default_default.snakeCase;
wrapperLodash_default.some = collection_default_default.some;
wrapperLodash_default.sortedIndex = array_default_default.sortedIndex;
wrapperLodash_default.sortedIndexBy = array_default_default.sortedIndexBy;
wrapperLodash_default.sortedIndexOf = array_default_default.sortedIndexOf;
wrapperLodash_default.sortedLastIndex = array_default_default.sortedLastIndex;
wrapperLodash_default.sortedLastIndexBy = array_default_default.sortedLastIndexBy;
wrapperLodash_default.sortedLastIndexOf = array_default_default.sortedLastIndexOf;
wrapperLodash_default.startCase = string_default_default.startCase;
wrapperLodash_default.startsWith = string_default_default.startsWith;
wrapperLodash_default.subtract = math_default_default.subtract;
wrapperLodash_default.sum = math_default_default.sum;
wrapperLodash_default.sumBy = math_default_default.sumBy;
wrapperLodash_default.template = string_default_default.template;
wrapperLodash_default.times = util_default_default.times;
wrapperLodash_default.toFinite = lang_default_default.toFinite;
wrapperLodash_default.toInteger = toInteger_default;
wrapperLodash_default.toLength = lang_default_default.toLength;
wrapperLodash_default.toLower = string_default_default.toLower;
wrapperLodash_default.toNumber = lang_default_default.toNumber;
wrapperLodash_default.toSafeInteger = lang_default_default.toSafeInteger;
wrapperLodash_default.toString = lang_default_default.toString;
wrapperLodash_default.toUpper = string_default_default.toUpper;
wrapperLodash_default.trim = string_default_default.trim;
wrapperLodash_default.trimEnd = string_default_default.trimEnd;
wrapperLodash_default.trimStart = string_default_default.trimStart;
wrapperLodash_default.truncate = string_default_default.truncate;
wrapperLodash_default.unescape = string_default_default.unescape;
wrapperLodash_default.uniqueId = util_default_default.uniqueId;
wrapperLodash_default.upperCase = string_default_default.upperCase;
wrapperLodash_default.upperFirst = string_default_default.upperFirst;
wrapperLodash_default.each = collection_default_default.forEach;
wrapperLodash_default.eachRight = collection_default_default.forEachRight;
wrapperLodash_default.first = array_default_default.head;
mixin2(wrapperLodash_default, function() {
  var source = {};
  baseForOwn_default(wrapperLodash_default, function(func, methodName) {
    if (!hasOwnProperty25.call(wrapperLodash_default.prototype, methodName)) {
      source[methodName] = func;
    }
  });
  return source;
}(), { "chain": false });
wrapperLodash_default.VERSION = VERSION;
(wrapperLodash_default.templateSettings = string_default_default.templateSettings).imports._ = wrapperLodash_default;
arrayEach_default(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
  wrapperLodash_default[methodName].placeholder = wrapperLodash_default;
});
arrayEach_default(["drop", "take"], function(methodName, index) {
  LazyWrapper_default.prototype[methodName] = function(n) {
    n = n === void 0 ? 1 : nativeMax17(toInteger_default(n), 0);
    var result2 = this.__filtered__ && !index ? new LazyWrapper_default(this) : this.clone();
    if (result2.__filtered__) {
      result2.__takeCount__ = nativeMin15(n, result2.__takeCount__);
    } else {
      result2.__views__.push({
        "size": nativeMin15(n, MAX_ARRAY_LENGTH7),
        "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
      });
    }
    return result2;
  };
  LazyWrapper_default.prototype[methodName + "Right"] = function(n) {
    return this.reverse()[methodName](n).reverse();
  };
});
arrayEach_default(["filter", "map", "takeWhile"], function(methodName, index) {
  var type = index + 1, isFilter = type == LAZY_FILTER_FLAG2 || type == LAZY_WHILE_FLAG;
  LazyWrapper_default.prototype[methodName] = function(iteratee2) {
    var result2 = this.clone();
    result2.__iteratees__.push({
      "iteratee": baseIteratee_default(iteratee2, 3),
      "type": type
    });
    result2.__filtered__ = result2.__filtered__ || isFilter;
    return result2;
  };
});
arrayEach_default(["head", "last"], function(methodName, index) {
  var takeName = "take" + (index ? "Right" : "");
  LazyWrapper_default.prototype[methodName] = function() {
    return this[takeName](1).value()[0];
  };
});
arrayEach_default(["initial", "tail"], function(methodName, index) {
  var dropName = "drop" + (index ? "" : "Right");
  LazyWrapper_default.prototype[methodName] = function() {
    return this.__filtered__ ? new LazyWrapper_default(this) : this[dropName](1);
  };
});
LazyWrapper_default.prototype.compact = function() {
  return this.filter(identity_default);
};
LazyWrapper_default.prototype.find = function(predicate) {
  return this.filter(predicate).head();
};
LazyWrapper_default.prototype.findLast = function(predicate) {
  return this.reverse().find(predicate);
};
LazyWrapper_default.prototype.invokeMap = baseRest_default(function(path, args) {
  if (typeof path == "function") {
    return new LazyWrapper_default(this);
  }
  return this.map(function(value) {
    return baseInvoke_default(value, path, args);
  });
});
LazyWrapper_default.prototype.reject = function(predicate) {
  return this.filter(negate_default(baseIteratee_default(predicate)));
};
LazyWrapper_default.prototype.slice = function(start, end) {
  start = toInteger_default(start);
  var result2 = this;
  if (result2.__filtered__ && (start > 0 || end < 0)) {
    return new LazyWrapper_default(result2);
  }
  if (start < 0) {
    result2 = result2.takeRight(-start);
  } else if (start) {
    result2 = result2.drop(start);
  }
  if (end !== void 0) {
    end = toInteger_default(end);
    result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
  }
  return result2;
};
LazyWrapper_default.prototype.takeRightWhile = function(predicate) {
  return this.reverse().takeWhile(predicate).reverse();
};
LazyWrapper_default.prototype.toArray = function() {
  return this.take(MAX_ARRAY_LENGTH7);
};
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_default[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
  if (!lodashFunc) {
    return;
  }
  wrapperLodash_default.prototype[methodName] = function() {
    var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper_default, iteratee2 = args[0], useLazy = isLazy || isArray_default(value);
    var interceptor = function(value2) {
      var result3 = lodashFunc.apply(wrapperLodash_default, arrayPush_default([value2], args));
      return isTaker && chainAll ? result3[0] : result3;
    };
    if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
      isLazy = useLazy = false;
    }
    var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
    if (!retUnwrapped && useLazy) {
      value = onlyLazy ? value : new LazyWrapper_default(this);
      var result2 = func.apply(value, args);
      result2.__actions__.push({ "func": thru_default, "args": [interceptor], "thisArg": void 0 });
      return new LodashWrapper_default(result2, chainAll);
    }
    if (isUnwrapped && onlyLazy) {
      return func.apply(this, args);
    }
    result2 = this.thru(interceptor);
    return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
  };
});
arrayEach_default(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
  var func = arrayProto6[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
  wrapperLodash_default.prototype[methodName] = function() {
    var args = arguments;
    if (retUnwrapped && !this.__chain__) {
      var value = this.value();
      return func.apply(isArray_default(value) ? value : [], args);
    }
    return this[chainName](function(value2) {
      return func.apply(isArray_default(value2) ? value2 : [], args);
    });
  };
});
baseForOwn_default(LazyWrapper_default.prototype, function(func, methodName) {
  var lodashFunc = wrapperLodash_default[methodName];
  if (lodashFunc) {
    var key = lodashFunc.name + "";
    if (!hasOwnProperty25.call(realNames_default, key)) {
      realNames_default[key] = [];
    }
    realNames_default[key].push({ "name": methodName, "func": lodashFunc });
  }
});
realNames_default[createHybrid_default(void 0, WRAP_BIND_KEY_FLAG7).name] = [{
  "name": "wrapper",
  "func": void 0
}];
LazyWrapper_default.prototype.clone = lazyClone_default;
LazyWrapper_default.prototype.reverse = lazyReverse_default;
LazyWrapper_default.prototype.value = lazyValue_default;
wrapperLodash_default.prototype.at = seq_default_default.at;
wrapperLodash_default.prototype.chain = seq_default_default.wrapperChain;
wrapperLodash_default.prototype.commit = seq_default_default.commit;
wrapperLodash_default.prototype.next = seq_default_default.next;
wrapperLodash_default.prototype.plant = seq_default_default.plant;
wrapperLodash_default.prototype.reverse = seq_default_default.reverse;
wrapperLodash_default.prototype.toJSON = wrapperLodash_default.prototype.valueOf = wrapperLodash_default.prototype.value = seq_default_default.value;
wrapperLodash_default.prototype.first = wrapperLodash_default.prototype.head;
if (symIterator2) {
  wrapperLodash_default.prototype[symIterator2] = seq_default_default.toIterator;
}

// node_modules/@sanity/assist/dist/index.mjs
var import_react_fast_compare = __toESM(require_react_fast_compare(), 1);
function hasOverflowScroll(el) {
  const overflow = getComputedStyle(el).overflow;
  return overflow.includes("auto") || overflow.includes("hidden") || overflow.includes("scroll");
}
function useRegionRects() {
  const ref = (0, import_react.useRef)(null), [relativeBoundsRect, setRelativeBoundsRect] = (0, import_react.useState)(null), [relativeElementRect, setRelativeElementRect] = (0, import_react.useState)(null), [boundsScroll, setBoundsScroll] = (0, import_react.useState)({ x: 0, y: 0 }), [scroll, setScroll] = (0, import_react.useState)({ x: 0, y: 0 }), boundsScrollXRef = (0, import_react.useRef)(0), boundsScrollYRef = (0, import_react.useRef)(0), elementScrollXRef = (0, import_react.useRef)(0), elementScrollYRef = (0, import_react.useRef)(0);
  (0, import_react.useEffect)(() => {
    const el = ref.current;
    if (!el) return;
    const scrollParents = [];
    let parent2 = el.parentElement;
    for (; parent2 && parent2 !== document.body; )
      hasOverflowScroll(parent2) && scrollParents.push(parent2), parent2 = parent2.parentElement;
    function handleResize() {
      var _a;
      const boundsRect = ((_a = scrollParents[0]) == null ? void 0 : _a.getBoundingClientRect()) || {
        x: 0,
        y: 0,
        width: window.innerWidth,
        height: window.innerHeight
      }, domRect = el.getBoundingClientRect();
      setRelativeBoundsRect({
        x: boundsRect.x + boundsScrollXRef.current,
        y: boundsRect.y + boundsScrollYRef.current,
        w: boundsRect.width,
        h: boundsRect.height
      }), setRelativeElementRect({
        x: domRect.x + elementScrollXRef.current,
        y: domRect.y + elementScrollYRef.current,
        w: domRect.width,
        h: domRect.height
      });
    }
    function handleScroll() {
      let scrollX = window.scrollX, scrollY = window.scrollY;
      for (const scrollParent2 of scrollParents)
        scrollX += scrollParent2.scrollLeft, scrollY += scrollParent2.scrollTop;
      const scrollParent = scrollParents[0];
      boundsScrollXRef.current = scrollX - ((scrollParent == null ? void 0 : scrollParent.scrollLeft) || window.scrollX), boundsScrollYRef.current = scrollY - ((scrollParent == null ? void 0 : scrollParent.scrollTop) || window.scrollY), setBoundsScroll({
        x: boundsScrollXRef.current,
        y: boundsScrollYRef.current
      }), elementScrollXRef.current = scrollX, elementScrollYRef.current = scrollY, setScroll({ x: scrollX, y: scrollY });
    }
    window.addEventListener("scroll", handleScroll, { passive: true });
    const ro = new ResizeObserver(handleResize);
    ro.observe(el);
    for (const scrollParent of scrollParents)
      scrollParent.addEventListener("scroll", handleScroll, { passive: true }), ro.observe(scrollParent);
    return handleScroll(), () => {
      ro.unobserve(el);
      for (const scrollParent of scrollParents)
        ro.unobserve(scrollParent), scrollParent.removeEventListener("scroll", handleScroll);
      ro.disconnect(), window.removeEventListener("scroll", handleScroll);
    };
  }, []);
  const bounds = (0, import_react.useMemo)(
    () => relativeBoundsRect && {
      x: relativeBoundsRect.x - boundsScroll.x,
      y: relativeBoundsRect.y - boundsScroll.y,
      w: relativeBoundsRect.w,
      h: relativeBoundsRect.h
    },
    [relativeBoundsRect, boundsScroll]
  ), element = (0, import_react.useMemo)(
    () => relativeElementRect && {
      x: relativeElementRect.x - scroll.x,
      y: relativeElementRect.y - scroll.y,
      w: relativeElementRect.w,
      h: relativeElementRect.h
    },
    [relativeElementRect, scroll]
  );
  return { bounds, element, ref };
}
function ConnectorRegion(props) {
  const { children, onRectsChange, ...restProps } = props, { bounds, element, ref } = useRegionRects();
  return (0, import_react.useEffect)(() => {
    onRectsChange == null ? void 0 : onRectsChange(bounds && element ? { bounds, element } : null);
  }, [bounds, element, onRectsChange]), (0, import_jsx_runtime.jsx)("div", { ...restProps, ref, children });
}
var ConnectorsStoreContext = (0, import_react.createContext)(null);
function useConnectorsStore() {
  const store = (0, import_react.useContext)(ConnectorsStoreContext);
  if (!store)
    throw new Error("Missing connectors store context");
  return store;
}
function ConnectFromRegion(props) {
  const { children, _key: key, zIndex, ...restProps } = props, store = useConnectorsStore(), [rects, setRects] = (0, import_react.useState)(null);
  return (0, import_react.useEffect)(() => store.from.subscribe(key, { zIndex }), [key, store, zIndex]), (0, import_react.useEffect)(() => {
    rects && store.from.next(key, rects);
  }, [key, rects, store]), (0, import_jsx_runtime.jsx)(ConnectorRegion, { ...restProps, onRectsChange: setRects, children });
}
function createConnectorsStore() {
  const configKeys = [], fieldKeys = [], channels = {
    from: /* @__PURE__ */ new Map(),
    to: /* @__PURE__ */ new Map()
  }, payloads = {
    from: /* @__PURE__ */ new Map(),
    to: /* @__PURE__ */ new Map()
  }, observers = [];
  function notifyObservers() {
    const connectors = [];
    for (const key of configKeys) {
      const toRects = channels.to.get(key), toPayload = payloads.from.get(key), fromRects = channels.from.get(key), fromPayload = payloads.from.get(key);
      toRects && fromRects && connectors.push({
        key,
        from: { ...fromRects, payload: fromPayload },
        to: { ...toRects, payload: toPayload }
      });
    }
    for (const observer of observers)
      observer(connectors);
  }
  return {
    to: {
      subscribe(key, payload) {
        return channels.to.set(key, null), payloads.to.set(key, payload), configKeys.push(key), () => {
          channels.to.delete(key), payloads.to.delete(key);
          const idx = configKeys.indexOf(key);
          idx > -1 && configKeys.splice(idx, 1), notifyObservers();
        };
      },
      next(key, rects) {
        channels.to.set(key, rects), fieldKeys.includes(key) && notifyObservers();
      }
    },
    connectors: {
      subscribe(observer) {
        return observers.push(observer), () => {
          const idx = observers.indexOf(observer);
          idx > -1 && observers.splice(idx, 1);
        };
      }
    },
    from: {
      subscribe(key, payload) {
        return channels.from.set(key, null), payloads.from.set(key, payload), fieldKeys.push(key), () => {
          channels.from.delete(key), payloads.from.delete(key);
          const idx = fieldKeys.indexOf(key);
          idx > -1 && fieldKeys.splice(idx, 1), notifyObservers();
        };
      },
      next(key, rects) {
        channels.from.set(key, rects), configKeys.includes(key) && notifyObservers();
      }
    }
  };
}
function ConnectorsProvider(props) {
  const { children, onConnectorsChange } = props, store = (0, import_react.useMemo)(() => createConnectorsStore(), []);
  return (0, import_react.useEffect)(
    () => onConnectorsChange && store.connectors.subscribe(onConnectorsChange),
    [onConnectorsChange, store]
  ), (0, import_jsx_runtime.jsx)(ConnectorsStoreContext.Provider, { value: store, children });
}
function getConnectorLinePoint(options2, rect, bounds) {
  const centerY = rect.y + rect.h / 2, isAbove = rect.y + rect.h < bounds.y + options2.arrow.marginY, isBelow = rect.y > bounds.y + bounds.h - options2.arrow.marginY;
  return {
    bounds,
    x: rect.x,
    y: centerY,
    centerY,
    startY: rect.y + options2.path.marginY,
    endY: rect.y + rect.h - options2.path.marginY,
    isAbove,
    isBelow,
    outOfBounds: isAbove || isBelow
  };
}
function mapConnectorToLine(options2, connector) {
  const fromBounds = {
    y: connector.from.bounds.y + options2.arrow.threshold,
    // bottom: connector.from.bounds.y + connector.from.bounds.h - options.arrow.threshold,
    x: connector.from.bounds.x,
    // right: connector.from.bounds.x + connector.from.bounds.w,
    w: connector.from.bounds.w,
    h: connector.from.bounds.h - options2.arrow.threshold * 2
  }, from = getConnectorLinePoint(options2, connector.from.element, fromBounds);
  from.x = connector.from.element.x + connector.from.element.w;
  const fromBottom = fromBounds.y + fromBounds.h, toBounds = {
    y: connector.to.bounds.y + options2.arrow.threshold,
    // bottom: connector.to.bounds.y + connector.to.bounds.h - options.arrow.threshold,
    x: connector.to.bounds.x,
    // right: connector.to.bounds.x + connector.to.bounds.w,
    w: connector.to.bounds.w,
    h: connector.to.bounds.h - options2.arrow.threshold * 2
  }, toBottom = toBounds.y + toBounds.h, to = getConnectorLinePoint(options2, connector.to.element, toBounds), maxStartY = Math.max(to.startY, from.startY);
  return from.y = Math.min(maxStartY, from.endY), from.y < toBounds.y ? from.y = Math.min(toBounds.y, from.endY) : from.y > toBottom && (from.y = Math.max(toBottom, from.startY)), to.y = Math.min(maxStartY, to.endY), to.y < fromBounds.y ? to.y = Math.min(fromBounds.y, to.endY) : to.y > fromBottom && (to.y = Math.max(fromBottom, to.startY)), from.y = Math.min(Math.max(from.y, fromBounds.y), fromBottom), to.y = Math.min(Math.max(to.y, toBounds.y), toBottom), { from, to };
}
var assistFormId = "assist";
var assistDocumentIdPrefix = "sanity.assist.schemaType.";
var assistDocumentStatusIdPrefix = "sanity.assist.status.";
var assistSchemaIdPrefix = "sanity.assist.schema.";
var assistDocumentTypeName = "sanity.assist.schemaType.annotations";
var assistFieldTypeName = "sanity.assist.schemaType.field";
var instructionTypeName = "sanity.assist.instruction";
var promptTypeName = "sanity.assist.instruction.prompt";
var userInputTypeName = "sanity.assist.instruction.userInput";
var instructionContextTypeName = "sanity.assist.instruction.context";
var fieldReferenceTypeName = "sanity.assist.instruction.fieldRef";
var contextDocumentTypeName = "assist.instruction.context";
var assistTasksStatusTypeName = "sanity.assist.task.status";
var instructionTaskTypeName = "sanity.assist.instructionTask";
var fieldPresenceTypeName = "sanity.assist.instructionTask.presence";
var assistSerializedTypeName = "sanity.assist.serialized.type";
var assistSerializedFieldTypeName = "sanity.assist.serialized.field";
var outputFieldTypeName = "sanity.assist.output.field";
var outputTypeTypeName = "sanity.assist.output.type";
var fieldPathParam = "pathKey";
var instructionParam = "instruction";
var documentRootKey = "<document>";
function usePathKey(path) {
  return (0, import_react.useMemo)(() => getPathKey(path), [path]);
}
function getPathKey(path) {
  return path.length ? Array.isArray(path) ? pathToString$1(path) : path : documentRootKey;
}
function getInstructionTitle(instruction2) {
  return (instruction2 == null ? void 0 : instruction2.title) ?? "Untitled";
}
function isDefined(t) {
  return t != null;
}
function isPortableTextArray(type) {
  return type.of.find((t) => isType(t, "block"));
}
function isType(schemaType, typeName) {
  return schemaType.name === typeName ? true : schemaType.type ? isType(schemaType.type, typeName) : false;
}
function isImage(schemaType) {
  return isType(schemaType, "image");
}
function getDescriptionFieldOption(schemaType) {
  var _a, _b;
  if (!schemaType)
    return;
  const descriptionField = (_b = (_a = schemaType.options) == null ? void 0 : _a.aiAssist) == null ? void 0 : _b.imageDescriptionField;
  return typeof descriptionField == "string" ? {
    path: descriptionField,
    updateOnImageChange: true
  } : descriptionField ? {
    path: descriptionField.path,
    updateOnImageChange: descriptionField.updateOnImageChange ?? true
  } : getDescriptionFieldOption(schemaType.type);
}
function getImageInstructionFieldOption(schemaType) {
  var _a, _b;
  return schemaType ? ((_b = (_a = schemaType.options) == null ? void 0 : _a.aiAssist) == null ? void 0 : _b.imageInstructionField) || getImageInstructionFieldOption(schemaType.type) : void 0;
}
function isSchemaAssistEnabled(type) {
  var _a, _b;
  return !((_b = (_a = type.options) == null ? void 0 : _a.aiAssist) == null ? void 0 : _b.exclude);
}
function isAssistSupported(type) {
  return !isSchemaAssistEnabled(type) || isDisabled(type) ? false : type.jsonType === "array" ? !type.of.every((t) => isDisabled(t)) : type.jsonType === "object" ? !type.fields.every((field) => isDisabled(field.type)) || /* to allow attaching custom actions on fieldless images */
  isType(type, "image") : true;
}
function isDisabled(type) {
  return !isSchemaAssistEnabled(type) || isUnsupportedType(type);
}
function isUnsupportedType(type) {
  var _a, _b;
  return type.name === "sanity.imageCrop" || type.name === "sanity.imageHotspot" || isType(type, "globalDocumentReference") || isType(type, "reference") && !((_b = (_a = type == null ? void 0 : type.options) == null ? void 0 : _a.aiAssist) == null ? void 0 : _b.embeddingsIndex) || isType(type, "crossDatasetReference") || isType(type, "file");
}
var FirstAssistedPathContext = (0, import_react.createContext)(void 0);
function FirstAssistedPathProvider(props) {
  const { members } = props, firstAssistedPath = (0, import_react.useMemo)(() => {
    const firstAssisted = members.find(
      (member) => member.kind === "field" && isAssistSupported(member.field.schemaType)
    );
    return (firstAssisted == null ? void 0 : firstAssisted.field.path) ? pathToString$1(firstAssisted == null ? void 0 : firstAssisted.field.path) : void 0;
  }, [members]);
  return (0, import_jsx_runtime.jsx)(FirstAssistedPathContext.Provider, { value: firstAssistedPath, children: props.children });
}
var releaseAnnouncementUrl = "https://www.sanity.io/blog/sanity-ai-assist-announcement?utm_source=sanity-assist-plugin&utm_medium=organic_social&utm_campaign=ai-assist&utm_content=";
var instructionGuideUrl = "https://sanity.io/guides/getting-started-with-ai-assist-instructions?utm_source=sanity-assist-plugin&utm_medium=organic_social&utm_campaign=ai-assist&utm_content=";
var giveFeedbackUrl = "https://forms.gle/Kwz7CThxGeA2GiEU8";
var salesUrl = "https://www.sanity.io/contact/sales?utm_source=sanity-assist-plugin&utm_medium=organic_social&utm_campaign=ai-assist&utm_content=";
var packageName = "@sanity/assist";
var pluginTitle = "Sanity AI Assist";
var pluginTitleShort = "AI Assist";
var maxHistoryVisibilityMs = minutesToMilliseconds(30);
var illegalIdChars = /[^a-zA-Z0-9._-]/g;
function assistDocumentId(documentType) {
  return `${assistDocumentIdPrefix}${documentType}`.replace(illegalIdChars, "_");
}
function assistTasksStatusId(documentId) {
  return isVersionId(documentId) ? `${assistDocumentStatusIdPrefix}${getVersionFromId(documentId)}.${getPublishedId(documentId)}` : `${assistDocumentStatusIdPrefix}${getPublishedId(documentId)}`;
}
function useDocumentState(id, docType) {
  const state = useEditState(id, docType);
  return state.draft || state.published;
}
function useStudioAssistDocument({
  documentId,
  schemaType,
  initDoc
}) {
  const documentTypeName = schemaType.name, currentUser = useCurrentUser(), assistDocument = useDocumentState(
    assistDocumentId(documentTypeName),
    assistDocumentTypeName
  ), assistTasksStatus = useDocumentState(
    assistTasksStatusId(documentId ?? ""),
    assistTasksStatusTypeName
  ), client = useClient({ apiVersion: "2023-01-01" });
  return (0, import_react.useEffect)(() => {
    !assistDocument && initDoc && client.createIfNotExists({
      _id: assistDocumentId(documentTypeName),
      _type: assistDocumentTypeName
    }).catch(() => {
    });
  }, [client, assistDocument, documentTypeName, initDoc]), (0, import_react.useMemo)(() => {
    if (!assistDocument)
      return;
    const tasks = (assistTasksStatus == null ? void 0 : assistTasksStatus.tasks) ?? [], fields = ((assistDocument == null ? void 0 : assistDocument.fields) ?? []).map((assistField) => {
      var _a;
      return {
        ...assistField,
        tasks: tasks.filter((task) => task.path === assistField.path),
        instructions: (_a = assistField.instructions) == null ? void 0 : _a.filter((p) => !p.userId || p.userId === (currentUser == null ? void 0 : currentUser.id)).map((instruction2) => asStudioInstruction(instruction2, tasks))
      };
    });
    return typed({
      ...assistDocument,
      tasks: tasks == null ? void 0 : tasks.map((task) => {
        var _a, _b;
        const instruction2 = (_b = (_a = fields.find((f) => f.path === task.path)) == null ? void 0 : _a.instructions) == null ? void 0 : _b.find((i) => i._key === task.instructionKey);
        return {
          ...task,
          instruction: instruction2
        };
      }),
      fields
    });
  }, [assistDocument, assistTasksStatus, currentUser]);
}
function asStudioInstruction(instruction2, run) {
  return {
    ...instruction2,
    tasks: run.filter((task) => task.instructionKey === instruction2._key).filter(
      (task) => task.started && (/* @__PURE__ */ new Date()).getTime() - new Date(task.started).getTime() < maxHistoryVisibilityMs
    )
  };
}
var NO_TASKS = [];
function useInstructionToaster(documentId, documentSchemaType) {
  const assistDocument = useStudioAssistDocument({ documentId, schemaType: documentSchemaType }), assistDocLoaded = !!assistDocument, currentUser = useCurrentUser(), toast = useToast(), tasks = assistDocument == null ? void 0 : assistDocument.tasks, previousTasks = (0, import_react.useRef)("initial");
  (0, import_react.useEffect)(() => {
    var _a;
    if (assistDocLoaded) {
      if (previousTasks.current !== "initial") {
        const prevTaskByKey = Object.fromEntries(
          (previousTasks.current ?? NO_TASKS).map((run) => [run._key, run])
        );
        (_a = tasks == null ? void 0 : tasks.filter((task) => task.startedByUserId === (currentUser == null ? void 0 : currentUser.id)).filter((task) => {
          const prevTask = prevTaskByKey[task._key];
          return !prevTask && task.ended || !(prevTask == null ? void 0 : prevTask.ended) && task.ended;
        }).filter((task) => task.ended && isAfter(addSeconds(new Date(task.ended), 30), /* @__PURE__ */ new Date()))) == null ? void 0 : _a.forEach((task) => {
          const title = task.title ?? getInstructionTitle(task.instruction);
          task.reason === "error" ? toast.push({
            title: `Failed: ${title}`,
            status: "error",
            description: `Instruction failed. ${task.message ?? ""}`,
            closable: true,
            duration: 1e4
          }) : task.reason === "timeout" ? toast.push({
            title: `Timeout: ${title}`,
            status: "error",
            description: "Instruction timed out.",
            closable: true
          }) : task.reason === "success" ? toast.push({
            title: `Success: ${title}`,
            status: "success",
            description: "Instruction completed.",
            closable: true
          }) : task.reason === "aborted" && toast.push({
            title: `Canceled: ${title}`,
            status: "warning",
            description: "Instruction canceled.",
            closable: true
          });
        });
      }
      previousTasks.current = tasks;
    }
  }, [tasks, previousTasks, toast, currentUser, assistDocLoaded]);
}
function AssistDocumentInputWrapper(props) {
  var _a;
  if (!isType(props.schemaType, "document") && props.id !== "root" && props.id !== assistFormId)
    return (0, import_jsx_runtime.jsx)(AssistInput, { ...props });
  const documentId = (_a = props.value) == null ? void 0 : _a._id;
  return documentId ? (0, import_jsx_runtime.jsx)(AssistDocumentInput, { ...props, documentId }) : props.renderDefault(props);
}
function AssistDocumentInput({ documentId, ...props }) {
  useInstructionToaster(documentId, props.schemaType);
  const schemaType = (0, import_react.useMemo)(() => props.schemaType.name !== assistDocumentTypeName ? props.schemaType : {
    ...props.schemaType,
    type: {
      ...props.schemaType.type,
      // compatability with i18nArrays plugin that requires this to be document
      name: "document"
    }
  }, [props.schemaType]);
  return (0, import_jsx_runtime.jsx)(FirstAssistedPathProvider, { members: props.members, children: props.renderDefault({ ...props, schemaType }) });
}
function AssistInput(props) {
  const { zIndex } = useLayer(), { paneKey } = useDocumentPane(), pathKey = usePathKey(props.path);
  return (0, import_jsx_runtime.jsx)(ConnectFromRegion, { _key: `${paneKey}_${pathKey}`, zIndex, style: { minWidth: 0 }, children: props.renderDefault(props) });
}
var AssistDocumentContext = (0, import_react.createContext)(
  void 0
);
function useAssistDocumentContext() {
  const context = (0, import_react.useContext)(AssistDocumentContext);
  if (!context)
    throw new Error("AssistDocumentContext value is missing");
  return context;
}
var AiAssistanceConfigContext = (0, import_react.createContext)({});
function useAiAssistanceConfig() {
  const context = (0, import_react.useContext)(AiAssistanceConfigContext);
  if (!context)
    throw new Error("Missing AiAssistanceConfigContext");
  return context;
}
function useSerializedTypes() {
  return useAiAssistanceConfig().serializedTypes;
}
var basePath = "/assist/tasks/instruction";
var API_VERSION_WITH_EXTENDED_TYPES = "2025-04-01";
function canUseAssist(status) {
  return (status == null ? void 0 : status.enabled) && status.initialized && status.validToken;
}
function useApiClient(customApiClient) {
  const client = useClient({ apiVersion: API_VERSION_WITH_EXTENDED_TYPES });
  return (0, import_react.useMemo)(
    () => customApiClient ? customApiClient(client) : client,
    [client, customApiClient]
  );
}
function useTranslate(apiClient) {
  const [loading, setLoading] = (0, import_react.useState)(false), user = useCurrentUser(), types = useSerializedTypes(), toast = useToast(), translate = (0, import_react.useCallback)(
    ({
      documentId,
      languagePath,
      styleguide,
      translatePath,
      fieldLanguageMap,
      conditionalMembers
    }) => {
      setLoading(true);
      async function run() {
        return apiClient.request({
          method: "POST",
          url: `/assist/tasks/translate/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
          body: {
            documentId,
            types,
            languagePath,
            userStyleguide: await styleguide(),
            fieldLanguageMap,
            conditionalMembers,
            translatePath: translatePath.length === 0 ? documentRootKey : pathToString$1(translatePath),
            userId: user == null ? void 0 : user.id
          }
        });
      }
      return run().catch((e) => {
        throw toast.push({
          status: "error",
          title: "Translate failed",
          description: e.message
        }), setLoading(false), e;
      }).finally(() => {
        setTimeout(() => {
          setLoading(false);
        }, 2e3);
      });
    },
    [setLoading, apiClient, toast, user, types]
  );
  return (0, import_react.useMemo)(
    () => ({
      translate,
      loading
    }),
    [translate, loading]
  );
}
function useGenerateCaption(apiClient) {
  const [loading, setLoading] = (0, import_react.useState)(false), user = useCurrentUser(), types = useSerializedTypes(), toast = useToast(), generateCaption = (0, import_react.useCallback)(
    ({ path, documentId }) => (setLoading(true), apiClient.request({
      method: "POST",
      url: `/assist/tasks/generate-caption/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
      body: {
        path,
        documentId,
        types,
        userId: user == null ? void 0 : user.id
      }
    }).catch((e) => {
      throw toast.push({
        status: "error",
        title: "Generate image description failed",
        description: e.message
      }), setLoading(false), e;
    }).finally(() => {
      setTimeout(() => {
        setLoading(false);
      }, 2e3);
    })),
    [setLoading, apiClient, toast, user, types]
  );
  return (0, import_react.useMemo)(
    () => ({
      generateCaption,
      loading
    }),
    [generateCaption, loading]
  );
}
function useGenerateImage(apiClient) {
  const [loading, setLoading] = (0, import_react.useState)(false), user = useCurrentUser(), types = useSerializedTypes(), toast = useToast(), generateImage = (0, import_react.useCallback)(
    ({ path, documentId }) => (setLoading(true), apiClient.request({
      method: "POST",
      url: `/assist/tasks/generate-image/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
      body: {
        path,
        documentId,
        types,
        userId: user == null ? void 0 : user.id
      }
    }).catch((e) => {
      throw toast.push({
        status: "error",
        title: "Generate image from prompt failed",
        description: e.message
      }), setLoading(false), e;
    }).finally(() => {
      setTimeout(() => {
        setLoading(false);
      }, 2e3);
    })),
    [setLoading, apiClient, toast, user, types]
  );
  return (0, import_react.useMemo)(
    () => ({
      generateImage,
      loading
    }),
    [generateImage, loading]
  );
}
function useGetInstructStatus(apiClient) {
  const [loading, setLoading] = (0, import_react.useState)(true), getInstructStatus = (0, import_react.useCallback)(async () => {
    setLoading(true);
    const projectId = apiClient.config().projectId;
    try {
      return await apiClient.request({
        method: "GET",
        url: `${basePath}/${apiClient.config().dataset}/status?projectId=${projectId}`
      });
    } finally {
      setLoading(false);
    }
  }, [setLoading, apiClient]);
  return {
    loading,
    getInstructStatus
  };
}
function useInitInstruct(apiClient) {
  const [loading, setLoading] = (0, import_react.useState)(false), initInstruct = (0, import_react.useCallback)(() => (setLoading(true), apiClient.request({
    method: "GET",
    url: `${basePath}/${apiClient.config().dataset}/init?projectId=${apiClient.config().projectId}`
  }).finally(() => {
    setLoading(false);
  })), [setLoading, apiClient]);
  return {
    loading,
    initInstruct
  };
}
function useRunInstructionApi(apiClient) {
  const toast = useToast(), [loading, setLoading] = (0, import_react.useState)(false), user = useCurrentUser(), types = useSerializedTypes(), {
    config: { assist: assistConfig }
  } = useAiAssistanceConfig(), runInstruction = (0, import_react.useCallback)(
    (request) => {
      var _a;
      if (!user) {
        toast.push({
          status: "error",
          title: "Unable to get user for instruction."
        });
        return;
      }
      setLoading(true);
      const { timeZone, locale } = Intl.DateTimeFormat().resolvedOptions(), defaultLocaleSettings = { timeZone, locale }, localeSettings = ((_a = assistConfig == null ? void 0 : assistConfig.localeSettings) == null ? void 0 : _a.call(assistConfig, { user, defaultSettings: defaultLocaleSettings })) ?? defaultLocaleSettings;
      return apiClient.request({
        method: "POST",
        url: `${basePath}/${apiClient.config().dataset}?projectId=${apiClient.config().projectId}`,
        body: {
          ...request,
          types,
          userId: user == null ? void 0 : user.id,
          localeSettings,
          maxPathDepth: assistConfig == null ? void 0 : assistConfig.maxPathDepth
        }
      }).catch((e) => {
        throw toast.push({
          status: "error",
          title: "Instruction failed",
          description: e.message
        }), e;
      }).finally(() => {
        setLoading(false);
      });
    },
    [apiClient, types, user, toast, assistConfig]
  );
  return (0, import_react.useMemo)(
    () => ({
      runInstruction,
      loading
    }),
    [runInstruction, loading]
  );
}
var NO_INPUT = {};
var RunInstructionContext = (0, import_react.createContext)({
  runInstruction: () => {
  },
  getUserInput: async () => {
  },
  instructionLoading: false
});
function useRunInstruction() {
  return (0, import_react.useContext)(RunInstructionContext);
}
function isUserInputBlock(block) {
  return block._type === userInputTypeName;
}
function RunInstructionProvider(props) {
  var _a;
  const { config } = useAiAssistanceConfig(), apiClient = useApiClient(config == null ? void 0 : config.__customApiClient), { runInstruction: runInstructionRequest, loading } = useRunInstructionApi(apiClient), id = (0, import_react.useId)(), [inputs, setInputs] = (0, import_react.useState)(NO_INPUT), [runRequest, setRunRequest] = (0, import_react.useState)(), [resolveUserInput, setResolveUserInput] = (0, import_react.useState)(), getUserInput = (0, import_react.useCallback)(async ({ title, inputs: inputs2 }) => {
    const userInputBlocks = inputs2.map((input, i) => ({
      _type: userInputTypeName,
      _key: input.id ?? `${i}`,
      message: input.title,
      description: input.description
    }));
    if (userInputBlocks.length)
      return setRunRequest({ dialogTitle: title, userInputBlocks }), new Promise((resolve) => {
        setResolveUserInput(() => resolve);
      });
  }, []), runInstruction = (0, import_react.useCallback)(
    (req) => {
      var _a2;
      if (loading)
        return;
      const { instruction: instruction2, ...request } = req, instructionKey = instruction2._key, userInputBlocks = (_a2 = instruction2 == null ? void 0 : instruction2.prompt) == null ? void 0 : _a2.flatMap(
        (block) => block._type === "block" ? block.children.filter(isUserInputBlock) : [block]
      ).filter(isUserInputBlock);
      if (!(userInputBlocks == null ? void 0 : userInputBlocks.length)) {
        runInstructionRequest({
          ...request,
          instructionKey,
          userTexts: void 0
        });
        return;
      }
      setRunRequest({
        ...req,
        userInputBlocks
      });
    },
    [runInstructionRequest, loading]
  ), close = (0, import_react.useCallback)(() => {
    setRunRequest(void 0), setInputs(NO_INPUT), resolveUserInput && resolveUserInput(void 0), setResolveUserInput(void 0);
  }, [resolveUserInput]), runWithInput = (0, import_react.useCallback)(() => {
    if (runRequest)
      if ("instruction" in runRequest) {
        const { instruction: instruction2, userTexts, ...request } = runRequest;
        runInstructionRequest({
          ...request,
          instructionKey: instruction2._key,
          userTexts: Object.entries(inputs).map(([key, value]) => ({
            blockKey: key,
            userInput: value
          }))
        });
      } else {
        const userInputs = Object.values(inputs).map((input, i) => {
          const userInputBlock = runRequest.userInputBlocks[i];
          return {
            input: {
              id: userInputBlock._key,
              title: userInputBlock.message ?? "",
              description: userInputBlock.description
            },
            result: input
          };
        });
        resolveUserInput == null ? void 0 : resolveUserInput(userInputs), setResolveUserInput(void 0);
      }
    close();
  }, [close, runInstructionRequest, runRequest, inputs, resolveUserInput]), open = !!runRequest, runDisabled = (0, import_react.useMemo)(
    () => {
      var _a2;
      return (((_a2 = runRequest == null ? void 0 : runRequest.userInputBlocks) == null ? void 0 : _a2.length) ?? 0) > Object.entries(inputs).filter(([, value]) => !!value).length;
    },
    [runRequest == null ? void 0 : runRequest.userInputBlocks, inputs]
  ), runButton = (0, import_jsx_runtime.jsx)(
    Button,
    {
      text: "Run instruction",
      onClick: runWithInput,
      tone: "primary",
      icon: PlayIcon,
      style: { width: "100%" },
      disabled: runDisabled
    }
  ), contextValue = (0, import_react.useMemo)(
    () => ({ runInstruction, getUserInput, instructionLoading: loading }),
    [runInstruction, loading]
  );
  return (0, import_jsx_runtime.jsxs)(RunInstructionContext.Provider, { value: contextValue, children: [
    open ? (0, import_jsx_runtime.jsx)(
      Dialog,
      {
        id,
        open,
        onClose: close,
        width: 1,
        header: "dialogTitle" in runRequest ? runRequest.dialogTitle : getInstructionTitle(runRequest == null ? void 0 : runRequest.instruction),
        footer: (0, import_jsx_runtime.jsx)(Flex, { justify: "space-between", padding: 2, flex: 1, children: runDisabled ? (0, import_jsx_runtime.jsx)(
          Tooltip,
          {
            content: (0, import_jsx_runtime.jsx)(Flex, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { children: "Unable to run instruction. All fields must have a value." }) }),
            placement: "top",
            children: (0, import_jsx_runtime.jsx)(Flex, { flex: 1, children: runButton })
          }
        ) : runButton }),
        children: (0, import_jsx_runtime.jsx)(Stack, { padding: 4, space: 2, children: (_a = runRequest == null ? void 0 : runRequest.userInputBlocks) == null ? void 0 : _a.map((block, i) => (0, import_jsx_runtime.jsx)(
          UserInput,
          {
            block,
            autoFocus: i === 0,
            inputs,
            setInputs
          },
          block._key
        )) })
      }
    ) : null,
    props.children
  ] });
}
function UserInput(props) {
  const { block, autoFocus, setInputs, inputs } = props, key = block._key, textAreaRef = (0, import_react.useRef)(null), onChange = (0, import_react.useCallback)(
    (e) => {
      setInputs((current) => ({
        ...current,
        [key]: (e.currentTarget ?? e.target).value
      }));
    },
    [key, setInputs]
  ), value = (0, import_react.useMemo)(() => inputs[key], [inputs, key]);
  return (0, import_react.useEffect)(() => {
    autoFocus && setTimeout(() => {
      var _a;
      return (_a = textAreaRef.current) == null ? void 0 : _a.focus();
    }, 0);
  }, [autoFocus]), (0, import_jsx_runtime.jsxs)(Stack, { padding: 2, space: 3, children: [
    (0, import_jsx_runtime.jsx)(
      FormFieldHeaderText,
      {
        title: (block == null ? void 0 : block.message) ?? "Provide more context",
        description: block.description
      }
    ),
    (0, import_jsx_runtime.jsx)(
      TextArea,
      {
        ref: textAreaRef,
        rows: 4,
        value,
        onChange,
        style: { resize: "vertical" }
      }
    )
  ] });
}
function isDocAssistable(documentSchemaType, published, draft) {
  return !!(documentSchemaType.liveEdit ? published : draft);
}
function useRequestRunInstruction(args) {
  const { runInstruction, instructionLoading } = useRunInstruction(), requestRunInstruction = useDraftDelayedTask({
    ...args,
    task: runInstruction
  });
  return {
    instructionLoading,
    requestRunInstruction
  };
}
function useDraftDelayedTask(args) {
  const { documentOnChange, isDocAssistable: isDocAssistable2, task } = args, [queuedArgs, setQueuedArgs] = (0, import_react.useState)(void 0);
  return (0, import_react.useEffect)(() => {
    queuedArgs && isDocAssistable2 && (task(queuedArgs), setQueuedArgs(void 0));
  }, [queuedArgs, isDocAssistable2, task]), (0, import_react.useCallback)(
    (taskArgs) => {
      documentOnChange(PatchEvent.from([unset(["_force_document_creation"])])), setQueuedArgs(taskArgs);
    },
    [setQueuedArgs, documentOnChange]
  );
}
var maxDepth = 6;
function getTypeIcon(schemaType) {
  let t = schemaType;
  for (; t; ) {
    if (t.icon) return t.icon;
    t = t.type;
  }
  return isType(schemaType, "slug") ? LinkIcon : isType(schemaType, "image") ? ImageIcon : schemaType.jsonType === "array" && isPortableTextArray(schemaType) ? BlockContentIcon : schemaType.jsonType === "array" ? OlistIcon : schemaType.jsonType === "object" ? BlockquoteIcon : schemaType.jsonType === "string" ? StringIcon : DocumentIcon;
}
function asFieldRefsByTypePath(fieldRefs) {
  return fieldRefs.reduce(
    (acc, ref) => ({ ...acc, [ref.key]: ref }),
    {}
  );
}
function getDocumentFieldRef(schemaType) {
  return {
    key: documentRootKey,
    icon: schemaType.icon ?? DocumentIcon,
    title: "The entire document",
    path: [],
    schemaType
  };
}
function getFieldRefs(schemaType, parent2, depth = 0) {
  return depth >= maxDepth ? [] : schemaType.fields.filter((f) => !f.name.startsWith("_")).flatMap((field) => {
    const path = parent2 ? [...parent2.path, field.name] : [field.name], title = field.type.title ?? field.name, fieldRef = {
      key: patchableKey(pathToString$1(path)),
      path,
      title: parent2 ? [parent2.title, title].join(" / ") : title,
      schemaType: field.type,
      icon: getTypeIcon(field.type)
    }, fields = field.type.jsonType === "object" ? getFieldRefs(field.type, fieldRef, depth + 1) : [], syntheticFields = field.type.jsonType === "array" ? getSyntheticFields(field.type, fieldRef, depth + 1) : [];
    return isAssistSupported(field.type) ? [fieldRef, ...fields, ...syntheticFields] : [...fields, ...syntheticFields];
  });
}
function getSyntheticFields(schemaType, parent2, depth = 0) {
  return depth >= maxDepth ? [] : schemaType.of.filter((itemType) => !isType(itemType, "block")).flatMap((itemType) => {
    const segment = { _key: itemType.name }, title = itemType.title ?? itemType.name, path = parent2 ? [...parent2.path, segment] : [segment], fieldRef = {
      key: patchableKey(pathToString$1(path)),
      path,
      title: parent2 ? [parent2.title, title].join(" / ") : title,
      schemaType: itemType,
      icon: getTypeIcon(itemType),
      synthetic: true
    }, fields = itemType.jsonType === "object" ? getFieldRefs(itemType, fieldRef, depth + 1) : [];
    return isAssistSupported(itemType) ? [fieldRef, ...fields] : fields;
  });
}
function getTypePath(doc, pathString) {
  if (!pathString)
    return;
  const path = stringToPath(pathString), currentPath = [];
  let valid = true;
  const syntheticPath = path.map((segment) => {
    if (currentPath.push(segment), isKeySegment(segment)) {
      const match2 = extractWithPath(pathToString$1(currentPath), doc)[0], value = match2 == null ? void 0 : match2.value;
      if (match2 && value && typeof value == "object" && "_type" in value)
        return { _key: value._type };
      valid = false;
    }
    return segment;
  });
  return valid ? patchableKey(pathToString$1(syntheticPath)) : void 0;
}
function patchableKey(pathKey) {
  return pathKey.replace(/[=]=/g, ":").replace(/[[\]]/g, "|").replace(/"/g, "");
}
function useTypePath(doc, pathString) {
  return (0, import_react.useMemo)(() => getTypePath(doc, pathString), [doc, pathString]);
}
function useSelectedField(documentSchemaType, path) {
  const { getFieldRefs: getFieldRefs2 } = useAiAssistanceConfig(), selectableFields = (0, import_react.useMemo)(
    () => documentSchemaType && isObjectSchemaType(documentSchemaType) ? [getDocumentFieldRef(documentSchemaType), ...getFieldRefs2(documentSchemaType.name)] : [],
    [documentSchemaType, getFieldRefs2]
  );
  return (0, import_react.useMemo)(() => path ? selectableFields == null ? void 0 : selectableFields.find((f) => f.key === path) : void 0, [selectableFields, path]);
}
function getFieldTitle(field) {
  const schemaType = field == null ? void 0 : field.schemaType;
  return (field == null ? void 0 : field.title) ?? (schemaType == null ? void 0 : schemaType.title) ?? (schemaType == null ? void 0 : schemaType.name) ?? "Untitled";
}
function useAiPaneRouter() {
  const paneRouter = usePaneRouter();
  return (0, import_react.useMemo)(
    () => ({ ...paneRouter, params: paneRouter.params ?? {} }),
    [paneRouter]
  );
}
function useAssistDocumentContextValue(documentId, documentType) {
  const schema = useSchema(), { getFieldRefs: getFieldRefs2, getFieldRefsByTypePath } = useAiAssistanceConfig(), documentSchemaType = (0, import_react.useMemo)(() => {
    const schemaType = schema.get(documentType);
    if (!schemaType)
      throw new Error(`Schema type "${documentType}" not found`);
    return schemaType;
  }, [documentType, schema]), { fieldRefs, fieldRefsByTypePath } = (0, import_react.useMemo)(() => ({
    fieldRefs: getFieldRefs2(documentType),
    fieldRefsByTypePath: getFieldRefsByTypePath(documentType)
  }), [getFieldRefs2, getFieldRefsByTypePath, documentType]), {
    openInspector,
    closeInspector,
    inspector,
    onChange: documentOnChange,
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore this is a valid option available in `corel` - Remove after corel is merged to next
    selectedReleaseId,
    editState
  } = useDocumentPane(), { draft, published, version } = editState || {}, assistableDocumentId = selectedReleaseId ? getVersionId(documentId, selectedReleaseId) : documentSchemaType.liveEdit ? documentId : getDraftId(documentId), documentIsNew = selectedReleaseId ? !(version == null ? void 0 : version._id) : !(draft == null ? void 0 : draft._id) && !(published == null ? void 0 : published._id), documentIsAssistable = selectedReleaseId ? !!version : isDocAssistable(documentSchemaType, published, draft), { params } = useAiPaneRouter(), selectedPath = params[fieldPathParam], assistDocument = useStudioAssistDocument({
    documentId: assistableDocumentId,
    schemaType: documentSchemaType
  }), { syntheticTasks, addSyntheticTask, removeSyntheticTask } = useSyntheticTasks(assistableDocumentId);
  return (0, import_react.useMemo)(() => {
    const base = {
      assistableDocumentId,
      documentSchemaType,
      documentIsNew,
      documentIsAssistable,
      openInspector,
      closeInspector,
      inspector,
      documentOnChange,
      selectedPath,
      syntheticTasks,
      addSyntheticTask,
      removeSyntheticTask,
      fieldRefs,
      fieldRefsByTypePath
    };
    return assistDocument ? {
      ...base,
      loading: false,
      assistDocument
    } : { ...base, loading: true, assistDocument: void 0 };
  }, [
    assistDocument,
    documentIsAssistable,
    assistableDocumentId,
    documentSchemaType,
    documentIsNew,
    openInspector,
    closeInspector,
    inspector,
    documentOnChange,
    selectedPath,
    syntheticTasks,
    addSyntheticTask,
    removeSyntheticTask,
    fieldRefs,
    fieldRefsByTypePath
  ]);
}
function useSyntheticTasks(assistableDocumentId) {
  const [syntheticTasks, setSyntheticTasks] = (0, import_react.useState)(() => []), addSyntheticTask = (0, import_react.useCallback)((task) => {
    setSyntheticTasks((current) => [...current, task]);
  }, []), removeSyntheticTask = (0, import_react.useCallback)((task) => {
    setSyntheticTasks((current) => current.filter((t) => task._key !== t._key));
  }, []);
  return (0, import_react.useEffect)(() => {
    setSyntheticTasks([]);
  }, [assistableDocumentId]), {
    syntheticTasks,
    addSyntheticTask,
    removeSyntheticTask
  };
}
function AssistDocumentContextProvider(props) {
  const { documentId, documentType } = props, value = useAssistDocumentContextValue(documentId, documentType);
  return (0, import_jsx_runtime.jsx)(AssistDocumentContext.Provider, { value, children: props.children });
}
function AssistDocumentLayout(props) {
  const { documentId, documentType } = props;
  return (0, import_jsx_runtime.jsx)(AssistDocumentContextProvider, { documentType, documentId, children: props.renderDefault(props) });
}
function AssistFeatureBadge() {
  return (0, import_jsx_runtime.jsx)(Badge, { fontSize: 0, style: { margin: "-2px 0" }, tone: "primary", children: "Beta" });
}
function AssistOnboardingPopover(props) {
  const { dismiss } = props;
  return (0, import_jsx_runtime.jsx)(
    Popover,
    {
      content: (0, import_jsx_runtime.jsx)(AssistIntroCard, { dismiss }),
      open: true,
      portal: true,
      placeholder: "bottom",
      tone: "default",
      width: 0,
      children: (0, import_jsx_runtime.jsx)(Card, { radius: 2, shadow: 2, style: { padding: 2, lineHeight: 0 }, children: (0, import_jsx_runtime.jsx)(Button, { disabled: true, fontSize: 1, icon: SparklesIcon, mode: "bleed", padding: 2 }) })
    }
  );
}
function AssistIntroCard(props) {
  const buttonRef = (0, import_react.useRef)(null);
  return (0, import_jsx_runtime.jsxs)(Stack, { as: "section", padding: 3, space: 3, children: [
    (0, import_jsx_runtime.jsxs)(Stack, { padding: 2, space: 4, children: [
      (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, align: "center", children: [
        (0, import_jsx_runtime.jsx)(Text, { as: "h1", size: 1, weight: "semibold", children: pluginTitle }),
        (0, import_jsx_runtime.jsx)("div", { "aria-hidden": true, style: { margin: "-3px 0", lineHeight: 0 }, children: (0, import_jsx_runtime.jsx)(AssistFeatureBadge, {}) })
      ] }),
      (0, import_jsx_runtime.jsx)(Stack, { space: 3, children: (0, import_jsx_runtime.jsxs)(Text, { as: "p", muted: true, size: 1, children: [
        "Manage reusable AI instructions to boost your content creation and reduce amount of repetitive chores.",
        " ",
        (0, import_jsx_runtime.jsxs)("a", { href: releaseAnnouncementUrl, target: "_blank", rel: "noreferrer", children: [
          "Learn more ",
          (0, import_jsx_runtime.jsx)(ArrowRightIcon, {})
        ] })
      ] }) })
    ] }),
    (0, import_jsx_runtime.jsx)(
      Button,
      {
        fontSize: 1,
        icon: CheckmarkIcon,
        onClick: props.dismiss,
        padding: 3,
        ref: buttonRef,
        text: "Ok, good to know!",
        tone: "primary"
      }
    )
  ] });
}
var inspectorOnboardingKey = "sanityStudio:assist:inspector:onboarding:dismissed";
var fieldOnboardingKey = "sanityStudio:assist:field:onboarding:dismissed";
function isFeatureOnboardingDismissed(featureKey) {
  return typeof localStorage > "u" ? false : localStorage.getItem(featureKey) === "true";
}
function dismissFeatureOnboarding(featureKey) {
  typeof localStorage > "u" || localStorage.setItem(featureKey, "true");
}
function useOnboardingFeature(featureKey) {
  const [showOnboarding, setShowOnboarding] = (0, import_react.useState)(
    () => !isFeatureOnboardingDismissed(featureKey)
  ), dismissOnboarding = (0, import_react.useCallback)(() => {
    setShowOnboarding(false), dismissFeatureOnboarding(featureKey);
  }, [setShowOnboarding, featureKey]);
  return { showOnboarding, dismissOnboarding };
}
var fadeIn = mt`
  0% {
    opacity: 0;
    transform: scale(0.75);
  }
  40% {
    opacity: 0;
    transform: scale(0.75);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
`;
var FadeInDiv = dt.div`
  animation-name: ${fadeIn};
  animation-timing-function: ease-in-out;
`;
var FadeInContent = (0, import_react.forwardRef)(function({
  children,
  durationMs = 250
}, ref) {
  return (0, import_jsx_runtime.jsx)(FadeInDiv, { ref, style: { animationDuration: `${durationMs}ms` }, children });
});
var purple = {
  400: {
    hex: "#b087f7"
  },
  500: {
    hex: "#8f57ef"
  },
  600: {
    hex: "#721fe5"
  }
};
var Root = dt.span`
  display: block;
  width: 25px;
  height: 25px;
  position: relative;
`;
var dash = mt`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(43deg);
  }
`;
var Outline = dt.svg`
  display: block;
  position: absolute;
  top: 0;
  left: 0;

  & > circle {
    stroke: var(--ai-avatar-stroke-color);
    stroke-width: 1.5px;
    stroke-linecap: round;
    transform-origin: center;
    animation: ${dash} 500ms ease-in-out infinite;
    transition: stroke-dasharray 200ms ease-in-out;

    stroke-dasharray: 2.34px 0;

    [data-state='active'] > & {
      stroke-dasharray: 2px 2.34px;
    }
  }
`;
var IconDisc = dt.span`
  background: var(--ai-avatar-disc-color);
  color: white;
  width: 21px;
  height: 21px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10.5px;
  position: absolute;
  top: 2px;
  left: 2px;
`;
function AssistAvatar(props) {
  const { state = "present" } = props, scheme = useColorSchemeValue(), style = (0, import_react.useMemo)(() => scheme === "dark" ? {
    "--ai-avatar-stroke-color": purple[400].hex,
    "--ai-avatar-disc-color": purple[600].hex
  } : {
    "--ai-avatar-stroke-color": purple[500].hex,
    "--ai-avatar-disc-color": purple[600].hex
  }, [scheme]);
  return (0, import_jsx_runtime.jsxs)(Root, { "data-state": state, style, children: [
    (0, import_jsx_runtime.jsx)(
      Outline,
      {
        width: "25",
        height: "25",
        viewBox: "0 0 25 25",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: (0, import_jsx_runtime.jsx)("circle", { cx: "12.5", cy: "12.5", r: "11.75" })
      }
    ),
    (0, import_jsx_runtime.jsx)(IconDisc, { children: (0, import_jsx_runtime.jsx)(Text, { as: "span", size: 0, style: { color: "inherit" }, children: (0, import_jsx_runtime.jsx)(SparklesIcon, { style: { color: "inherit" } }) }) })
  ] });
}
function AiFieldPresence(props) {
  return (0, import_jsx_runtime.jsx)(Card, { style: { position: "relative", background: "transparent" }, contentEditable: false, children: (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      placement: "left",
      content: (0, import_jsx_runtime.jsx)(Card, { padding: 3, border: true, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: "Running instruction..." }) }) }),
      children: (0, import_jsx_runtime.jsx)(FadeInContent, { durationMs: 300, children: (0, import_jsx_runtime.jsx)(AssistAvatar, { state: "active" }) })
    }
  ) });
}
var NO_PRESENCE = [];
function useAssistPresence(path, showFocusWithin) {
  var _a;
  const context = useAssistDocumentContext(), tasks = (_a = context && "assistDocument" in context ? context.assistDocument : void 0) == null ? void 0 : _a.tasks;
  return (0, import_react.useMemo)(() => {
    var _a2, _b;
    const activePresence = (_b = (_a2 = tasks == null ? void 0 : tasks.filter((task) => !task.ended)) == null ? void 0 : _a2.flatMap((task) => task.presence ?? [])) == null ? void 0 : _b.filter(
      (p) => p.started && (/* @__PURE__ */ new Date()).getTime() - new Date(p.started).getTime() < maxHistoryVisibilityMs
    ).filter((presence) => {
      if (!presence.path || !path.length)
        return false;
      const statusPath = stringToPath(presence.path);
      return !showFocusWithin && statusPath.length !== path.length ? false : path.every((pathSegment, i) => {
        const statusSegment = statusPath[i];
        return typeof pathSegment == "string" ? pathSegment === statusSegment : isKeySegment(pathSegment) && isKeySegment(statusSegment) ? pathSegment._key === statusSegment._key : false;
      });
    });
    return (activePresence == null ? void 0 : activePresence.length) ? activePresence.map((status) => aiPresence(status, path)) : NO_PRESENCE;
  }, [showFocusWithin, tasks, path]);
}
function aiPresence(presence, path, title) {
  return {
    user: {
      id: `sanity-assistant_${presence._key}`,
      displayName: pluginTitle
    },
    path,
    sessionId: "not-available",
    lastActiveAt: (presence == null ? void 0 : presence.started) ?? (/* @__PURE__ */ new Date()).toISOString()
  };
}
function AssistFieldWrapper(props) {
  const { schemaType } = props;
  return !(0, import_react.useMemo)(() => isAssistSupported(schemaType), [schemaType]) || schemaType.name.startsWith("sanity.") || schemaType.name === contextDocumentTypeName ? props.renderDefault(props) : !isType(props.schemaType, "document") && props.inputId !== "root" && props.inputId !== assistFormId ? (0, import_jsx_runtime.jsx)(AssistField, { ...props, children: props.children }) : props.renderDefault(props);
}
function AssistField(props) {
  const { path } = props, isPortableText = (0, import_react.useMemo)(
    () => !!(isArraySchemaType(props.schemaType) && isPortableTextArray(props.schemaType)),
    [props.schemaType]
  ), presence = useAssistPresence(props.path, isPortableText), firstAssistedPath = (0, import_react.useContext)(FirstAssistedPathContext), isFirstAssisted = (0, import_react.useMemo)(
    () => pathToString$1(path) === firstAssistedPath,
    [path, firstAssistedPath]
  ), { showOnboarding, dismissOnboarding } = useOnboardingFeature(fieldOnboardingKey), singlePresence = presence[0], actions = (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, align: "center", justify: "space-between", children: [
    singlePresence && (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(AiFieldPresence, { presence: singlePresence }) }),
    isFirstAssisted && showOnboarding && (0, import_jsx_runtime.jsx)(AssistOnboardingPopover, { dismiss: dismissOnboarding })
  ] });
  return props.renderDefault({
    ...props,
    // When showing the onboarding, prevent default field actions from being rendered
    actions: isFirstAssisted && showOnboarding ? [] : props.actions,
    // Render presence (and possibly onboarding) in the internal slot (between presence and the field actions)
    // eslint-disable-next-line camelcase
    __internal_slot: actions
  });
}
var WrapPreCard = dt(Card)`
  & pre {
    white-space: pre-wrap !important;
  }
`;
function SafeValueInput(props) {
  return (0, import_jsx_runtime.jsx)(ErrorWrapper, { onChange: props.onChange, children: (0, import_jsx_runtime.jsx)(PteValueFixer, { ...props }) });
}
function ErrorWrapper(props) {
  const { onChange } = props, [error, setError] = (0, import_react.useState)(), catchError2 = (0, import_react.useCallback)((params) => {
    setError(params.error);
  }, []), unsetValue = (0, import_react.useCallback)(() => {
    onChange(PatchEvent.from(unset())), setError(void 0);
  }, [onChange]), dismiss = (0, import_react.useCallback)(() => setError(void 0), []), catcher = (0, import_jsx_runtime.jsx)(ErrorBoundary, { onCatch: catchError2, children: props.children });
  return error ? (0, import_jsx_runtime.jsx)(Card, { border: true, tone: "critical", padding: 2, contentEditable: false, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [
    (0, import_jsx_runtime.jsx)(Text, { muted: true, weight: "semibold", children: "An error occurred." }),
    (0, import_jsx_runtime.jsx)(WrapPreCard, { flex: 1, padding: 2, tone: "critical", border: true, children: catcher }),
    (0, import_jsx_runtime.jsxs)(Flex, { width: "fill", flex: 1, gap: 3, children: [
      (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(Button, { text: "Dismiss", onClick: dismiss, tone: "primary" }) }),
      (0, import_jsx_runtime.jsx)(Button, { text: "Unset value", onClick: unsetValue, tone: "critical" })
    ] })
  ] }) }) : catcher;
}
function PteValueFixer(props) {
  const isPortableText = (0, import_react.useMemo)(
    () => isArraySchemaType(props.schemaType) && isPortableTextArray(props.schemaType),
    [props.schemaType]
  ), value = props.value;
  return isPortableText && value && !value.length ? props.renderDefault({ ...props, value: void 0 }) : props.renderDefault(props);
}
function AssistFormBlock(props) {
  const presence = useAssistPresence(props.path, true), { onChange } = useFormCallbacks(), key = props.value._key, localOnChange = (0, import_react.useCallback)(
    (patchEvent) => {
      key && onChange(PatchEvent.from(patchEvent).prefixAll({ _key: key }));
    },
    [onChange, key]
  ), singlePresence = presence[0];
  return (0, import_jsx_runtime.jsx)(ErrorWrapper, { onChange: localOnChange, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", justify: "space-between", children: [
    (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: props.renderDefault(props) }),
    singlePresence && (0, import_jsx_runtime.jsx)(AiFieldPresence, { presence: singlePresence })
  ] }) });
}
var InlineBlockValueContext = (0, import_react.createContext)(void 0);
function AssistInlineFormBlock(props) {
  return (0, import_jsx_runtime.jsx)(InlineBlockValueContext.Provider, { value: props.value, children: (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: props.renderDefault(props) }) });
}
function AssistItem(props) {
  const { path } = props, presence = useAssistPresence(path, true);
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "center", width: "fill", style: { position: "relative" }, children: [
    (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: props.renderDefault({ ...props }) }),
    presence.map((pre) => (0, import_jsx_runtime.jsx)(Box, { style: { position: "absolute", right: 35 }, children: (0, import_jsx_runtime.jsx)(AiFieldPresence, { presence: pre }) }, pre.user.id))
  ] });
}
var preventDefault = (ev) => ev.preventDefault();
function DocumentForm(props) {
  var _a;
  const {
    collapsedFieldSets,
    collapsedPaths,
    displayed: value,
    documentId,
    documentType,
    editState,
    formState,
    onBlur,
    onChange,
    onFocus,
    onPathOpen,
    onSetActiveFieldGroup,
    onSetCollapsedFieldSet,
    onSetCollapsedPath,
    ready,
    validation
  } = useDocumentPane(), documentStore = useDocumentStore(), presence = useDocumentPresence(documentId), patchChannel = (0, import_react.useMemo)(() => createPatchChannel(), []), isLocked = (_a = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a.enabled;
  (0, import_react.useEffect)(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(
      tap((event) => {
        event.type === "mutation" && patchChannel.publish(prepareMutationEvent(event)), event.type === "rebase" && patchChannel.publish(prepareRebaseEvent(event));
      })
    ).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = !!(value == null ? void 0 : value._rev);
  (0, import_react.useEffect)(() => {
    hasRev && patchChannel.publish({
      type: "mutation",
      patches: [],
      snapshot: value
    });
  }, [hasRev]);
  const formRef = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => {
    focusFirstDescendant(formRef.current);
  }, []), isLocked ? (0, import_jsx_runtime.jsx)(Box, { as: "form", ...props, ref: formRef, children: (0, import_jsx_runtime.jsx)(
    Flex,
    {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      padding: 3,
      sizing: "border",
      children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: "Please hold tight while the document is synced. This usually happens right after the document has been published, and it shouldnt take more than a few seconds" })
    }
  ) }) : (0, import_jsx_runtime.jsx)(Box, { as: "form", ...props, onSubmit: preventDefault, ref: formRef, children: ready ? formState === null ? (0, import_jsx_runtime.jsx)(
    Flex,
    {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      padding: 3,
      sizing: "border",
      children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: "This form is hidden" })
    }
  ) : (0, import_jsx_runtime.jsx)(
    FormBuilder,
    {
      __internal_patchChannel: patchChannel,
      collapsedFieldSets,
      collapsedPaths,
      focusPath: formState.focusPath,
      changed: formState.changed,
      focused: formState.focused,
      groups: formState.groups,
      id: assistFormId,
      members: formState.members,
      onChange,
      onFieldGroupSelect: onSetActiveFieldGroup,
      onPathBlur: onBlur,
      onPathFocus: onFocus,
      onPathOpen,
      onSetFieldSetCollapsed: onSetCollapsedFieldSet,
      onSetPathCollapsed: onSetCollapsedPath,
      presence,
      readOnly: formState.readOnly,
      schemaType: formState.schemaType,
      validation,
      value: formState.value
    }
  ) : (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      align: "center",
      direction: "column",
      height: "fill",
      justify: "center",
      padding: 3,
      sizing: "border",
      children: [
        (0, import_jsx_runtime.jsx)(Spinner, { muted: true }),
        (0, import_jsx_runtime.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, size: 1, children: "Loading document" }) })
      ]
    }
  ) });
}
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "mutation",
    snapshot: event.document,
    patches: fromMutationPatches(event.origin, patches)
  };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean), localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return {
    type: "rebase",
    snapshot: event.document,
    patches: fromMutationPatches("remote", remotePatches).concat(
      fromMutationPatches("local", localPatches)
    )
  };
}
var AssistTypeContext = (0, import_react.createContext)({});
var DEFAULT_MAX_DEPTH$1 = 8;
var ABSOLUTE_MAX_DEPTH$1 = 50;
function getConditionalMembers(docState, maxDepth2 = DEFAULT_MAX_DEPTH$1) {
  return [{
    path: "",
    hidden: false,
    readOnly: !!docState.readOnly,
    conditional: isConditional(docState.schemaType)
  }, ...extractConditionalPaths(docState, Math.min(maxDepth2, ABSOLUTE_MAX_DEPTH$1))].filter((v) => v.conditional).map(({ conditional, ...state }) => ({ ...state }));
}
function isConditional(schemaType) {
  return typeof schemaType.hidden == "function" || typeof schemaType.readOnly == "function";
}
function conditionalState(memberState) {
  return {
    path: pathToString$1(memberState.path),
    readOnly: !!memberState.readOnly,
    // Use actual form state readOnly value
    hidden: false,
    // If it's in form state members, it's not hidden
    conditional: isConditional(memberState.schemaType)
  };
}
function extractConditionalPaths(node, maxDepth2) {
  return node.path.length >= maxDepth2 ? [] : node.members.reduce((acc, member) => {
    var _a, _b;
    if (member.kind === "error")
      return acc;
    if (member.kind === "field") {
      const schemaType = member.field.schemaType;
      if (schemaType.jsonType === "object") {
        const innerFields = member.field.readOnly ? [] : extractConditionalPaths(member.field, maxDepth2);
        return [...acc, conditionalState(member.field), ...innerFields];
      } else if (schemaType.jsonType === "array") {
        const array = member.field;
        let arrayPaths = [];
        const isObjectsArray = array.members.some(
          (m) => m.kind === "item" && isObjectSchemaType(m.item.schemaType)
        );
        if (!array.readOnly)
          for (const arrayMember of array.members) {
            if (arrayMember.kind === "error")
              continue;
            const innerFields = isObjectsArray && !arrayMember.item.readOnly ? extractConditionalPaths(arrayMember.item, maxDepth2) : [];
            arrayPaths = [...arrayPaths, conditionalState(arrayMember.item), ...innerFields];
          }
        return [...acc, conditionalState(array), ...arrayPaths];
      }
      return [...acc, conditionalState(member.field)];
    } else if (member.kind === "fieldSet") {
      const conditionalFieldset = !!((_b = (_a = node.schemaType) == null ? void 0 : _a.fieldsets) == null ? void 0 : _b.some(
        (f) => !f.single && f.name === member.fieldSet.name && typeof f.hidden == "function"
      )), innerFields = extractConditionalPaths(member.fieldSet, maxDepth2).map((f) => ({
        ...f,
        // if fieldset is conditional, visible fields must also be considered conditional
        conditional: conditionalFieldset || f.conditional
      }));
      return [...acc, ...innerFields];
    }
    return acc;
  }, []);
}
var SparklesIllustration = dt(SparklesIcon)({
  fontSize: "3.125em",
  "& path": {
    strokeWidth: "0.6px !important"
  }
});
function InspectorOnboarding(props) {
  const { onDismiss } = props;
  return (0, import_jsx_runtime.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime.jsx)(Container, { width: 0, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [
    (0, import_jsx_runtime.jsx)("div", { style: { textAlign: "center" }, children: (0, import_jsx_runtime.jsx)(SparklesIllustration, {}) }),
    (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, children: "Create reusable AI instructions that can be applied across all documents of a certain type." }),
    (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, justify: "center", children: [
      (0, import_jsx_runtime.jsx)(
        Button,
        {
          as: "a",
          href: releaseAnnouncementUrl,
          rel: "noreferrer",
          target: "_blank",
          fontSize: 1,
          mode: "default",
          onClick: onDismiss,
          padding: 2,
          text: "Learn more",
          tone: "primary"
        }
      ),
      (0, import_jsx_runtime.jsx)(Button, { fontSize: 1, mode: "bleed", onClick: onDismiss, padding: 2, text: "Dismiss" })
    ] })
  ] }) }) });
}
function FieldAutocomplete(props) {
  const { id, schemaType, fieldPath, onSelect, includeDocument, filter: filter22 } = props, { getFieldRefs: getFieldRefs2 } = useAiAssistanceConfig(), fieldRefs = (0, import_react.useMemo)(() => {
    const refs = getFieldRefs2(schemaType.name);
    return includeDocument ? [getDocumentFieldRef(schemaType), ...refs] : refs;
  }, [schemaType, includeDocument, getFieldRefs2]), currentField = (0, import_react.useMemo)(
    () => fieldRefs.find((f) => f.key === fieldPath),
    [fieldPath, fieldRefs]
  ), autocompleteOptions = (0, import_react.useMemo)(
    () => fieldRefs.filter((field) => filter22 ? filter22(field) : true).filter((f) => !isType(f.schemaType, "reference")).map((field) => ({ value: field.key, field })),
    [fieldRefs, filter22]
  ), renderOption = (0, import_react.useCallback)((option) => {
    const { value, field } = option;
    return value ? isType(field.schemaType, "document") ? (0, import_jsx_runtime.jsx)(Card, { as: "button", padding: 3, radius: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: "The entire document" }) }) : (0, import_jsx_runtime.jsx)(Card, { as: "button", padding: 3, radius: 1, children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 3, children: [
      (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_react.createElement)(field.icon) }),
      (0, import_jsx_runtime.jsx)(FieldTitle, { field })
    ] }) }) : (0, import_jsx_runtime.jsx)(Card, { as: "button", padding: 3, radius: 1, children: (0, import_jsx_runtime.jsx)(Text, { accent: true, size: 1, children: option.value }) });
  }, []), renderValue = (0, import_react.useCallback)((value, option) => (option == null ? void 0 : option.field.title) ?? value, []), filterOption = (0, import_react.useCallback)((query, option) => {
    var _a, _b, _c;
    const lQuery = query.toLowerCase();
    return ((_a = option == null ? void 0 : option.value) == null ? void 0 : _a.toLowerCase().includes(lQuery)) || ((_c = (_b = option == null ? void 0 : option.field) == null ? void 0 : _b.title) == null ? void 0 : _c.toLowerCase().includes(lQuery));
  }, []);
  return (0, import_jsx_runtime.jsx)(
    Autocomplete,
    {
      fontSize: 1,
      icon: currentField ? currentField.icon : SearchIcon,
      onChange: onSelect,
      openButton: true,
      id,
      options: autocompleteOptions,
      placeholder: "Search for a field",
      radius: 2,
      renderOption,
      renderValue,
      value: currentField == null ? void 0 : currentField.key,
      filterOption
    }
  );
}
function FieldTitle(props) {
  const splitTitle = props.field.title.split("/");
  return (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsxs)(
    Breadcrumbs,
    {
      style: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        marginTop: "-4px"
      },
      separator: (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: "/" }) }),
      space: 1,
      children: [
        splitTitle.slice(0, splitTitle.length - 1).map((pt, i) => (
          // eslint-disable-next-line react/no-array-index-key
          (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: pt.trim() }) }, i)
        )),
        (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: splitTitle[splitTitle.length - 1] }) })
      ]
    }
  ) });
}
function useInterval(ms) {
  const [tick, update2] = (0, import_react.useReducer)((n) => n + 1, 0);
  return (0, import_react.useEffect)(() => {
    const i = setInterval(update2, ms);
    return () => clearInterval(i);
  }, [ms]), tick;
}
function TimeAgo({ date }) {
  useInterval(1e3);
  const timeSince = formatDistanceToNow(date ? new Date(date) : /* @__PURE__ */ new Date());
  return (0, import_jsx_runtime.jsxs)("span", { title: timeSince, children: [
    timeSince,
    " ago"
  ] });
}
var rotate = mt`
  0% {
    transform: rotate(0);
  }
  100% {
    transform: rotate(360deg);
  }
`;
var SyncSpinningIcon = dt(SyncIcon)`
  animation: ${rotate} 1s linear infinite;
`;
var TASK_CONFIG = {
  aborted: {
    title: "Canceled",
    icon: CloseCircleIcon,
    tone: "transparent"
  },
  error: {
    title: "Error",
    icon: ErrorOutlineIcon,
    tone: "critical"
  },
  success: {
    title: "Completed",
    icon: CheckmarkCircleIcon,
    tone: "positive"
  },
  timeout: {
    title: "Timeout",
    icon: ClockIcon,
    tone: "caution"
  }
};
function InstructionTaskHistoryButton(props) {
  const { tasks, instructions, documentId, showTitles } = props, client = useClient({ apiVersion: "2023-01-01" }), cancelRun = (0, import_react.useCallback)(
    (taskKey) => {
      if (!documentId)
        return;
      const statusDocId = assistTasksStatusId(documentId), basePath2 = `${typed("tasks")}[_key=="${taskKey}"]`;
      client.patch(statusDocId).set({
        [`${basePath2}.${typed("ended")}`]: (/* @__PURE__ */ new Date()).toISOString(),
        [`${basePath2}.${typed("reason")}`]: typed("aborted")
      }).commit().catch(console.error);
    },
    [client, documentId]
  ), titledTasks = (0, import_react.useMemo)(() => {
    const t = (tasks == null ? void 0 : tasks.filter(
      (task) => task.started && (/* @__PURE__ */ new Date()).getTime() - new Date(task.started).getTime() < maxHistoryVisibilityMs
    ).map((task) => {
      const instruction2 = instructions == null ? void 0 : instructions.find((i) => i._key === task.instructionKey);
      return {
        ...task,
        title: showTitles ? task.title ?? getInstructionTitle(instruction2) : void 0,
        cancel: () => cancelRun(task._key)
      };
    })) ?? [];
    return t.sort((a, b) => new Date(b.started ?? "").getTime() - new Date(a.started ?? "").getTime()), t;
  }, [tasks, instructions, cancelRun, showTitles]), isRunning = (0, import_react.useMemo)(() => titledTasks.some((r) => !r.ended), [titledTasks]), hasErrors = (0, import_react.useMemo)(
    () => titledTasks.some((r) => r.reason === "error" || r.reason === "timeout"),
    [titledTasks]
  ), [open, setOpen] = (0, import_react.useState)(false), toggleOpen = (0, import_react.useCallback)(() => setOpen((v) => !v), []), [button, setButton] = (0, import_react.useState)(null), [popover, setPopover] = (0, import_react.useState)(null), handleClickOutside = (0, import_react.useCallback)(() => {
    setOpen(false);
  }, []);
  useClickOutside(handleClickOutside, [button, popover]);
  const handleEscape = (0, import_react.useCallback)(() => {
    setOpen(false), button == null ? void 0 : button.focus();
  }, [button]);
  return (0, import_jsx_runtime.jsx)(
    Popover,
    {
      constrainSize: true,
      content: (0, import_jsx_runtime.jsx)(TaskList, { onEscape: handleEscape, tasks: titledTasks }),
      open: open && !!(titledTasks == null ? void 0 : titledTasks.length),
      placement: "top",
      portal: true,
      ref: setPopover,
      width: 0,
      children: (0, import_jsx_runtime.jsx)(
        TaskStatusButton,
        {
          disabled: !(titledTasks == null ? void 0 : titledTasks.length),
          hasErrors,
          isRunning,
          onClick: toggleOpen,
          ref: setButton,
          selected: open
        }
      )
    }
  );
}
var TASK_STATUS_BUTTON_TOOLTIP_PROPS = {
  placement: "top"
};
var TaskStatusButton = (0, import_react.forwardRef)(function(props, ref) {
  const { disabled, hasErrors, isRunning, onClick, selected } = props;
  return (0, import_jsx_runtime.jsx)(
    StatusButton,
    {
      label: `${pluginTitle} status`,
      "aria-label": `${pluginTitle} status`,
      icon: isRunning ? SyncSpinningIcon : hasErrors ? ErrorOutlineIcon : CheckmarkCircleIcon,
      mode: "bleed",
      onClick,
      tone: hasErrors ? "critical" : void 0,
      disabled,
      ref,
      selected,
      tooltipProps: TASK_STATUS_BUTTON_TOOLTIP_PROPS
    }
  );
});
function TaskList(props) {
  const { onEscape, tasks } = props, { isTopLayer } = useLayer();
  return useGlobalKeyDown(
    (0, import_react.useCallback)(
      (event) => {
        isTopLayer && event.key === "Escape" && onEscape();
      },
      [isTopLayer, onEscape]
    )
  ), (0, import_jsx_runtime.jsx)(Stack, { padding: 1, space: 1, children: tasks.map((task) => (0, import_jsx_runtime.jsx)(TaskItem, { task }, task._key)) });
}
function TaskItem(props) {
  const { task } = props, taskType = task.reason && TASK_CONFIG[task.reason];
  return (0, import_jsx_runtime.jsx)(Card, { radius: 2, tone: taskType && (taskType == null ? void 0 : taskType.tone), children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", flex: 1, gap: 3, padding: 3, children: [
      (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, children: [
        taskType && (0, import_react.createElement)(taskType.icon),
        !task.reason && (0, import_jsx_runtime.jsx)(Spinner, {})
      ] }) }),
      (0, import_jsx_runtime.jsxs)(Stack, { flex: 1, space: 2, children: [
        (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "medium", children: [
          taskType ? taskType.title : "Running",
          task.title && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
            ": ",
            task.title
          ] })
        ] }),
        task.message ? (0, import_jsx_runtime.jsx)(Text, { size: 1, children: task.message }) : null,
        (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(TimeAgo, { date: task.ended ?? task.started }) })
      ] })
    ] }),
    !task.ended && (0, import_jsx_runtime.jsx)(Box, { flex: "none", padding: 1, children: (0, import_jsx_runtime.jsx)(Button, { fontSize: 1, mode: "bleed", onClick: task.cancel, text: "Cancel" }) })
  ] }) });
}
var CardWithShadowBelow = dt(Card)`
  position: relative;

  &:after {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    bottom: -1px;
    border-bottom: 1px solid var(--card-border-color);
    opacity: 0.5;
    z-index: 100;
  }
`;
var CardWithShadowAbove = dt(Card)`
  position: relative;

  &:after {
    content: '';
    display: block;
    position: absolute;
    left: 0;
    right: 0;
    top: -1px;
    border-top: 1px solid var(--card-border-color);
    opacity: 0.5;
    z-index: 100;
  }
`;
function AssistInspectorWrapper(props) {
  const context = useAiAssistanceConfig();
  if (context.statusLoading)
    return (0, import_jsx_runtime.jsx)(Flex, { align: "center", height: "fill", justify: "center", padding: 4, sizing: "border", children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, style: { textAlign: "center" }, children: [
      (0, import_jsx_runtime.jsx)(Spinner, { muted: true }),
      (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [
        "Loading ",
        pluginTitle,
        "..."
      ] })
    ] }) });
  const status = context.status;
  return (status == null ? void 0 : status.enabled) ? !(status == null ? void 0 : status.initialized) || !status.validToken ? (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", children: [
    (0, import_jsx_runtime.jsx)(
      DocumentInspectorHeader,
      {
        closeButtonLabel: "Close",
        onClose: props.onClose,
        title: pluginTitle
      }
    ),
    (0, import_jsx_runtime.jsxs)(Stack, { padding: 4, space: 3, children: [
      context.error ? (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "semibold", children: [
        "Failed to start ",
        pluginTitle
      ] }) : null,
      !context.error && !(status == null ? void 0 : status.initialized) ? (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "semibold", children: [
        pluginTitle,
        " is not enabled"
      ] }) : null,
      !context.error && (status == null ? void 0 : status.initialized) && !status.validToken ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: "Invalid token" }),
        (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: "The token used by the AI Assistant is not valid and has to be regenerated." })
      ] }) : null,
      context.error && (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: "Something went wrong. See console for details." }),
      !context.error && !(status == null ? void 0 : status.initialized) && (0, import_jsx_runtime.jsxs)(Text, { size: 1, muted: true, children: [
        "Please enable ",
        pluginTitle,
        "."
      ] }),
      (0, import_jsx_runtime.jsx)(
        Button,
        {
          fontSize: 1,
          icon: context.initLoading ? (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(Spinner, {}) }) : context.error ? RetryIcon : void 0,
          text: context.error ? "Retry" : (status == null ? void 0 : status.initialized) && !status.validToken ? `Restore ${pluginTitle}` : `Enable ${pluginTitle} now`,
          tone: "primary",
          onClick: context.init,
          disabled: context.initLoading
        }
      )
    ] })
  ] }) : (0, import_jsx_runtime.jsx)(AssistInspector, { ...props }) : (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", children: [
    (0, import_jsx_runtime.jsx)(
      DocumentInspectorHeader,
      {
        closeButtonLabel: "Close",
        onClose: props.onClose,
        title: pluginTitle
      }
    ),
    (0, import_jsx_runtime.jsxs)(Stack, { flex: 1, overflow: "auto", padding: 4, space: 3, children: [
      (0, import_jsx_runtime.jsxs)(Text, { as: "p", size: 1, weight: "semibold", children: [
        pluginTitle,
        " is not available"
      ] }),
      (0, import_jsx_runtime.jsxs)(Text, { as: "p", muted: true, size: 1, children: [
        "Please get in touch with a Sanity account manager or",
        " ",
        (0, import_jsx_runtime.jsx)("a", { href: salesUrl, target: "_blank", rel: "noreferrer", children: "contact our sales team" }),
        " ",
        "to get started with ",
        pluginTitle,
        ".",
        " ",
        (0, import_jsx_runtime.jsx)("a", { href: releaseAnnouncementUrl, target: "_blank", rel: "noreferrer", children: "Learn more " })
      ] })
    ] })
  ] });
}
function AssistInspector(props) {
  var _a, _b, _c;
  const { params } = useAiPaneRouter(), boundary = (0, import_react.useRef)(null), pathKey = params == null ? void 0 : params[fieldPathParam], instructionKey = params == null ? void 0 : params[instructionParam], documentPane = useDocumentPane(), {
    documentId,
    documentType,
    value: docValue,
    schemaType,
    onChange: documentOnChange,
    formState
  } = documentPane, { assistableDocumentId, documentIsAssistable } = useAssistDocumentContext(), formStateRef = (0, import_react.useRef)(formState);
  formStateRef.current = formState;
  const { instructionLoading, requestRunInstruction } = useRequestRunInstruction({
    documentOnChange,
    isDocAssistable: documentIsAssistable
  }), typePath = useTypePath(docValue, pathKey ?? ""), selectedField = useSelectedField(schemaType, typePath), aiDocId = assistDocumentId(documentType), assistDocument = useStudioAssistDocument({ documentId, schemaType, initDoc: true }), instruction2 = (_c = (_b = (_a = assistDocument == null ? void 0 : assistDocument.fields) == null ? void 0 : _a.find((f) => f.path === typePath)) == null ? void 0 : _b.instructions) == null ? void 0 : _c.find((i) => i._key === instructionKey), tasks = (0, import_react.useMemo)(
    () => {
      var _a2;
      return (_a2 = assistDocument == null ? void 0 : assistDocument.tasks) == null ? void 0 : _a2.filter((i) => !instructionKey || i.instructionKey === instructionKey);
    },
    [assistDocument == null ? void 0 : assistDocument.tasks, instructionKey]
  ), instructions = (0, import_react.useMemo)(
    () => {
      var _a2;
      return (_a2 = assistDocument == null ? void 0 : assistDocument.fields) == null ? void 0 : _a2.flatMap((f) => f.instructions ?? []);
    },
    [assistDocument == null ? void 0 : assistDocument.fields]
  ), promptValue = instruction2 == null ? void 0 : instruction2.prompt, isEmptyPrompt = (0, import_react.useMemo)(() => {
    var _a2, _b2, _c2;
    if (!(promptValue == null ? void 0 : promptValue.length))
      return true;
    const children = (_a2 = promptValue[0]) == null ? void 0 : _a2.children;
    return promptValue.length == 1 && (children == null ? void 0 : children.length) === 1 && !((_c2 = (_b2 = children == null ? void 0 : children[0]) == null ? void 0 : _b2.text) == null ? void 0 : _c2.length);
  }, [promptValue]), paneNode = (0, import_react.useMemo)(
    () => ({
      type: "document",
      id: aiDocId,
      title: pluginTitle,
      options: {
        id: aiDocId,
        type: assistDocumentTypeName
      }
    }),
    [aiDocId]
  ), runCurrentInstruction = (0, import_react.useCallback)(
    () => instruction2 && pathKey && typePath && requestRunInstruction({
      documentId: assistableDocumentId,
      path: pathKey,
      typePath,
      assistDocumentId: assistDocumentId(documentType),
      instruction: instruction2,
      conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current) : []
    }),
    [pathKey, instruction2, typePath, documentType, assistableDocumentId, requestRunInstruction]
  ), Region = (0, import_react.useCallback)((_props) => (0, import_jsx_runtime.jsx)("div", { ..._props, style: { height: "100%", flex: 1, overflow: "auto" } }), []), assistTypeContext = (0, import_react.useMemo)(() => ({ typePath, documentType }), [typePath, documentType]);
  return !documentId || !schemaType || schemaType.jsonType !== "object" ? (0, import_jsx_runtime.jsx)(Card, { flex: 1, padding: 4, children: (0, import_jsx_runtime.jsx)(Text, { children: "Document not ready yet." }) }) : (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      ref: boundary,
      direction: "column",
      height: "fill",
      overflow: "hidden",
      sizing: "border",
      style: { lineHeight: 0 },
      children: [
        (0, import_jsx_runtime.jsx)(
          AiInspectorHeader,
          {
            onClose: props.onClose,
            field: selectedField,
            fieldTitle: getFieldTitle(selectedField)
          }
        ),
        (0, import_jsx_runtime.jsx)(Card, { as: Region, flex: 1, overflow: "auto", children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", style: { minHeight: "100%" }, children: [
          (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(PresenceOverlay, { children: (0, import_jsx_runtime.jsx)(Box, { padding: 4, children: selectedField && (0, import_jsx_runtime.jsx)(AssistTypeContext.Provider, { value: assistTypeContext, children: (0, import_jsx_runtime.jsx)(
            VirtualizerScrollInstanceProvider,
            {
              scrollElement: boundary.current,
              containerElement: boundary,
              children: (0, import_jsx_runtime.jsx)(
                DocumentPaneProviderWrapper,
                {
                  paneKey: documentPane.paneKey,
                  index: documentPane.index,
                  itemId: "ai",
                  pane: paneNode,
                  forcedVersion: {
                    isReleaseLocked: false,
                    selectedPerspectiveName: "published",
                    selectedReleaseId: void 0
                  },
                  children: (0, import_jsx_runtime.jsx)(DocumentForm, {})
                }
              )
            }
          ) }) }) }) }),
          (0, import_jsx_runtime.jsx)(Box, { flex: "none", padding: 4, children: (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [
            "How is Sanity AI Assist working for you?",
            " ",
            (0, import_jsx_runtime.jsxs)(
              "a",
              {
                href: giveFeedbackUrl,
                target: "_blank",
                rel: "noreferrer",
                style: { whiteSpace: "nowrap" },
                children: [
                  "Let us know ",
                  (0, import_jsx_runtime.jsx)(ArrowRightIcon, {})
                ]
              }
            )
          ] }) })
        ] }) }),
        (0, import_jsx_runtime.jsx)(CardWithShadowAbove, { flex: "none", paddingX: 4, paddingY: 3, style: { justifySelf: "flex-end" }, children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, flex: 1, justify: "flex-end", children: [
          (schemaType == null ? void 0 : schemaType.name) && pathKey && instructionKey && (0, import_jsx_runtime.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime.jsx)(
            Button,
            {
              mode: "ghost",
              disabled: isEmptyPrompt || instructionLoading,
              fontSize: 1,
              icon: instructionLoading ? (0, import_jsx_runtime.jsx)(Spinner, { style: { marginTop: 3 } }) : PlayIcon,
              onClick: runCurrentInstruction,
              padding: 3,
              text: "Run instruction"
            }
          ) }),
          (0, import_jsx_runtime.jsx)(
            InstructionTaskHistoryButton,
            {
              documentId: assistableDocumentId,
              tasks,
              instructions,
              showTitles: !instructionKey
            }
          )
        ] }) })
      ]
    }
  );
}
function AiInspectorHeader(props) {
  const { onClose, field, fieldTitle } = props, { showOnboarding, dismissOnboarding } = useOnboardingFeature(inspectorOnboardingKey);
  return (0, import_jsx_runtime.jsxs)(CardWithShadowBelow, { flex: "none", padding: 2, children: [
    (0, import_jsx_runtime.jsxs)(Flex, { flex: 1, align: "center", children: [
      (0, import_jsx_runtime.jsx)(Flex, { flex: 1, padding: 3, gap: 2, align: "center", children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", wrap: "wrap", style: { marginTop: "-4px" }, children: [
        (0, import_jsx_runtime.jsx)(Box, { marginTop: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: "AI instructions for" }) }),
        (0, import_jsx_runtime.jsx)(Card, { radius: 2, border: true, padding: 1, marginTop: 1, children: field ? (0, import_jsx_runtime.jsx)(FieldTitle, { field }) : (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: fieldTitle }) })
      ] }) }),
      (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Button, { fontSize: 1, icon: CloseIcon, mode: "bleed", onClick: onClose }) })
    ] }),
    showOnboarding && (0, import_jsx_runtime.jsx)(InspectorOnboarding, { onDismiss: dismissOnboarding })
  ] });
}
var aiInspectorId = "ai-assistance";
var assistInspector = {
  name: aiInspectorId,
  useMenuItem: () => ({
    icon: SparklesIcon,
    title: pluginTitle,
    hidden: true,
    showAsAction: false
  }),
  component: AssistInspectorWrapper,
  onClose({ params }) {
    return {
      params: typed({
        ...params,
        [fieldPathParam]: void 0,
        [instructionParam]: void 0
      })
    };
  }
};
function arrowPath(options2, x, y, dir) {
  return [
    `M ${x - options2.arrow.size} ${y - options2.arrow.size * dir} `,
    `L ${x} ${y}`,
    `L ${x + options2.arrow.size} ${y - options2.arrow.size * dir}`
  ].join("");
}
function moveTo(x, y) {
  return `M${x} ${y}`;
}
function lineTo(x, y) {
  return `L${x} ${y}`;
}
function join2(strings, delim = "") {
  return strings.join(delim);
}
function quadCurve(x1, y1, x, y) {
  return `Q${x1} ${y1} ${x} ${y}`;
}
function drawConnectorPath(options2, line) {
  const { cornerRadius } = options2.path, { from, to } = line, { x: fromX, y: fromY } = from, { x: _toX, y: toY } = to, toX = _toX - 1, dividerX = to.bounds.x + options2.divider.offsetX, fromPathX = from.isAbove || from.isBelow ? fromX + options2.arrow.marginX : fromX, r0 = Math.min(cornerRadius, Math.abs(fromPathX - dividerX) / 2), r1 = Math.min(cornerRadius, Math.abs(fromY - toY) / 2), cmds = [];
  return from.isAbove ? cmds.push(
    moveTo(
      fromX + options2.arrow.marginX,
      fromY - options2.arrow.threshold + options2.arrow.marginY
    ),
    lineTo(fromX + options2.arrow.marginX, fromY - r0),
    quadCurve(fromX + options2.arrow.marginX, fromY, fromX + options2.arrow.marginX + r0, fromY)
  ) : from.isBelow ? cmds.push(
    moveTo(
      fromX + options2.arrow.marginX,
      fromY + options2.arrow.threshold - options2.arrow.marginY
    ),
    lineTo(fromX + options2.arrow.marginX, fromY + r0),
    quadCurve(fromX + options2.arrow.marginX, fromY, fromX + options2.arrow.marginX + r0, fromY)
  ) : cmds.push(moveTo(fromX, fromY)), to.isAbove ? fromY < to.bounds.y ? cmds.push(
    lineTo(dividerX - r1, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY + r1),
    lineTo(dividerX, toY - r1),
    quadCurve(dividerX, toY, dividerX + r1, toY),
    lineTo(dividerX - cornerRadius, toY),
    quadCurve(dividerX, toY, dividerX, toY - cornerRadius),
    lineTo(dividerX, toY - options2.arrow.threshold + options2.arrow.marginY)
  ) : cmds.push(
    lineTo(dividerX - cornerRadius, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY - cornerRadius),
    lineTo(dividerX, toY - options2.arrow.threshold + options2.arrow.marginY)
  ) : to.isBelow ? fromY > to.bounds.y + to.bounds.h ? cmds.push(
    lineTo(dividerX - options2.arrow.marginX - r1, fromY),
    quadCurve(
      dividerX - options2.arrow.marginX,
      fromY,
      dividerX - options2.arrow.marginX,
      fromY - r1
    ),
    lineTo(dividerX - options2.arrow.marginX, toY + r1),
    quadCurve(
      dividerX - options2.arrow.marginX,
      toY,
      dividerX - options2.arrow.marginX + r1,
      toY
    ),
    lineTo(dividerX - cornerRadius, toY),
    quadCurve(dividerX, toY, dividerX, toY + cornerRadius),
    lineTo(dividerX, toY + options2.arrow.threshold - options2.arrow.marginY)
  ) : cmds.push(
    lineTo(dividerX - cornerRadius, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY + cornerRadius),
    lineTo(dividerX, toY + options2.arrow.threshold - options2.arrow.marginY)
  ) : fromY < toY ? cmds.push(
    lineTo(dividerX - r0, fromY),
    quadCurve(dividerX, fromY, dividerX, fromY + r1),
    lineTo(dividerX, toY - r1),
    quadCurve(dividerX, toY, dividerX + r1, toY),
    lineTo(toX, toY)
  ) : cmds.push(
    lineTo(dividerX - Math.min(r0, r1), fromY),
    quadCurve(dividerX, fromY, dividerX, fromY - Math.min(r0, r1)),
    lineTo(dividerX, toY + r1),
    quadCurve(dividerX, toY, dividerX + r1, toY),
    lineTo(toX, toY)
  ), join2(cmds);
}
function ConnectorPath(props) {
  const { from, options: options2, to } = props, { strokeWidth } = options2.path, theme = useTheme(), line = (0, import_react.useMemo)(() => mapConnectorToLine(options2, { from, to }), [from, options2, to]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: drawConnectorPath(options2, line),
        stroke: theme.sanity.color.base.bg,
        strokeWidth: strokeWidth + 4
      }
    ),
    (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: drawConnectorPath(options2, line),
        stroke: rgba(theme.sanity.color.base.border, 0.5),
        strokeWidth
      }
    ),
    line.from.isAbove && (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: arrowPath(
          options2,
          line.from.x + options2.arrow.marginX,
          line.from.bounds.y - options2.arrow.threshold + options2.arrow.marginY,
          -1
        ),
        stroke: theme.sanity.color.base.border,
        strokeWidth
      }
    ),
    line.from.isBelow && (0, import_jsx_runtime.jsx)(
      "path",
      {
        d: arrowPath(
          options2,
          line.from.x + options2.arrow.marginX,
          line.from.bounds.y + line.from.bounds.h + options2.arrow.threshold - options2.arrow.marginY,
          1
        ),
        stroke: theme.sanity.color.base.border,
        strokeWidth
      }
    )
  ] });
}
var DEBUG = false;
var options = {
  arrow: {
    marginX: 10.5,
    marginY: 5,
    size: 4,
    threshold: 16.5
  },
  divider: {
    offsetX: -10.5
  },
  path: {
    cornerRadius: 3,
    marginY: 10.5,
    strokeWidth: 1
  }
};
function AssistConnectorsOverlay(props) {
  const { connectors } = props, [, setRedraw] = (0, import_react.useState)(false);
  return (0, import_react.useEffect)(() => {
    setRedraw(true);
  }, []), (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsx)(
      "svg",
      {
        fill: "none",
        width: window.innerWidth,
        height: window.innerHeight,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          zIndex: 150
          // zIndex,
        },
        children: connectors.map((connector) => (0, import_jsx_runtime.jsx)(
          ConnectorPath,
          {
            from: connector.from,
            options,
            to: connector.to
          },
          connector.key
        ))
      }
    ),
    DEBUG
  ] });
}
function validateStyleguide(styleguide) {
  if (styleguide && styleguide.length > 2e3)
    throw new Error(
      `[${packageName}]: \`translate.styleguide\` value is too long. It must be 2000 characters or less, but was ${styleguide.length} characters`
    );
  return styleguide;
}
function createStyleGuideResolver(styleguide, context) {
  return async () => {
    if (typeof styleguide != "function")
      return styleguide;
    const styleguideResult = await styleguide(context);
    return validateStyleguide(styleguideResult);
  };
}
var getLanguageParams = (select, document2) => {
  if (!select || !document2)
    return {};
  const selection = select || {}, selectedValue = {};
  for (const [key, path] of Object.entries(selection)) {
    let value = get_default(document2, path);
    Array.isArray(value) && (value = value.filter(
      (item) => typeof item == "object" ? (item == null ? void 0 : item._type) !== "reference" || "_ref" in item : true
    )), selectedValue[key] = value;
  }
  return selectedValue;
};
var toFieldLanguagesKeyPrefix = "sanityStudio:assist:field-languages:from:";
function getPreferredToFieldLanguages(fromLanguageId) {
  if (typeof localStorage > "u")
    return [];
  const value = localStorage.getItem(`${toFieldLanguagesKeyPrefix}${fromLanguageId}`);
  return value ? JSON.parse(value) : [];
}
function setPreferredToFieldLanguages(fromLanguageId, languageIds) {
  typeof localStorage > "u" || localStorage.setItem(`${toFieldLanguagesKeyPrefix}${fromLanguageId}`, JSON.stringify(languageIds));
}
var DEFAULT_MAX_DEPTH = 6;
var ABSOLUTE_MAX_DEPTH = 50;
function getDocumentMembersFlat(doc, schemaType, maxDepth2 = DEFAULT_MAX_DEPTH) {
  return isDocumentSchemaType(schemaType) ? extractPaths(doc, schemaType, [], Math.min(maxDepth2, ABSOLUTE_MAX_DEPTH)) : (console.error("Schema type is not a document"), []);
}
function extractPaths(doc, schemaType, path, maxDepth2) {
  return path.length >= maxDepth2 ? [] : schemaType.fields.reduce((acc, field) => {
    const fieldPath = [...path, field.name], fieldSchema = field.type, { value } = extractWithPath(pathToString$1(fieldPath), doc)[0] ?? {};
    if (!value)
      return acc;
    const thisFieldWithPath = {
      path: fieldPath,
      name: field.name,
      schemaType: fieldSchema,
      value
    };
    if (fieldSchema.jsonType === "object") {
      const innerFields = extractPaths(doc, fieldSchema, fieldPath, maxDepth2);
      return [...acc, thisFieldWithPath, ...innerFields];
    } else if (fieldSchema.jsonType === "array" && fieldSchema.of.length && fieldSchema.of.some((item) => "fields" in item) && // no reason to drill into arrays if the item fields will be culled by maxDepth, ie we need 1 extra path headroom
    path.length + 1 < maxDepth2) {
      const { value: arrayValue } = extractWithPath(pathToString$1(fieldPath), doc)[0] ?? {};
      let arrayPaths = [];
      if (arrayValue == null ? void 0 : arrayValue.length)
        for (const item of arrayValue) {
          const itemPath = [...fieldPath, { _key: item._key }];
          let itemSchema = fieldSchema.of.find((t) => t.name === item._type);
          if (item._type || (itemSchema = fieldSchema.of[0], console.warn(
            "Array item is missing _type - using the first defined type in the array.of schema",
            {
              itemPath,
              item,
              itemSchema
            }
          )), item._key && itemSchema) {
            const innerFields = extractPaths(
              doc,
              itemSchema,
              itemPath,
              maxDepth2
            ), arrayMember = {
              path: itemPath,
              name: item._key,
              schemaType: itemSchema,
              value: item
            };
            arrayPaths = [...arrayPaths, arrayMember, ...innerFields];
          }
        }
      return [...acc, thisFieldWithPath, ...arrayPaths];
    }
    return [...acc, thisFieldWithPath];
  }, []);
}
var defaultLanguageOutputs = function(member, enclosingType, translateFromLanguageId, translateToLanguageIds) {
  if (member.schemaType.jsonType === "object" && member.schemaType.name.startsWith("internationalizedArray")) {
    const pathEnd = member.path.slice(-1);
    return (isKeySegment(pathEnd[0]) ? pathEnd[0]._key : null) === translateFromLanguageId ? translateToLanguageIds.map((translateToId) => ({
      id: translateToId,
      outputPath: [...member.path.slice(0, -1), { _key: translateToId }]
    })) : void 0;
  }
  if (enclosingType.jsonType === "object" && enclosingType.name.startsWith("locale"))
    return translateFromLanguageId === member.name ? translateToLanguageIds.map((translateToId) => ({
      id: translateToId,
      outputPath: [...member.path.slice(0, -1), translateToId]
    })) : void 0;
};
function getFieldLanguageMap(documentSchema, documentMembers, translateFromLanguageId, outputLanguageIds, langFn) {
  var _a, _b;
  const translationMaps = [];
  for (const member of documentMembers) {
    const parentPath = member.path.slice(0, -1), enclosingType = ((_a = documentMembers.find((m) => pathToString$1(m.path) === pathToString$1(parentPath))) == null ? void 0 : _a.schemaType) ?? documentSchema, translations = (_b = langFn(
      member,
      enclosingType,
      translateFromLanguageId,
      outputLanguageIds
    )) == null ? void 0 : _b.filter((translation) => translation.id !== translateFromLanguageId);
    translations && translationMaps.push({
      inputLanguageId: translateFromLanguageId,
      inputPath: member.path,
      outputs: translations
    });
  }
  return translationMaps;
}
var FieldTranslationContext = (0, import_react.createContext)({
  openFieldTranslation: () => {
  },
  translationLoading: false
});
function useFieldTranslation() {
  return (0, import_react.useContext)(FieldTranslationContext);
}
function hasValuesToTranslate(fieldLanguageMaps, fromLanguage, basePath2) {
  return fieldLanguageMaps == null ? void 0 : fieldLanguageMaps.some(
    (map2) => map2.inputLanguageId === (fromLanguage == null ? void 0 : fromLanguage.id) && map2.inputPath && pathToString$1(map2.inputPath).startsWith(pathToString$1(basePath2))
  );
}
function FieldTranslationProvider(props) {
  var _a, _b, _c;
  const { config: assistConfig } = useAiAssistanceConfig(), apiClient = useApiClient(assistConfig.__customApiClient), styleguide = (_a = assistConfig.translate) == null ? void 0 : _a.styleguide, config = (_b = assistConfig.translate) == null ? void 0 : _b.field, { translate: runTranslate } = useTranslate(apiClient), [dialogOpen, setDialogOpen] = (0, import_react.useState)(false), [fieldTranslationParams, setFieldTranslationParams] = (0, import_react.useState)(), [languages, setLanguages] = (0, import_react.useState)(), [fromLanguage, setFromLanguage] = (0, import_react.useState)(void 0), [toLanguages, setToLanguages] = (0, import_react.useState)(void 0), [fieldLanguageMaps, setFieldLanguageMaps] = (0, import_react.useState)(), close = (0, import_react.useCallback)(() => {
    setDialogOpen(false), setLanguages(void 0), setFieldTranslationParams(void 0);
  }, []), languageClient = useClient({
    apiVersion: (config == null ? void 0 : config.apiVersion) ?? API_VERSION_WITH_EXTENDED_TYPES
  }), documentId = (_c = fieldTranslationParams == null ? void 0 : fieldTranslationParams.document) == null ? void 0 : _c._id, id = (0, import_react.useId)(), selectFromLanguage = (0, import_react.useCallback)(
    (from, languages2, params) => {
      const { document: document2, documentSchema } = params ?? {};
      if (setFromLanguage(from), !document2 || !documentSchema || !params || !languages2) {
        setFieldLanguageMaps(void 0);
        return;
      }
      const preferred = getPreferredToFieldLanguages(from.id), allToLanguages = languages2.filter((l) => l.id !== (from == null ? void 0 : from.id)), filteredToLanguages = allToLanguages.filter(
        (l) => !preferred.length || preferred.includes(l.id)
      );
      setToLanguages(filteredToLanguages);
      const fromId = from == null ? void 0 : from.id, allToIds = (allToLanguages == null ? void 0 : allToLanguages.map((l) => l.id)) ?? [], docMembers = getDocumentMembersFlat(document2, documentSchema, config == null ? void 0 : config.maxPathDepth);
      if (fromId && (allToIds == null ? void 0 : allToIds.length)) {
        const transMap = getFieldLanguageMap(
          documentSchema,
          docMembers,
          fromId,
          allToIds.filter((toId) => fromId !== toId),
          (config == null ? void 0 : config.translationOutputs) ?? defaultLanguageOutputs
        );
        setFieldLanguageMaps(transMap);
      } else
        setFieldLanguageMaps(void 0);
    },
    [config]
  ), toggleToLanguage = (0, import_react.useCallback)(
    (toggledLang, toLanguages2, languages2) => {
      if (!languages2 || !fromLanguage)
        return;
      const wasSelected = !!(toLanguages2 == null ? void 0 : toLanguages2.find((l) => l.id === toggledLang.id)), newToLangs = languages2.filter(
        (anyLang) => !!(toLanguages2 == null ? void 0 : toLanguages2.find(
          (selectedLang) => toggledLang.id !== selectedLang.id && selectedLang.id === anyLang.id
        )) || toggledLang.id === anyLang.id && !wasSelected
      );
      setToLanguages(newToLangs), setPreferredToFieldLanguages(
        fromLanguage.id,
        newToLangs.map((l) => l.id)
      );
    },
    [fromLanguage]
  ), openFieldTranslation = (0, import_react.useCallback)(
    async (params) => {
      setDialogOpen(true);
      const languageParams = getLanguageParams(config == null ? void 0 : config.selectLanguageParams, params.document), languages2 = await (typeof (config == null ? void 0 : config.languages) == "function" ? config == null ? void 0 : config.languages(languageClient, languageParams) : Promise.resolve(config == null ? void 0 : config.languages));
      setLanguages(languages2), setFieldTranslationParams(params);
      const fromLanguage2 = languages2 == null ? void 0 : languages2[0];
      fromLanguage2 ? selectFromLanguage(fromLanguage2, languages2, params) : console.error("No languages available for selected language params", languageParams);
    },
    [selectFromLanguage, config, languageClient]
  ), contextValue = (0, import_react.useMemo)(() => ({
    openFieldTranslation,
    translationLoading: false
  }), [openFieldTranslation]), runDisabled = !fromLanguage || !(toLanguages == null ? void 0 : toLanguages.length) || !(fieldLanguageMaps == null ? void 0 : fieldLanguageMaps.length) || !documentId || !hasValuesToTranslate(fieldLanguageMaps, fromLanguage, fieldTranslationParams.translatePath), onRunTranslation = (0, import_react.useCallback)(() => {
    const translatePath = fieldTranslationParams == null ? void 0 : fieldTranslationParams.translatePath;
    fieldLanguageMaps && documentId && translatePath && runTranslate({
      documentId,
      translatePath,
      styleguide: createStyleGuideResolver(styleguide, {
        client: languageClient,
        documentId,
        schemaType: fieldTranslationParams == null ? void 0 : fieldTranslationParams.documentSchema,
        translatePath
      }),
      fieldLanguageMap: fieldLanguageMaps.map((map2) => ({
        ...map2,
        // eslint-disable-next-line max-nested-callbacks
        outputs: map2.outputs.filter((out) => !!(toLanguages == null ? void 0 : toLanguages.find((l) => l.id === out.id)))
      })),
      conditionalMembers: fieldTranslationParams == null ? void 0 : fieldTranslationParams.conditionalMembers
    }), close();
  }, [
    fieldLanguageMaps,
    documentId,
    runTranslate,
    styleguide,
    close,
    toLanguages,
    fieldTranslationParams == null ? void 0 : fieldTranslationParams.translatePath,
    fieldTranslationParams == null ? void 0 : fieldTranslationParams.conditionalMembers,
    fieldTranslationParams == null ? void 0 : fieldTranslationParams.documentSchema,
    languageClient
  ]), runButton = (0, import_jsx_runtime.jsx)(
    Button,
    {
      text: "Translate",
      tone: "primary",
      icon: PlayIcon,
      style: { width: "100%" },
      disabled: runDisabled,
      onClick: onRunTranslation
    }
  );
  return (0, import_jsx_runtime.jsxs)(FieldTranslationContext.Provider, { value: contextValue, children: [
    dialogOpen ? (0, import_jsx_runtime.jsx)(
      Dialog,
      {
        id,
        width: 1,
        open: dialogOpen,
        onClose: close,
        header: "Translate fields",
        footer: (0, import_jsx_runtime.jsx)(Flex, { justify: "space-between", padding: 2, flex: 1, children: runDisabled ? (0, import_jsx_runtime.jsx)(
          Tooltip,
          {
            content: (0, import_jsx_runtime.jsx)(Flex, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { children: "There is nothing to translate in the selected from-language." }) }),
            placement: "top",
            children: (0, import_jsx_runtime.jsx)(Flex, { flex: 1, children: runButton })
          }
        ) : runButton }),
        children: languages ? (0, import_jsx_runtime.jsxs)(Flex, { padding: 4, gap: 5, align: "flex-start", justify: "center", children: [
          (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
            (0, import_jsx_runtime.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime.jsx)(Text, { weight: "semibold", children: "From" }) }),
            languages == null ? void 0 : languages.map((radioLanguage) => (0, import_jsx_runtime.jsx)(
              FromLanguageRadio,
              {
                radioLanguage,
                fromLanguage,
                selectFromLanguage,
                languages,
                fieldTranslationParams
              },
              radioLanguage.id
            ))
          ] }),
          (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
            (0, import_jsx_runtime.jsx)(Box, { marginBottom: 2, children: (0, import_jsx_runtime.jsx)(Text, { weight: "semibold", children: "To" }) }),
            languages.map((checkboxLanguage) => (0, import_jsx_runtime.jsx)(
              ToLanguageCheckbox,
              {
                checkboxLanguage,
                fromLanguage,
                toLanguages,
                toggleToLanguage,
                languages
              },
              checkboxLanguage.id
            ))
          ] })
        ] }) : (0, import_jsx_runtime.jsxs)(Flex, { padding: 4, gap: 2, align: "flex-start", justify: "center", children: [
          (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Spinner, {}) }),
          (0, import_jsx_runtime.jsx)(Text, { children: "Loading languages..." })
        ] })
      }
    ) : null,
    props.children
  ] });
}
function ToLanguageCheckbox(props) {
  const { checkboxLanguage, fromLanguage, toLanguages, toggleToLanguage, languages } = props, langId = checkboxLanguage.id, onChange = (0, import_react.useCallback)(
    () => toggleToLanguage(checkboxLanguage, toLanguages, languages),
    [toggleToLanguage, checkboxLanguage, toLanguages, languages]
  );
  return (0, import_jsx_runtime.jsxs)(
    Flex,
    {
      gap: 3,
      align: "center",
      as: "label",
      style: langId === (fromLanguage == null ? void 0 : fromLanguage.id) ? { opacity: 0.5 } : void 0,
      children: [
        (0, import_jsx_runtime.jsx)(
          Checkbox,
          {
            name: "toLang",
            value: langId,
            checked: langId !== (fromLanguage == null ? void 0 : fromLanguage.id) && !!(toLanguages == null ? void 0 : toLanguages.find((tl) => tl.id === langId)),
            onChange,
            disabled: langId === (fromLanguage == null ? void 0 : fromLanguage.id)
          }
        ),
        (0, import_jsx_runtime.jsx)(Text, { muted: langId === (fromLanguage == null ? void 0 : fromLanguage.id), children: checkboxLanguage.title ?? langId })
      ]
    },
    langId
  );
}
function FromLanguageRadio(props) {
  const { languages, radioLanguage, selectFromLanguage, fromLanguage, fieldTranslationParams } = props, langId = radioLanguage.id, onChange = (0, import_react.useCallback)(
    () => selectFromLanguage(radioLanguage, languages, fieldTranslationParams),
    [selectFromLanguage, radioLanguage, languages, fieldTranslationParams]
  );
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 3, align: "center", as: "label", children: [
    (0, import_jsx_runtime.jsx)(
      Radio,
      {
        name: "fromLang",
        value: langId,
        checked: langId === (fromLanguage == null ? void 0 : fromLanguage.id),
        onChange
      }
    ),
    (0, import_jsx_runtime.jsx)(Text, { children: radioLanguage.title ?? radioLanguage.id })
  ] }, langId);
}
var hiddenTypes = [
  "any",
  "array",
  "block",
  "boolean",
  "crossDatasetReference",
  "date",
  "datetime",
  "document",
  "email",
  "file",
  "globalDocumentReference",
  "image",
  "number",
  "object",
  "reference",
  "span",
  "string",
  "text",
  "url",
  "slug",
  "geopoint",
  "sanity.assetSourceData",
  "sanity.imageAsset",
  "sanity.fileAsset",
  "sanity.imageCrop",
  "sanity.imageHotspot",
  "sanity.imageMetadata",
  "sanity.imageDimensions",
  "sanity.imagePalette",
  "sanity.imagePaletteSwatch",
  assistSerializedTypeName,
  assistSerializedFieldTypeName,
  "sanity-agent.job.document"
];
var inlineTypes = ["document", "object", "image", "file"];
function serializeSchema(schema, options2) {
  const list = schema.getTypeNames().filter((t) => !(hiddenTypes.includes(t) || t.startsWith("sanity."))).map((t) => schema.get(t)).filter((t) => !!t).map((t) => getSchemaStub(t, schema, options2)).filter((t) => !("to" in t && t.to && !t.to.length || "of" in t && t.of && !t.of.length || "fields" in t && t.fields && !t.fields.length));
  return list.sort((a, b) => ((a == null ? void 0 : a.name) ?? "").localeCompare((b == null ? void 0 : b.name) ?? "")), list;
}
function getSchemaStub(schemaType, schema, options2) {
  var _a;
  if (!((_a = schemaType.type) == null ? void 0 : _a.name))
    throw console.error("Missing type name", schemaType.type), new Error("Type is missing name!");
  const baseSchema = {
    // we dont need type or id when we send using POST, so leave these out to save bandwidth
    ...(options2 == null ? void 0 : options2.leanFormat) ? {} : { _id: `${assistSchemaIdPrefix}${schemaType.name}`, _type: assistSerializedTypeName },
    name: schemaType.name,
    title: schemaType.title,
    type: schemaType.type.name,
    ...getBaseFields(schema, schemaType, schemaType.type.name, options2)
  };
  return removeUndef(baseSchema);
}
function getBaseFields(schema, type, typeName, options2) {
  var _a, _b, _c, _d, _e, _f;
  const schemaOptions = removeUndef({
    imagePromptField: (_b = (_a = type.options) == null ? void 0 : _a.aiAssist) == null ? void 0 : _b.imageInstructionField,
    embeddingsIndex: (_d = (_c = type.options) == null ? void 0 : _c.aiAssist) == null ? void 0 : _d.embeddingsIndex
  });
  return removeUndef({
    options: Object.keys(schemaOptions).length ? schemaOptions : void 0,
    values: Array.isArray((_e = type == null ? void 0 : type.options) == null ? void 0 : _e.list) ? (_f = type == null ? void 0 : type.options) == null ? void 0 : _f.list.map(
      (v) => typeof v == "string" ? v : v.value ?? `${v.title}`
    ) : void 0,
    of: "of" in type && typeName === "array" ? arrayOf(type, schema, options2) : void 0,
    to: "to" in type && typeName === "reference" ? refToTypeNames(type) : void 0,
    fields: "fields" in type && inlineTypes.includes(typeName) ? serializeFields(schema, type, options2) : void 0,
    annotations: typeName === "block" && "fields" in type ? serializeAnnotations(type, schema, options2) : void 0,
    inlineOf: typeName === "block" && "fields" in type ? serializeInlineOf(type, schema, options2) : void 0,
    hidden: typeof type.hidden == "function" ? "function" : type.hidden ? true : void 0,
    readOnly: typeof type.readOnly == "function" ? "function" : type.readOnly ? true : void 0
  });
}
function serializeFields(schema, schemaType, options2) {
  return (schemaType.fieldsets ? schemaType.fieldsets.flatMap(
    (fs) => fs.single ? fs.field : fs.fields.map((f) => ({
      ...f,
      type: {
        ...f.type,
        // if fieldset is (conditionally) hidden, the field must be considered the same way
        // ie, if the field does not show up in conditionalMembers, it is hidden
        // regardless of weather or not it is the field function or the fieldset function that hides it
        hidden: typeof fs.hidden == "function" ? fs.hidden : fs.hidden ? true : f.type.hidden
      }
    }))
  ) : schemaType.fields).filter((f) => {
    var _a;
    return !["sanity.imageHotspot", "sanity.imageCrop"].includes(((_a = f.type) == null ? void 0 : _a.name) ?? "");
  }).filter((f) => isAssistSupported(f.type)).map((field) => serializeMember(schema, field.type, field.name, options2));
}
function serializeMember(schema, type, name, options2) {
  var _a;
  const typeName = schema.get(type == null ? void 0 : type.name) ? type.name : ((_a = type.type) == null ? void 0 : _a.name) ?? "";
  return removeUndef({
    ...(options2 == null ? void 0 : options2.leanFormat) ? {} : { _type: assistSerializedFieldTypeName },
    name,
    type: typeName,
    title: type.title,
    ...getBaseFields(schema, type, typeName, options2)
  });
}
function serializeInlineOf(blockSchemaType, schema, options2) {
  var _a;
  const childrenType = (_a = blockSchemaType.fields.find((f) => f.name === "children")) == null ? void 0 : _a.type;
  if (!(!childrenType || !isArraySchemaType(childrenType)))
    return arrayOf(
      {
        of: childrenType.of.filter((t) => !isType(t, "span"))
      },
      schema,
      options2
    );
}
function serializeAnnotations(blockSchemaType, schema, options2) {
  var _a;
  const marksType = (_a = blockSchemaType.fields.find((f) => f.name === "markDefs")) == null ? void 0 : _a.type;
  if (!(!marksType || !isArraySchemaType(marksType)))
    return arrayOf(marksType, schema, options2);
}
function arrayOf(arrayType, schema, options2) {
  return arrayType.of.filter((type) => isAssistSupported(type)).map((t) => serializeMember(schema, t, t.name, options2));
}
function refToTypeNames(type) {
  return type.to.map((t) => ({
    type: typed(t.name)
  }));
}
function removeUndef(obj) {
  return Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {}), obj;
}
function createFieldRefCache() {
  const byType = {};
  function getRefsForType(schemaType) {
    const documentType = schemaType.name, cached = byType[documentType];
    if (cached) return cached;
    const fieldRefs = getFieldRefs(schemaType), fieldRefsByTypePath = asFieldRefsByTypePath(fieldRefs), refs = {
      fieldRefs,
      fieldRefsByTypePath
    };
    return byType[documentType] = refs, refs;
  }
  return getRefsForType;
}
function AiAssistanceConfigProvider(props) {
  var _a;
  const [status, setStatus] = (0, import_react.useState)(), [error, setError] = (0, import_react.useState)(), apiClient = useApiClient((_a = props.config) == null ? void 0 : _a.__customApiClient), { getInstructStatus, loading: statusLoading } = useGetInstructStatus(apiClient), { initInstruct, loading: initLoading } = useInitInstruct(apiClient), schema = useSchema(), serializedTypes = (0, import_react.useMemo)(() => serializeSchema(schema, { leanFormat: true }), [schema]), { getFieldRefs: getFieldRefs2, getFieldRefsByTypePath } = useFieldRefGetters(schema);
  (0, import_react.useEffect)(() => {
    getInstructStatus().then((s) => setStatus(s)).catch((e) => {
      console.error(e), setError(e);
    });
  }, [getInstructStatus]);
  const init = (0, import_react.useCallback)(async () => {
    setError(void 0);
    try {
      await initInstruct();
      const status2 = await getInstructStatus();
      setStatus(status2);
    } catch (e) {
      console.error("Failed to init ai assistance", e), setError(e);
    }
  }, [initInstruct, getInstructStatus, setStatus]), { config, children } = props, context = (0, import_react.useMemo)(() => ({
    config,
    status,
    statusLoading,
    init,
    initLoading,
    error,
    serializedTypes,
    getFieldRefs: getFieldRefs2,
    getFieldRefsByTypePath
  }), [
    config,
    status,
    init,
    statusLoading,
    initLoading,
    error,
    serializedTypes,
    getFieldRefs2,
    getFieldRefsByTypePath
  ]);
  return (0, import_jsx_runtime.jsx)(AiAssistanceConfigContext.Provider, { value: context, children });
}
function useFieldRefGetters(schema) {
  return (0, import_react.useMemo)(() => {
    const getForSchemaType = createFieldRefCache();
    function getRefsForType(documentType) {
      const schemaType = schema.get(documentType);
      if (!schemaType)
        throw new Error(`Schema type "${documentType}" not found`);
      return getForSchemaType(schemaType);
    }
    return {
      getFieldRefs: (documentType) => getRefsForType(documentType).fieldRefs,
      getFieldRefsByTypePath: (documentType) => getRefsForType(documentType).fieldRefsByTypePath
    };
  }, [schema]);
}
function AssistLayout(props) {
  const [connectors, setConnectors] = (0, import_react.useState)([]);
  return (0, import_jsx_runtime.jsx)(AiAssistanceConfigProvider, { config: props.config, children: (0, import_jsx_runtime.jsx)(RunInstructionProvider, { children: (0, import_jsx_runtime.jsx)(FieldTranslationProvider, { children: (0, import_jsx_runtime.jsxs)(ConnectorsProvider, { onConnectorsChange: setConnectors, children: [
    props.renderDefault(props),
    (0, import_jsx_runtime.jsx)(ThemeProvider, { tone: "default", children: (0, import_jsx_runtime.jsx)(AssistConnectorsOverlay, { connectors }) })
  ] }) }) }) });
}
var ImageContext = (0, import_react.createContext)({});
function ImageContextProvider(props) {
  var _a, _b;
  const { schemaType, path, value, readOnly } = props, assetRef = (_a = value == null ? void 0 : value.asset) == null ? void 0 : _a._ref, { selectedReleaseId } = useDocumentPane(), [assetRefState, setAssetRefState] = (0, import_react.useState)(assetRef), { assistableDocumentId, documentSchemaType } = useAssistDocumentContext(), { config, status } = useAiAssistanceConfig(), apiClient = useApiClient(config == null ? void 0 : config.__customApiClient), { generateCaption } = useGenerateCaption(apiClient), { isSyncing } = useSyncState(
    getPublishedId(assistableDocumentId),
    documentSchemaType.name,
    selectedReleaseId
  ), isShowingOlderRevision = !!((_b = usePaneRouter().params) == null ? void 0 : _b.rev);
  (0, import_react.useEffect)(() => {
    const descriptionField = getDescriptionFieldOption(schemaType);
    assetRef && assistableDocumentId && (descriptionField == null ? void 0 : descriptionField.updateOnImageChange) && assetRef !== assetRefState && !isSyncing && !isShowingOlderRevision && !readOnly && (setAssetRefState(assetRef), canUseAssist(status) && generateCaption({
      path: pathToString$1([...path, descriptionField.path]),
      documentId: assistableDocumentId
    }));
  }, [
    schemaType,
    path,
    assetRef,
    assetRefState,
    assistableDocumentId,
    generateCaption,
    isSyncing,
    status,
    readOnly,
    isShowingOlderRevision
  ]);
  const context = (0, import_react.useMemo)(() => {
    const descriptionField = getDescriptionFieldOption(schemaType), imageInstructionField = getImageInstructionFieldOption(schemaType);
    return {
      imageDescriptionPath: (descriptionField == null ? void 0 : descriptionField.path) ? pathToString$1([...path, descriptionField.path]) : void 0,
      imageInstructionPath: imageInstructionField ? pathToString$1([...path, imageInstructionField]) : void 0,
      assetRef
    };
  }, [schemaType, path, assetRef]);
  return (0, import_jsx_runtime.jsx)(ImageContext.Provider, { value: context, children: props.renderDefault(props) });
}
function IconInput(props) {
  const { value, onChange } = props, id = (0, import_react.useId)(), items = (0, import_react.useMemo)(
    () => Object.entries(icons).map(([key, icon]) => (0, import_jsx_runtime.jsx)(IconItem, { iconKey: key, icon, onChange }, key)),
    [onChange]
  ), selectedIcon = (0, import_react.useMemo)(() => getIcon(value), [value]);
  return (0, import_jsx_runtime.jsx)(
    MenuButton,
    {
      button: (0, import_jsx_runtime.jsx)(Button, { icon: selectedIcon, title: "Select icon", padding: 3, mode: "ghost", radius: 1 }),
      id,
      menu: (0, import_jsx_runtime.jsx)(Menu, { style: { maxHeight: 300 }, children: items }),
      popover: { portal: true }
    }
  );
}
function IconItem({
  icon,
  iconKey: key,
  onChange
}) {
  const onClick = (0, import_react.useCallback)(() => onChange(set(key)), [onChange, key]);
  return (0, import_jsx_runtime.jsx)(MenuItem, { icon, title: key, text: key, onClick });
}
function getIcon(iconName) {
  var _a;
  return ((_a = Object.entries(icons).find(([key]) => key === iconName)) == null ? void 0 : _a[1]) ?? icons.sparkles;
}
function useAssistSupported(path, schemaType) {
  return (0, import_react.useMemo)(() => isAssistSupported(schemaType), [schemaType]);
}
var translateActions = {
  name: "sanity-assist-translate",
  useAction(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    const { config, status } = useAiAssistanceConfig(), apiClient = useApiClient(config == null ? void 0 : config.__customApiClient), client = useClient({ apiVersion: API_VERSION_WITH_EXTENDED_TYPES }), {
      schemaType: fieldSchemaType,
      path,
      documentId,
      documentSchemaType,
      documentIsAssistable
    } = props, isDocumentLevel = path.length === 0, readOnly = fieldSchemaType.readOnly === true, docTransTypes = (_b = (_a = config.translate) == null ? void 0 : _a.document) == null ? void 0 : _b.documentTypes, options2 = fieldSchemaType == null ? void 0 : fieldSchemaType.options, addFieldAction = isDocumentLevel || ((_c = options2 == null ? void 0 : options2.aiAssist) == null ? void 0 : _c.translateAction), fieldTransEnabled = addFieldAction && documentSchemaType && ((_f = (_e = (_d = config.translate) == null ? void 0 : _d.field) == null ? void 0 : _e.documentTypes) == null ? void 0 : _f.includes(documentSchemaType.name)), documentTranslationEnabled = addFieldAction && documentSchemaType && (!docTransTypes && isAssistSupported(fieldSchemaType) || (docTransTypes == null ? void 0 : docTransTypes.includes(documentSchemaType.name)));
    if (documentSchemaType && (documentTranslationEnabled || fieldTransEnabled)) {
      const { value: documentValue, onChange: documentOnChange, formState } = useDocumentPane(), docRef = (0, import_react.useRef)(documentValue);
      docRef.current = documentValue;
      const formStateRef = (0, import_react.useRef)(formState);
      formStateRef.current = formState;
      const translationApi = useTranslate(apiClient), translate = useDraftDelayedTask({
        documentOnChange,
        isDocAssistable: documentIsAssistable ?? false,
        task: translationApi.translate
      }), styleguide = (_g = config.translate) == null ? void 0 : _g.styleguide, languagePath = (_i = (_h = config.translate) == null ? void 0 : _h.document) == null ? void 0 : _i.languageField, translateDocumentAction = (0, import_react.useMemo)(() => {
        if (!languagePath || !documentTranslationEnabled)
          return;
        const title = path.length ? "Translate" : "Translate document";
        return {
          type: "action",
          icon: translationApi.loading ? () => (0, import_jsx_runtime.jsx)(Box, { style: { height: 17 }, children: (0, import_jsx_runtime.jsx)(Spinner, { style: { transform: "translateY(6px)" } }) }) : TranslateIcon,
          title,
          onAction: () => {
            translationApi.loading || !languagePath || !documentId || translate({
              languagePath,
              translatePath: path,
              styleguide: createStyleGuideResolver(styleguide, {
                client,
                documentId,
                schemaType: documentSchemaType
              }),
              documentId: documentId ?? "",
              conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current) : []
            });
          },
          renderAsButton: true,
          disabled: translationApi.loading || readOnly
        };
      }, [
        languagePath,
        translate,
        styleguide,
        documentId,
        translationApi.loading,
        documentTranslationEnabled,
        path,
        readOnly,
        client,
        documentSchemaType
      ]), fieldTranslate = useFieldTranslation(), openFieldTranslation = useDraftDelayedTask({
        documentOnChange,
        isDocAssistable: documentIsAssistable ?? false,
        task: fieldTranslate.openFieldTranslation
      }), maxDepth2 = (_k = (_j = config.translate) == null ? void 0 : _j.field) == null ? void 0 : _k.maxPathDepth, translateFieldsAction = (0, import_react.useMemo)(
        () => fieldTransEnabled ? {
          type: "action",
          icon: fieldTranslate.translationLoading ? () => (0, import_jsx_runtime.jsx)(Box, { style: { height: 17 }, children: (0, import_jsx_runtime.jsx)(Spinner, { style: { transform: "translateY(6px)" } }) }) : TranslateIcon,
          title: "Translate fields...",
          onAction: () => {
            fieldTranslate.translationLoading || !documentId || (formStateRef.current && getConditionalMembers(formStateRef.current), openFieldTranslation({
              document: {
                ...docRef.current,
                _id: documentId
              },
              documentSchema: documentSchemaType,
              translatePath: path,
              conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current, maxDepth2) : []
            }));
          },
          renderAsButton: true,
          disabled: fieldTranslate.translationLoading || readOnly
        } : void 0,
        [
          openFieldTranslation,
          documentSchemaType,
          documentId,
          fieldTranslate.translationLoading,
          fieldTransEnabled,
          path,
          readOnly,
          maxDepth2
        ]
      );
      return (0, import_react.useMemo)(() => {
        if (status == null ? void 0 : status.initialized)
          return {
            type: "group",
            icon: () => null,
            title: "Translation",
            children: [translateDocumentAction, translateFieldsAction].filter(
              (c) => !!c
            ),
            expanded: true
          };
      }, [translateDocumentAction, translateFieldsAction, status]);
    }
  }
};
var generateCaptionsActions = {
  name: "sanity-assist-generate-captions",
  useAction(props) {
    const pathKey = usePathKey(props.path), { openInspector } = useDocumentPane(), { config, status } = useAiAssistanceConfig(), apiClient = useApiClient(config == null ? void 0 : config.__customApiClient), { generateCaption, loading } = useGenerateCaption(apiClient), imageContext = (0, import_react.useContext)(ImageContext);
    if (imageContext && pathKey === (imageContext == null ? void 0 : imageContext.imageDescriptionPath)) {
      const { assistableDocumentId } = useAssistDocumentContext();
      return (0, import_react.useMemo)(() => ({
        type: "action",
        icon: loading ? () => (0, import_jsx_runtime.jsx)(Box, { style: { height: 17 }, children: (0, import_jsx_runtime.jsx)(Spinner, { style: { transform: "translateY(6px)" } }) }) : ImageIcon,
        title: "Generate image description",
        onAction: () => {
          if (!loading) {
            if (!canUseAssist(status)) {
              openInspector(aiInspectorId, {
                [fieldPathParam]: pathKey,
                [instructionParam]: void 0
              });
              return;
            }
            generateCaption({ path: pathKey, documentId: assistableDocumentId });
          }
        },
        renderAsButton: true,
        disabled: loading,
        hidden: !imageContext.assetRef
      }), [
        generateCaption,
        pathKey,
        assistableDocumentId,
        loading,
        imageContext,
        status,
        openInspector
      ]);
    }
  }
};
var generateImagActions = {
  name: "sanity-assist-generate-image",
  useAction(props) {
    const pathKey = usePathKey(props.path), { config } = useAiAssistanceConfig(), apiClient = useApiClient(config == null ? void 0 : config.__customApiClient), { generateImage, loading } = useGenerateImage(apiClient), imageContext = (0, import_react.useContext)(ImageContext);
    if (imageContext && pathKey === (imageContext == null ? void 0 : imageContext.imageInstructionPath)) {
      const { assistableDocumentId } = useAssistDocumentContext();
      return (0, import_react.useMemo)(() => ({
        type: "action",
        icon: loading ? () => (0, import_jsx_runtime.jsx)(Box, { style: { height: 17 }, children: (0, import_jsx_runtime.jsx)(Spinner, { style: { transform: "translateY(6px)" } }) }) : ImageIcon,
        title: "Generate image from prompt",
        onAction: () => {
          loading || generateImage({ path: pathKey, documentId: assistableDocumentId });
        },
        renderAsButton: true,
        disabled: loading
      }), [generateImage, pathKey, assistableDocumentId, loading]);
    }
  }
};
function PrivateIcon() {
  return (0, import_jsx_runtime.jsx)(
    Tooltip,
    {
      content: (0, import_jsx_runtime.jsx)(Text, { size: 1, style: { whiteSpace: "nowrap" }, children: "Only visible to you" }),
      fallbackPlacements: ["bottom"],
      padding: 2,
      placement: "top",
      portal: true,
      children: (0, import_jsx_runtime.jsx)(LockIcon, {})
    }
  );
}
function getRandomValues(typedArray) {
  const crypto = typeof window < "u" && "crypto" in window ? window.crypto : globalThis.crypto;
  if (!crypto || !crypto.getRandomValues)
    throw new Error("WebCrypto not available in this environment");
  return crypto.getRandomValues(typedArray);
}
function whatwgRNG(length = 16) {
  const rnds8 = new Uint8Array(length);
  return getRandomValues(rnds8), rnds8;
}
var getByteHexTable = /* @__PURE__ */ (() => {
  let table;
  return () => {
    if (table)
      return table;
    table = [];
    for (let i = 0; i < 256; ++i)
      table[i] = (i + 256).toString(16).substring(1);
    return table;
  };
})();
function randomKey(length) {
  const table = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table[n], "").slice(0, length);
}
function defineAssistFieldAction(action) {
  return {
    ...action,
    type: "action"
  };
}
function defineFieldActionDivider() {
  return {
    type: "divider"
  };
}
function defineAssistFieldActionGroup(group) {
  return {
    ...group,
    type: "group"
  };
}
function useCustomFieldActions(props) {
  var _a;
  const {
    config: { fieldActions }
  } = useAiAssistanceConfig(), { addSyntheticTask, removeSyntheticTask } = useAssistDocumentContext(), schemaId = useWorkspaceSchemaId(), { push: pushToast } = useToast(), configActions = (_a = fieldActions == null ? void 0 : fieldActions.useFieldActions) == null ? void 0 : _a.call(fieldActions, {
    ...props,
    schemaId,
    path: props.path
  });
  return (0, import_react.useMemo)(() => {
    const title = fieldActions == null ? void 0 : fieldActions.title, customActions = configActions == null ? void 0 : configActions.filter(isDefined).map((node) => createSafeNode({
      node,
      pushToast,
      addSyntheticTask,
      removeSyntheticTask
    })).filter(isDefined), onlyGroups = (customActions == null ? void 0 : customActions.length) && (customActions == null ? void 0 : customActions.every((node) => node.type === "group"));
    return ((customActions == null ? void 0 : customActions.length) ? onlyGroups ? customActions : [
      {
        type: "group",
        title: title || "Custom actions",
        children: customActions,
        expanded: true
      }
    ] : []) ?? [];
  }, [configActions, fieldActions, pushToast]);
}
function createSafeNode(args) {
  var _a;
  const { node } = args;
  switch (node.type) {
    case "action":
      return createSafeAction({ ...args, action: node });
    case "group":
      const children = (_a = node.children) == null ? void 0 : _a.filter(isDefined).map((child) => createSafeNode({ ...args, node: child })).filter(isDefined);
      return (children == null ? void 0 : children.length) ? {
        ...node,
        renderAsButton: false,
        expanded: true,
        children
      } : void 0;
    case "divider":
    default:
      return node;
  }
}
function createSafeAction(args) {
  const { action, pushToast, addSyntheticTask, removeSyntheticTask } = args;
  return {
    ...action,
    onAction: () => {
      async function runAction() {
        var _a;
        const task = {
          _type: instructionTaskTypeName,
          _key: randomKey(12),
          started: (/* @__PURE__ */ new Date()).toISOString(),
          presence: [
            {
              _type: fieldPresenceTypeName,
              _key: randomKey(12),
              path: documentRootKey,
              started: (/* @__PURE__ */ new Date()).toISOString()
            }
          ]
        };
        try {
          addSyntheticTask(task);
          const actionResult = (_a = action.onAction) == null ? void 0 : _a.call(action);
          actionResult instanceof Promise && await actionResult;
        } catch (err) {
          console.error("Failed to execute action", action, err), pushToast({
            title: "Failed to execute action",
            description: err == null ? void 0 : err.message,
            status: "error"
          });
        } finally {
          removeSyntheticTask(task);
        }
      }
      runAction();
    },
    renderAsButton: false,
    selected: false
  };
}
var assistFieldActions = {
  name: "sanity-assist-actions",
  useAction(props) {
    const { schemaType } = props, {
      assistDocument,
      documentIsNew,
      documentIsAssistable,
      openInspector,
      closeInspector,
      inspector,
      documentOnChange,
      documentSchemaType,
      selectedPath,
      assistableDocumentId,
      fieldRefsByTypePath
    } = useAssistDocumentContext(), { value: docValue, formState } = useDocumentPane(), docValueRef = (0, import_react.useRef)(docValue), formStateRef = (0, import_react.useRef)(formState);
    formStateRef.current = formState;
    const currentUser = useCurrentUser(), isHidden = !assistDocument, pathKey = usePathKey(props.path), typePath = useTypePath(docValue, pathKey), assistDocumentId2 = assistDocument == null ? void 0 : assistDocument._id, { requestRunInstruction } = useRequestRunInstruction({
      documentOnChange,
      isDocAssistable: documentIsAssistable ?? false
    }), isSelectable = !!useSelectedField(documentSchemaType, typePath), assistSupported = useAssistSupported(props.path, schemaType) && isSelectable && isSchemaAssistEnabled(documentSchemaType) && schemaType.readOnly !== true, fieldAssist = (0, import_react.useMemo)(
      () => ((assistDocument == null ? void 0 : assistDocument.fields) ?? []).find(
        (f) => f.path === typePath || pathKey === documentRootKey && f.path === pathKey
      ),
      [assistDocument == null ? void 0 : assistDocument.fields, pathKey, typePath]
    ), fieldAssistKey = fieldAssist == null ? void 0 : fieldAssist._key, isSelected = (inspector == null ? void 0 : inspector.name) === aiInspectorId && pathKey === selectedPath, imageCaptionAction = generateCaptionsActions.useAction(props), imageGenAction = generateImagActions.useAction(props), translateAction = translateActions.useAction(
      typed({
        ...props,
        documentId: assistableDocumentId,
        documentIsAssistable,
        documentSchemaType
      })
    ), manageInstructions = (0, import_react.useCallback)(
      () => isSelected ? closeInspector(aiInspectorId) : openInspector(aiInspectorId, {
        [fieldPathParam]: pathKey,
        [instructionParam]: void 0
      }),
      [openInspector, closeInspector, isSelected, pathKey]
    ), onInstructionAction = (0, import_react.useCallback)(
      (instruction2) => {
        !pathKey || !fieldAssistKey || !assistDocumentId2 || !assistableDocumentId || requestRunInstruction({
          documentId: assistableDocumentId,
          assistDocumentId: assistDocumentId2,
          path: pathKey,
          typePath,
          instruction: instruction2,
          conditionalMembers: formStateRef.current ? getConditionalMembers(formStateRef.current) : []
        });
      },
      [
        requestRunInstruction,
        assistableDocumentId,
        pathKey,
        typePath,
        assistDocumentId2,
        fieldAssistKey
      ]
    ), privateInstructions = (0, import_react.useMemo)(
      () => {
        var _a;
        return ((_a = fieldAssist == null ? void 0 : fieldAssist.instructions) == null ? void 0 : _a.filter((i) => i.userId && i.userId === (currentUser == null ? void 0 : currentUser.id))) || [];
      },
      [fieldAssist == null ? void 0 : fieldAssist.instructions, currentUser]
    ), sharedInstructions = (0, import_react.useMemo)(
      () => {
        var _a;
        return ((_a = fieldAssist == null ? void 0 : fieldAssist.instructions) == null ? void 0 : _a.filter((i) => !i.userId)) || [];
      },
      [fieldAssist == null ? void 0 : fieldAssist.instructions]
    ), instructions = (0, import_react.useMemo)(
      () => [...privateInstructions, ...sharedInstructions],
      [privateInstructions, sharedInstructions]
    ), runInstructionsGroup = (0, import_react.useMemo)(() => (instructions == null ? void 0 : instructions.length) || imageCaptionAction || translateAction || imageGenAction ? {
      type: "group",
      icon: () => null,
      title: "Run instructions",
      children: [
        ...(instructions == null ? void 0 : instructions.map(
          (instruction2) => instructionItem({
            instruction: instruction2,
            isPrivate: !!(instruction2.userId && instruction2.userId === (currentUser == null ? void 0 : currentUser.id)),
            onInstructionAction,
            hidden: isHidden,
            assistSupported
          })
        )) || [],
        imageCaptionAction,
        imageGenAction
      ].filter((a) => !!a),
      expanded: true
    } : void 0, [
      instructions,
      currentUser == null ? void 0 : currentUser.id,
      onInstructionAction,
      isHidden,
      documentIsNew,
      assistSupported,
      imageCaptionAction,
      translateAction,
      imageGenAction
    ]), getDocumentValue = (0, import_react.useCallback)(() => docValueRef.current, []), getConditionalPaths = (0, import_react.useCallback)(() => (formStateRef.current ? getConditionalMembers(formStateRef.current) : []).flatMap(
      (cm) => {
        const path = stringToPath(cm.path);
        return path.some((s) => typeof s == "number") ? [] : {
          ...cm,
          path
        };
      }
    ), []), parentSchemaType = (0, import_react.useMemo)(() => {
      var _a;
      if (props.path.length) {
        if (props.path.length === 1)
          return documentSchemaType;
      } else return;
      const parentPath = props.path.slice(0, -1), typePath2 = getTypePath(docValueRef.current, pathToString$1(parentPath));
      return typePath2 ? (_a = fieldRefsByTypePath[typePath2]) == null ? void 0 : _a.schemaType : void 0;
    }, [fieldRefsByTypePath, props.path, documentSchemaType]), customActions = useCustomFieldActions({
      actionType: props.path.length ? "field" : "document",
      documentIdForAction: assistableDocumentId,
      schemaType,
      documentSchemaType,
      path: props.path,
      getDocumentValue,
      getConditionalPaths,
      parentSchemaType
    }), manageInstructionsItem = (0, import_react.useMemo)(
      () => ({
        type: "action",
        icon: ControlsIcon,
        title: "Manage instructions",
        onAction: manageInstructions,
        selected: isSelected
      }),
      [manageInstructions, isSelected]
    ), group = (0, import_react.useMemo)(
      () => ({
        type: "group",
        icon: SparklesIcon,
        title: pluginTitleShort,
        children: [
          runInstructionsGroup,
          translateAction,
          ...customActions,
          assistSupported && manageInstructionsItem
        ].filter((c) => !!c).filter((c) => c.type === "group" ? c.children.length : true),
        expanded: false,
        renderAsButton: true,
        hidden: !assistSupported && !imageCaptionAction && !translateAction && !imageGenAction
      }),
      [
        //documentIsNew,
        runInstructionsGroup,
        manageInstructionsItem,
        assistSupported,
        imageCaptionAction,
        translateAction,
        imageGenAction,
        customActions
      ]
    ), emptyAction = (0, import_react.useMemo)(
      () => ({
        type: "action",
        hidden: !assistSupported,
        icon: SparklesIcon,
        onAction: manageInstructions,
        renderAsButton: true,
        title: pluginTitleShort,
        selected: isSelected
      }),
      [assistSupported, manageInstructions, isSelected]
    );
    return !(instructions == null ? void 0 : instructions.length) && !imageCaptionAction && !translateAction && !imageGenAction && !customActions.length ? emptyAction : group;
  }
};
function instructionItem(props) {
  const { hidden, isPrivate, onInstructionAction, assistSupported, instruction: instruction2 } = props;
  return {
    type: "action",
    icon: getIcon(instruction2.icon),
    iconRight: isPrivate ? PrivateIcon : void 0,
    title: getInstructionTitle(instruction2),
    onAction: () => onInstructionAction(instruction2),
    disabled: !assistSupported,
    hidden
  };
}
function createAssistDocumentPresence(documentId) {
  return function() {
    return documentId ? (0, import_jsx_runtime.jsx)(AssistDocumentPresence, {}) : null;
  };
}
function AssistDocumentPresence() {
  const { assistDocument, syntheticTasks } = useAssistDocumentContext(), anyPresence = (0, import_react.useMemo)(() => {
    var _a, _b, _c;
    const anyPresence2 = (_a = [...(assistDocument == null ? void 0 : assistDocument.tasks) ?? [], ...syntheticTasks ?? []].filter((run) => !run.ended && !run.reason)) == null ? void 0 : _a.flatMap((run) => run.presence ?? []).find((f) => f.started && (/* @__PURE__ */ new Date()).getTime() - new Date(f.started).getTime() < 3e4);
    if (anyPresence2)
      return aiPresence(anyPresence2, []);
    const anyRun = (_c = (_b = assistDocument == null ? void 0 : assistDocument.tasks) == null ? void 0 : _b.filter((run) => !run.ended && !run.reason)) == null ? void 0 : _c.find((f) => f.started && (/* @__PURE__ */ new Date()).getTime() - new Date(f.started).getTime() < 3e4);
    return anyRun ? aiPresence(
      {
        started: anyRun.started,
        _key: anyRun._key
      },
      []
    ) : void 0;
  }, [assistDocument == null ? void 0 : assistDocument.tasks, syntheticTasks]);
  return (0, import_jsx_runtime.jsx)(Card, { children: (0, import_jsx_runtime.jsx)(Flex, { flex: 1, justify: "flex-end", children: (0, import_jsx_runtime.jsx)(Flex, { gap: 2, align: "center", children: anyPresence && (0, import_jsx_runtime.jsx)(AiFieldPresence, { presence: anyPresence }) }) }) });
}
function BackToInstructionListLink() {
  const { openInspector } = useDocumentPane(), goBack = (0, import_react.useCallback)(
    () => openInspector(aiInspectorId, { [instructionParam]: void 0 }),
    [openInspector]
  );
  return (0, import_jsx_runtime.jsx)("div", { children: (0, import_jsx_runtime.jsx)(
    Button,
    {
      as: "a",
      fontSize: 1,
      icon: ArrowLeftIcon,
      mode: "bleed",
      padding: 1,
      space: 2,
      onClick: goBack,
      text: "  Instructions",
      textAlign: "left"
    }
  ) });
}
var SelectedFieldContext = (0, import_react.createContext)(void 0);
var SelectedFieldContextProvider = SelectedFieldContext.Provider;
var EMPTY_FIELDS = [];
function AssistDocumentForm(props) {
  return props.readOnly ? (0, import_jsx_runtime.jsx)(Card, { border: true, tone: "caution", padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: " You do not have sufficient permissions to manage instructions." }) }) : (0, import_jsx_runtime.jsx)(AssistDocumentFormEditable, { ...props });
}
function AssistDocumentFormEditable(props) {
  const { onChange } = props, value = props.value, id = value == null ? void 0 : value._id, fields = value == null ? void 0 : value.fields, { params, setParams } = useAiPaneRouter(), pathKey = params[fieldPathParam], { typePath, documentType: targetDocumentType } = (0, import_react.useContext)(AssistTypeContext), instruction2 = params[instructionParam], activeKey = (0, import_react.useMemo)(() => {
    var _a;
    if (typePath)
      return (_a = (fields ?? EMPTY_FIELDS).find((f) => f.path === typePath)) == null ? void 0 : _a._key;
  }, [fields, typePath]), activePath = (0, import_react.useMemo)(() => {
    if (!activeKey)
      return;
    const base = ["fields", { _key: activeKey }];
    return instruction2 ? [...base, "instructions", { _key: instruction2 }] : base;
  }, [activeKey, instruction2]), schema = useSchema(), documentSchema = (0, import_react.useMemo)(() => {
    if (targetDocumentType)
      return schema.get(targetDocumentType);
  }, [schema, targetDocumentType]), fieldSchema = useSelectedSchema(pathKey, documentSchema), context = (0, import_react.useMemo)(
    () => ({
      documentSchema,
      fieldSchema: fieldSchema ?? documentSchema
    }),
    [fieldSchema, documentSchema]
  ), title = value == null ? void 0 : value.title;
  (0, import_react.useEffect)(() => {
    !title && documentSchema && !(id == null ? void 0 : id.startsWith("drafts.")) && onChange(set(documentSchema.title ?? documentSchema.name, ["title"]));
  }, [title, documentSchema, onChange, id]);
  const { onPathOpen, ...formCallbacks } = useFormCallbacks(), newCallbacks = (0, import_react.useMemo)(
    () => ({
      ...formCallbacks,
      onPathOpen: (path) => {
        var _a;
        !instruction2 && path.length === 4 && path[2] === "instructions" ? (setParams(
          typed({
            ...params,
            [instructionParam]: (_a = path[3]) == null ? void 0 : _a._key
          })
        ), onPathOpen([])) : setTimeout(() => onPathOpen(path), 0);
      }
    }),
    [formCallbacks, onPathOpen, params, setParams, instruction2]
  );
  (0, import_react.useEffect)(() => {
    activePath && !instruction2 && onPathOpen([]);
  }, [activePath, instruction2, onPathOpen]);
  const fieldError = (0, import_react.useMemo)(() => {
    const fieldError2 = props.members.find(
      (m) => m.kind === "error" && m.fieldName === "fields"
    );
    if (fieldError2)
      return (0, import_jsx_runtime.jsx)(MemberFieldError, { member: fieldError2 });
  }, [props.members]);
  return (0, import_jsx_runtime.jsx)(SelectedFieldContextProvider, { value: context, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 5, children: [
    (0, import_jsx_runtime.jsx)(
      FieldsInitializer,
      {
        pathKey: typePath,
        activePath,
        fields,
        documentSchema,
        onChange
      },
      typePath
    ),
    instruction2 && (0, import_jsx_runtime.jsx)(BackToInstructionListLink, {}),
    activePath && !fieldError && (0, import_jsx_runtime.jsx)(FormCallbacksProvider, { ...newCallbacks, children: (0, import_jsx_runtime.jsx)("div", { style: { lineHeight: "1.25em" }, children: (0, import_jsx_runtime.jsx)(FormInput, { ...props, absolutePath: activePath }) }) }),
    fieldError,
    !activePath && props.renderDefault(props)
  ] }) });
}
function useSelectedSchema(fieldPath, documentSchema) {
  return (0, import_react.useMemo)(() => {
    if (!fieldPath)
      return;
    if (fieldPath === documentRootKey)
      return documentSchema;
    const path = stringToPath(fieldPath);
    let currentSchema = documentSchema;
    for (let i = 0; i < path.length; i++) {
      const segment = path[i], field = currentSchema == null ? void 0 : currentSchema.fields.find((f) => f.name === segment);
      if (!field)
        return;
      if (i === path.length - 1)
        return field.type;
      if (field.type.jsonType !== "object")
        return;
      currentSchema = field.type;
    }
    return currentSchema;
  }, [documentSchema, fieldPath]);
}
function FieldsInitializer({
  pathKey,
  activePath,
  fields,
  documentSchema,
  onChange
}) {
  const {
    config: { __presets: presets }
  } = useAiAssistanceConfig(), existingField = fields == null ? void 0 : fields.find((f) => f._key === pathKey), documentPresets = !!(documentSchema == null ? void 0 : documentSchema.name) && (presets == null ? void 0 : presets[documentSchema == null ? void 0 : documentSchema.name]), missingPresetInstructions = (0, import_react.useMemo)(() => {
    var _a, _b, _c;
    if (!documentPresets || !pathKey)
      return;
    const existingInstructions = existingField == null ? void 0 : existingField.instructions;
    return (_c = (_b = (_a = documentPresets.fields) == null ? void 0 : _a.find((f) => f.path === pathKey)) == null ? void 0 : _b.instructions) == null ? void 0 : _c.filter(
      (i) => !(existingInstructions == null ? void 0 : existingInstructions.some((ei) => ei._key === i._key))
    );
  }, [documentPresets, pathKey, existingField]), initialized = (0, import_react.useRef)(false);
  return (0, import_react.useEffect)(() => {
    var _a;
    if (initialized.current || !pathKey || existingField && !(missingPresetInstructions == null ? void 0 : missingPresetInstructions.length))
      return;
    let event = PatchEvent.from([setIfMissing([], ["fields"])]);
    existingField || (event = event.append(
      insert$1(
        [
          typed({
            _key: pathKey,
            _type: assistFieldTypeName,
            path: pathKey,
            instructions: []
          })
        ],
        "after",
        ["fields", -1]
      )
    )), ((_a = existingField == null ? void 0 : existingField.instructions) == null ? void 0 : _a.length) || (event = event.append([setIfMissing([], ["fields", { _key: pathKey }, "instructions"])])), (missingPresetInstructions == null ? void 0 : missingPresetInstructions.length) && (event = event.append(
      insert$1(
        missingPresetInstructions.map(
          (preset) => {
            var _a2;
            return {
              ...preset,
              _type: "sanity.assist.instruction",
              prompt: (_a2 = preset.prompt) == null ? void 0 : _a2.map((p) => ({ markDefs: [], ...p }))
            };
          }
        ),
        "after",
        ["fields", { _key: pathKey }, "instructions", -1]
      )
    )), onChange(event), initialized.current = true;
  }, [activePath, onChange, pathKey, existingField, missingPresetInstructions]), null;
}
function FieldRefPreview(props) {
  var _a, _b;
  const { actions } = props, documentSchema = (_a = (0, import_react.useContext)(SelectedFieldContext)) == null ? void 0 : _a.documentSchema, path = ((_b = (0, import_react.useContext)(InlineBlockValueContext)) == null ? void 0 : _b.path) ?? props.path, selectedField = useSelectedField(documentSchema, path);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, align: "center", style: { width: "100%" }, children: [
    (0, import_jsx_runtime.jsx)(Flex, { flex: 1, gap: 2, align: "center", paddingY: 3, paddingX: 1, children: (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", children: (selectedField == null ? void 0 : selectedField.title) ?? "Select field" }) }) }),
    actions
  ] });
}
function HiddenFieldTitle(props) {
  return props.renderDefault({ ...props, title: "", level: props.level - 2, changed: false });
}
function InstructionVisibility(props) {
  const { value, onChange } = props, user = useCurrentUser(), handleChange = (0, import_react.useCallback)(() => {
    const newValue = value ? "" : (user == null ? void 0 : user.id) ?? "";
    onChange(newValue ? set(newValue) : unset());
  }, [onChange, user, value]), id = (0, import_react.useId)();
  return (0, import_jsx_runtime.jsx)(Card, { children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, align: "flex-start", children: [
    (0, import_jsx_runtime.jsx)("div", { style: { margin: "-3px 0" }, children: (0, import_jsx_runtime.jsx)(
      Switch,
      {
        ...props.elementProps,
        id,
        value: `${!value}`,
        checked: !value,
        onChange: handleChange,
        disabled: props.elementProps.readOnly
      }
    ) }),
    (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, weight: "medium", children: (0, import_jsx_runtime.jsx)("label", { htmlFor: id, children: "Make visible to all Studio members" }) })
  ] }) });
}
function FieldRefPathInput(props) {
  var _a;
  const documentSchema = (_a = (0, import_react.useContext)(SelectedFieldContext)) == null ? void 0 : _a.documentSchema, { typePath } = (0, import_react.useContext)(AssistTypeContext), ref = (0, import_react.useRef)(null), id = (0, import_react.useId)(), { onChange } = props;
  (0, import_react.useEffect)(() => {
    var _a2, _b;
    (_b = (_a2 = ref.current) == null ? void 0 : _a2.querySelector("input")) == null ? void 0 : _b.focus();
  }, []);
  const onSelect = (0, import_react.useCallback)((path) => onChange(set(path)), [onChange]), filter22 = (0, import_react.useCallback)(
    (field) => {
      if (!field.key.includes("|") || !typePath)
        return true;
      if (field.key.includes("|") && !typePath.includes("|"))
        return false;
      const fieldSegments = field.key.split("."), lastArrayItemIndex = fieldSegments.findLastIndex((s) => s.includes("|")), mustStartWith = fieldSegments.slice(0, lastArrayItemIndex + 1).join(".");
      return typePath.startsWith(mustStartWith);
    },
    [typePath]
  );
  return documentSchema ? (0, import_jsx_runtime.jsx)(Box, { flex: 1, style: { minWidth: 300 }, ref, children: (0, import_jsx_runtime.jsx)(
    FieldAutocomplete,
    {
      id,
      schemaType: documentSchema,
      onSelect,
      fieldPath: props.value,
      filter: filter22
    }
  ) }) : props.renderDefault(props);
}
function findFieldMember(members, fieldName) {
  return members.find(
    (m) => m.kind === "field" && m.name === fieldName || m.kind === "error" && m.fieldName === fieldName
  );
}
function findFieldsetMember(members, fieldsetName) {
  return members.find(
    (m) => m.kind === "fieldSet" && m.fieldSet.name === fieldsetName
  );
}
function InstructionInput(props) {
  return (0, import_jsx_runtime.jsxs)(Stack, { space: [4, 4, 4, 5], children: [
    (0, import_jsx_runtime.jsx)(NameField, { ...props }),
    (0, import_jsx_runtime.jsx)(ShareField, { ...props }),
    (0, import_jsx_runtime.jsx)(ObjectMember, { fieldName: "prompt", ...props }),
    (0, import_jsx_runtime.jsx)(ObjectMember, { fieldName: "output", ...props })
  ] });
}
function ObjectMember({ fieldName, ...props }) {
  const member = findFieldMember(props.members, fieldName);
  return member ? (0, import_jsx_runtime.jsx)(ObjectInputMember, { ...props, member }) : null;
}
var NONE = [];
function NameField(props) {
  const fieldsetMember = findFieldsetMember(props.members, "appearance"), titleId = (0, import_react.useId)(), members = (fieldsetMember == null ? void 0 : fieldsetMember.fieldSet.members) ?? NONE, iconMember = findFieldMember(members, "icon"), titleMember = findFieldMember(members, "title"), titlePlaceholder = "Untitled", moddedTitleMember = (0, import_react.useMemo)(() => {
    if (titleMember)
      return titleMember.kind === "error" ? titleMember : {
        ...titleMember,
        field: {
          ...titleMember == null ? void 0 : titleMember.field,
          schemaType: {
            ...titleMember == null ? void 0 : titleMember.field.schemaType,
            placeholder: titlePlaceholder
          }
        }
      };
  }, [titleMember, titlePlaceholder]);
  return (0, import_jsx_runtime.jsx)(Stack, { space: 5, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
    (0, import_jsx_runtime.jsx)(Flex, { gap: 1, children: (0, import_jsx_runtime.jsx)(Text, { as: "label", weight: "semibold", size: 1, htmlFor: titleId, children: "Name" }) }),
    (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: "How this instruction appears in menus" }),
    (0, import_jsx_runtime.jsxs)(Flex, { align: "center", children: [
      iconMember && (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(ObjectInputMember, { ...props, member: iconMember }) }),
      moddedTitleMember && (0, import_jsx_runtime.jsx)(Box, { flex: 1, style: { marginLeft: -1 }, children: (0, import_jsx_runtime.jsx)(ObjectInputMember, { ...props, member: moddedTitleMember }) })
    ] })
  ] }) });
}
function ShareField(props) {
  var _a;
  const members = ((_a = findFieldsetMember(props.members, "appearance")) == null ? void 0 : _a.fieldSet.members) ?? NONE, visibilityMember = findFieldMember(members, "userId");
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: visibilityMember && (0, import_jsx_runtime.jsx)(ObjectInputMember, { ...props, member: visibilityMember }) });
}
function InstructionOutputField(props) {
  const { fieldSchema } = (0, import_react.useContext)(SelectedFieldContext) ?? {};
  return !fieldSchema || !(isObjectSchemaType(fieldSchema) || isArrayOfObjectsSchemaType(fieldSchema)) ? null : (0, import_jsx_runtime.jsx)(EnabledOutputField, { ...props, fieldSchema, children: props.children });
}
function EnabledOutputField({
  fieldSchema,
  ...props
}) {
  var _a;
  const [open, setOpen] = (0, import_react.useState)(!!((_a = props.value) == null ? void 0 : _a.length)), onExpand = (0, import_react.useCallback)(() => setOpen(true), []), onCollapse = (0, import_react.useCallback)(() => setOpen(false), []);
  return props.renderDefault({
    ...props,
    collapsible: true,
    onExpand,
    onCollapse,
    collapsed: !open,
    level: 1,
    title: isObjectSchemaType(fieldSchema) ? "Allowed fields" : "Allowed types"
  });
}
function InstructionOutputInput(props) {
  const { fieldSchema } = (0, import_react.useContext)(SelectedFieldContext) ?? {};
  return fieldSchema ? isObjectSchemaType(fieldSchema) ? (0, import_jsx_runtime.jsx)(ObjectOutputInput, { ...props, fieldSchema }) : isArrayOfObjectsSchemaType(fieldSchema) ? (0, import_jsx_runtime.jsx)(ArrayOutputInput, { ...props, fieldSchema }) : null : null;
}
function useEmptySelectAllValue(value, allowedValues, onChange) {
  (0, import_react.useEffect)(() => {
    const validValues = value == null ? void 0 : value.filter(
      (v) => allowedValues.find(
        (f) => f.name === (v._type === outputFieldTypeName ? v.relativePath : v.type)
      )
    ), valueLength = (value == null ? void 0 : value.length) ?? 0, validLength = (validValues == null ? void 0 : validValues.length) ?? 0;
    (!validLength && valueLength || validLength >= allowedValues.length) && onChange(PatchEvent.from([unset()]));
  }, [allowedValues, value, onChange]);
}
function ObjectOutputInput({
  fieldSchema,
  ...props
}) {
  const { value, onChange } = props, fields = (0, import_react.useMemo)(
    () => fieldSchema.fields.filter((field) => isAssistSupported(field.type)),
    [fieldSchema.fields]
  );
  useEmptySelectAllValue(value, fields, onChange);
  const onSelectChange = (0, import_react.useCallback)(
    (checked, selectedValue) => {
      if (checked)
        if (value == null ? void 0 : value.length)
          onChange(PatchEvent.from(unset([{ _key: selectedValue }])));
        else {
          const items = fields.filter((f) => f.name !== selectedValue).map(
            (field) => typed({
              _key: field.name,
              _type: "sanity.assist.output.field",
              relativePath: field.name
            })
          );
          onChange(PatchEvent.from([setIfMissing([]), insert$1(items, "after", [-1])]));
        }
      else {
        const patchValue = {
          _key: selectedValue,
          _type: "sanity.assist.output.field",
          relativePath: selectedValue
        };
        onChange(PatchEvent.from([setIfMissing([]), insert$1([patchValue], "after", [-1])]));
      }
    },
    [onChange, value, fields]
  );
  return (0, import_jsx_runtime.jsx)(Stack, { space: 2, children: fields.map((field) => (0, import_jsx_runtime.jsx)(Flex, { align: "center", gap: 2, children: (0, import_jsx_runtime.jsx)(
    Selectable,
    {
      value: field.name,
      title: field.type.title ?? field.name,
      arrayValue: value,
      onChange: onSelectChange
    }
  ) }, field.name)) });
}
function ArrayOutputInput({
  fieldSchema,
  ...props
}) {
  const { value, onChange } = props, ofItems = (0, import_react.useMemo)(
    () => fieldSchema.of.filter((itemType) => isAssistSupported(itemType)),
    [fieldSchema.of]
  );
  useEmptySelectAllValue(value, ofItems, onChange);
  const onSelectChange = (0, import_react.useCallback)(
    (checked, selectedValue) => {
      if (checked)
        if (value == null ? void 0 : value.length)
          onChange(PatchEvent.from(unset([{ _key: selectedValue }])));
        else {
          const items = ofItems.filter((f) => f.name !== selectedValue).map(
            (field) => typed({
              _key: field.name,
              _type: "sanity.assist.output.type",
              type: field.name
            })
          );
          onChange(PatchEvent.from([setIfMissing([]), insert$1(items, "after", [-1])]));
        }
      else {
        const patchValue = {
          _key: selectedValue,
          _type: "sanity.assist.output.type",
          type: selectedValue
        };
        onChange(PatchEvent.from([setIfMissing([]), insert$1([patchValue], "after", [-1])]));
      }
    },
    [onChange, value, ofItems]
  );
  return (0, import_jsx_runtime.jsx)(Stack, { space: 2, children: ofItems.map((itemType) => (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsx)(
    Selectable,
    {
      value: itemType.name,
      title: isType(itemType, "block") ? "Text" : itemType.title ?? itemType.name,
      arrayValue: value,
      onChange: onSelectChange
    }
  ) }, itemType.name)) });
}
function Selectable({
  title,
  arrayValue,
  value,
  onChange
}) {
  const checked = !(arrayValue == null ? void 0 : arrayValue.length) || !!(arrayValue == null ? void 0 : arrayValue.find((v) => v._key === value)), handleChange = (0, import_react.useCallback)(() => onChange(checked, value), [onChange, checked, value]);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, align: "flex-start", children: [
    (0, import_jsx_runtime.jsx)(Checkbox, { checked, onChange: handleChange }),
    (0, import_jsx_runtime.jsx)(Card, { marginTop: 1, onClick: handleChange, children: (0, import_jsx_runtime.jsx)(Text, { style: { cursor: "default" }, size: 1, children: title }) })
  ] });
}
var PteMods = dt(Box)`
  & [data-testid='pt-editor__toolbar-card'] > div > div:last-child {
    display: none;
  }
  & [data-testid='pt-editor'] {
    min-height: 300px;
  }
  & [data-testid='pt-editor'] .pt-inline-object * {
    max-width: 400px;
  }
`;
function PromptInput(props) {
  return useOnlyInlineBlocks(props), (0, import_jsx_runtime.jsx)(PteMods, { children: props.renderDefault(props) });
}
function useOnlyInlineBlocks(props) {
  (0, import_react.useEffect)(() => {
    let needsFix = false;
    const val = (props.value ?? []).map((block) => block._type === "block" ? block : (needsFix = true, typed({
      _key: randomKey(12),
      _type: "block",
      level: 0,
      markDefs: [],
      style: "normal",
      children: [block]
    })));
    needsFix && props.onChange(set(val));
  }, []);
}
function InstructionsArrayField(props) {
  return props.renderDefault({
    ...props,
    title: " "
  });
}
function InstructionsArrayInput(props) {
  const user = useCurrentUser(), originalValue = props.value, originalMembers = props.members, value = (0, import_react.useMemo)(
    () => (originalValue ?? []).filter((v) => !v.userId || v.userId === (user == null ? void 0 : user.id)),
    [originalValue, user]
  ), members = (0, import_react.useMemo)(
    () => (originalMembers ?? []).filter((v) => {
      var _a;
      if (v.kind === "error")
        return true;
      const value2 = (_a = v == null ? void 0 : v.item) == null ? void 0 : _a.value;
      return !value2.userId || value2.userId === (user == null ? void 0 : user.id);
    }),
    [originalMembers, user]
  );
  return props.renderDefault({ ...props, value, members });
}
function HideReferenceChangedBannerInput(props) {
  const ref = (0, import_react.useRef)(null);
  return (0, import_react.useEffect)(() => {
    var _a;
    const parent2 = (_a = ref.current) == null ? void 0 : _a.closest('[data-testid="pane-content"]');
    if (!parent2)
      return;
    const style = document.createElement("style"), parentId = `id-${Math.random()}`.replace(".", "-");
    parent2.id = parentId, style.innerText = `
      #${parentId} [data-testid="reference-changed-banner"] { display: none; }
    `, parent2.prepend(style);
  }, [ref]), (0, import_jsx_runtime.jsx)(Box, { ref, children: props.renderDefault(props) });
}
var contextDocumentSchema = defineType({
  type: "document",
  name: contextDocumentTypeName,
  title: "AI context",
  liveEdit: true,
  icon: TokenIcon,
  components: {
    input: HideReferenceChangedBannerInput
  },
  fields: [
    defineField({
      type: "string",
      name: "title",
      title: "Title"
    }),
    defineField({
      name: "context",
      type: "array",
      title: "Context",
      of: [
        defineArrayMember({
          type: "block",
          styles: [{ title: "Normal", value: "normal" }],
          lists: [],
          marks: {
            decorators: [],
            annotations: []
          }
        })
      ]
    })
  ],
  preview: {
    select: {
      title: "title",
      context: "context"
    },
    prepare({ title, context }) {
      var _a;
      const words2 = ((_a = context == null ? void 0 : context.flatMap((block) => block == null ? void 0 : block.children).flatMap((child) => {
        var _a2;
        return (_a2 = child == null ? void 0 : child.text) == null ? void 0 : _a2.split(" ");
      }).filter(Boolean)) == null ? void 0 : _a.length) ?? 0;
      return {
        title,
        subtitle: `Words: ${words2}`,
        media: DocumentTextIcon
      };
    }
  }
});
var fieldReference = defineType({
  type: "object",
  name: fieldReferenceTypeName,
  title: "Field",
  icon: ThListIcon,
  fields: [
    defineField({
      type: "string",
      name: "path",
      title: "Field",
      components: {
        input: FieldRefPathInput
      },
      validation: (rule) => {
        const getForSchemaType = createFieldRefCache();
        return rule.custom((value, context) => {
          var _a;
          if (!value)
            return "Please select a field";
          try {
            const docId = (_a = context.document) == null ? void 0 : _a._id;
            if (!docId)
              return "Field reference cannot be used outside document inspector context. Could not resolve document id.";
            const targetDocType = docId.replace(new RegExp(`^${assistDocumentIdPrefix}`), ""), schema = context.schema.get(targetDocType);
            if (!schema)
              return `Field reference cannot be used outside document inspector context. Could not resolve schema: ${targetDocType}`;
            const { fieldRefs } = getForSchemaType(schema);
            return fieldRefs.find((r) => r.key === value) ? true : `Field with path "${value}" does not exist in the schema.`;
          } catch (e) {
            return console.error("Failed to resolve field reference", e), "Invalid field reference.";
          }
        });
      }
    })
  ],
  preview: {
    select: {
      path: "path"
    },
    prepare({ path }) {
      return {
        title: path,
        path,
        icon: CodeIcon
      };
    }
  },
  components: {
    preview: FieldRefPreview
  },
  options: {
    modal: {
      type: "popover"
    }
  }
});
var userInput = defineType({
  type: "object",
  name: userInputTypeName,
  title: "User input",
  icon: ComposeIcon,
  fields: [
    defineField({
      type: "string",
      name: "message",
      title: "User input title",
      placeholder: "Provide instruction text",
      description: "The header above the user input text field",
      validation: (rule) => rule.required()
    }),
    defineField({
      type: "text",
      rows: 3,
      name: "description",
      title: "User input description",
      description: "The description above the user input text field"
    })
  ],
  preview: {
    select: {
      title: "message"
    }
  },
  options: {
    modal: {
      type: "popover",
      width: 1
    }
  }
});
var promptContext = defineType({
  type: "object",
  name: instructionContextTypeName,
  title: contextDocumentSchema.title,
  icon: contextDocumentSchema.icon,
  fields: [
    defineField({
      type: "reference",
      name: "reference",
      to: [{ type: contextDocumentSchema.name }],
      title: "Context",
      description: "The referenced context will be inserted into the instruction",
      validation: (rule) => rule.required(),
      components: {
        input: function(props) {
          return (0, import_jsx_runtime.jsx)(Box, { style: { maxWidth: 300 }, children: props.renderDefault(props) });
        }
      }
    })
  ],
  preview: {
    select: {
      ref: "reference._ref",
      title: "reference.title",
      context: "reference.context"
    },
    prepare(select) {
      var _a, _b;
      return select.ref ? ((_b = (_a = contextDocumentSchema == null ? void 0 : contextDocumentSchema.preview) == null ? void 0 : _a.prepare) == null ? void 0 : _b.call(_a, select)) ?? select : { title: "No reference selected", media: contextDocumentSchema.icon };
    }
  },
  options: {
    modal: {
      type: "popover",
      width: "auto"
    }
  }
});
var prompt = defineType({
  type: "array",
  name: promptTypeName,
  title: "Prompt",
  of: [
    defineArrayMember({
      type: "block",
      styles: [{ title: "Normal", value: "normal" }],
      lists: [],
      marks: {
        decorators: [],
        annotations: []
      },
      of: [
        defineArrayMember({
          type: fieldReference.name
        }),
        defineArrayMember({
          type: promptContext.name
        }),
        defineArrayMember({
          type: userInput.name
        })
      ]
    })
    /*    defineArrayMember({
      type: fieldReference.name,
    }),
    defineArrayMember({
      type: promptContext.name,
    }),
    defineArrayMember({
      type: userInput.name,
    }),*/
  ]
});
var outputFieldType = defineType({
  type: "object",
  name: outputFieldTypeName,
  title: "Output field",
  fields: [
    defineField({
      type: "string",
      name: "path",
      title: "Path"
    })
  ]
});
var outputTypeType = defineType({
  type: "object",
  name: outputTypeTypeName,
  title: "Output type",
  fields: [
    defineField({
      type: "string",
      name: "type",
      title: "Type"
    })
  ]
});
var instruction = defineType({
  type: "object",
  name: instructionTypeName,
  title: "Instruction",
  fieldsets: [
    { name: "appearance", title: "Appearance", options: { collapsible: true, collapsed: true } }
  ],
  preview: {
    select: {
      icon: "icon",
      title: "title",
      userId: "userId"
    },
    prepare: ({ icon, title, userId }) => ({
      title,
      icon: icon ? icons[icon] : SparklesIcon,
      userId
    })
  },
  components: {
    input: InstructionInput,
    preview: (props) => (0, import_jsx_runtime.jsxs)(Flex, { gap: 3, align: "center", padding: 2, children: [
      props.icon && (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_react.createElement)(props.icon) }) }),
      (0, import_jsx_runtime.jsx)(Stack, { flex: 1, space: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", weight: "medium", children: getInstructionTitle(props) }) }),
      props.userId && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(
        Tooltip,
        {
          content: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: "Only visible to you" }),
          padding: 2,
          placement: "top",
          portal: true,
          children: (0, import_jsx_runtime.jsx)(LockIcon, {})
        }
      ) })
    ] })
  },
  fields: [
    defineField({
      type: prompt.name,
      name: "prompt",
      title: "Instruction",
      description: (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        "Learn from",
        " ",
        (0, import_jsx_runtime.jsxs)("a", { href: instructionGuideUrl, target: "_blank", rel: "noreferrer", children: [
          "our instruction guide ",
          (0, import_jsx_runtime.jsx)(ArrowRightIcon, {})
        ] })
      ] }),
      components: {
        input: PromptInput
      }
    }),
    defineField({
      type: "string",
      name: "icon",
      title: "Icon",
      fieldset: "appearance",
      components: {
        field: HiddenFieldTitle,
        input: IconInput
      }
    }),
    defineField({
      type: "string",
      name: "title",
      title: "Title",
      fieldset: "appearance",
      components: {
        field: HiddenFieldTitle
      }
    }),
    defineField({
      type: "string",
      name: "userId",
      title: "Visibility",
      fieldset: "appearance",
      components: {
        field: HiddenFieldTitle,
        input: InstructionVisibility
      },
      initialValue: (params, context) => {
        var _a;
        return ((_a = context.currentUser) == null ? void 0 : _a.id) ?? "";
      },
      readOnly: (context) => {
        var _a, _b, _c;
        return !!(((_a = context.parent) == null ? void 0 : _a.createdById) && ((_b = context.parent) == null ? void 0 : _b.createdById) !== ((_c = context.currentUser) == null ? void 0 : _c.id));
      }
    }),
    defineField({
      type: "string",
      name: "createdById",
      title: "Created by",
      hidden: true,
      fieldset: "appearance",
      initialValue: (params, context) => {
        var _a;
        return ((_a = context.currentUser) == null ? void 0 : _a.id) ?? "";
      }
    }),
    defineField({
      type: "array",
      name: "output",
      title: "Output filter",
      components: {
        input: InstructionOutputInput,
        field: InstructionOutputField
      },
      of: [
        defineArrayMember({ type: outputFieldType.name }),
        defineArrayMember({ type: outputTypeType.name })
      ]
    })
  ]
});
var fieldInstructions = defineType({
  type: "object",
  name: assistFieldTypeName,
  title: "Field prompt",
  /*  components: {
    input: FieldPromptInput,
  },*/
  fields: [
    defineField({
      type: "string",
      name: "path",
      title: "Path",
      readOnly: true,
      hidden: true
    }),
    defineField({
      type: "array",
      name: "instructions",
      title: "Instructions",
      of: [{ type: instruction.name }],
      components: {
        field: InstructionsArrayField,
        input: InstructionsArrayInput
      }
    })
  ],
  preview: {
    select: {
      title: "path"
    }
  }
});
var assistDocumentSchema = defineType({
  //NOTE: this is a document type. Using object here ensures it does not appear in structure menus
  type: "object",
  liveEdit: true,
  name: assistDocumentTypeName,
  title: "AI Document",
  components: {
    input: AssistDocumentForm,
    field: (props) => props.renderDefault({ ...props, title: "" })
  },
  fields: [
    defineField({
      type: "string",
      name: "title",
      title: "Title"
    }),
    defineField({
      type: "array",
      name: "fields",
      title: "Fields",
      of: [{ type: fieldInstructions.name }]
    })
  ],
  preview: {
    select: {
      title: "title"
    }
  }
});
var instructionTask = defineType({
  type: "object",
  name: instructionTaskTypeName,
  title: "Instruction task",
  fields: [
    defineField({
      type: "string",
      name: "path",
      title: "Path"
    }),
    defineField({
      type: "string",
      name: "instructionKey",
      title: "Instruction key"
    }),
    defineField({
      type: "datetime",
      name: "started",
      title: "Started"
    }),
    defineField({
      type: "datetime",
      name: "updated",
      title: "Updated"
    }),
    defineField({
      type: "string",
      name: "info",
      title: "Info"
    })
  ]
});
var documentInstructionStatus = defineType({
  //NOTE: this is a document type. Using object here ensures it does not appear in structure menus
  type: "object",
  liveEdit: true,
  name: assistTasksStatusTypeName,
  title: "Document instruction status",
  fields: [
    defineField({
      type: "array",
      name: "tasks",
      title: "Tasks",
      of: [{ type: instructionTask.name }]
    })
  ]
});
function excludeComments(type) {
  var _a, _b, _c;
  const existingRender = (_a = type == null ? void 0 : type.components) == null ? void 0 : _a.field;
  return {
    ...type,
    ..."components" in type ? {
      components: {
        ...type.components,
        field: (props) => {
          const newProps = { ...props, __internal_comments: void 0 };
          return typeof existingRender == "function" ? existingRender(newProps) : props.renderDefault(newProps);
        }
      }
    } : {},
    ..."fields" in type ? {
      // recursively disable comments in fields
      fields: (_b = type.fields) == null ? void 0 : _b.map((field) => excludeComments(field))
    } : {},
    ..."of" in type ? {
      // recursively disable comments in array items
      of: (_c = type.of) == null ? void 0 : _c.map((arrayItemType) => excludeComments(arrayItemType))
    } : {}
  };
}
var instructionForm = [
  fieldInstructions,
  instruction,
  fieldReference,
  prompt,
  userInput,
  promptContext
].map(excludeComments);
var schemaTypes = [
  ...instructionForm,
  outputFieldType,
  outputTypeType,
  assistDocumentSchema,
  documentInstructionStatus,
  instructionTask,
  contextDocumentSchema
];
var assist = definePlugin((config) => {
  var _a, _b, _c;
  const configWithDefaults = config ?? {}, styleguide = ((_a = configWithDefaults.translate) == null ? void 0 : _a.styleguide) || "", maxPathDepth = (_b = configWithDefaults.assist) == null ? void 0 : _b.maxPathDepth, temperature = (_c = configWithDefaults.assist) == null ? void 0 : _c.temperature;
  if (typeof styleguide == "string" && validateStyleguide(styleguide), maxPathDepth !== void 0 && (maxPathDepth < 1 || maxPathDepth > 12))
    throw new Error(
      `[${packageName}]: \`assist.maxPathDepth\` must be be in the range [1,12] inclusive, but was ${maxPathDepth}`
    );
  if (temperature !== void 0 && (temperature < 0 || temperature > 1))
    throw new Error(
      `[${packageName}]: \`assist.maxPathDepth\` must be be in the range [0,1] inclusive, but was ${temperature}`
    );
  return {
    name: packageName,
    handlesGDR: true,
    schema: {
      types: schemaTypes
    },
    i18n: {
      bundles: [{}]
    },
    document: {
      inspectors: (prev, context) => {
        const documentType = context.documentType, docSchema = context.schema.get(documentType);
        return docSchema && isSchemaAssistEnabled(docSchema) ? [...prev, assistInspector] : prev;
      },
      unstable_fieldActions: (prev, { documentType, schema }) => {
        if (documentType === assistDocumentTypeName)
          return [];
        const docSchema = schema.get(documentType);
        return docSchema && isSchemaAssistEnabled(docSchema) ? [...prev, assistFieldActions] : prev;
      },
      unstable_languageFilter: (prev, { documentId, schema, schemaType }) => {
        if (schemaType === assistDocumentTypeName)
          return [];
        const docSchema = schema.get(schemaType);
        return docSchema && isObjectSchemaType(docSchema) && isSchemaAssistEnabled(docSchema) ? [...prev, createAssistDocumentPresence(documentId)] : prev;
      },
      components: {
        unstable_layout: AssistDocumentLayout
      }
    },
    studio: {
      components: {
        layout: function(props) {
          return (0, import_jsx_runtime.jsx)(AssistLayout, { ...props, config: configWithDefaults });
        }
      }
    },
    form: {
      components: {
        input: AssistDocumentInputWrapper,
        field: AssistFieldWrapper,
        item: AssistItem,
        block: AssistFormBlock,
        inlineBlock: AssistInlineFormBlock
      }
    },
    plugins: [
      definePlugin({
        name: `${packageName}/safe-value-input`,
        form: { components: { input: SafeValueInput } }
      })(),
      definePlugin({
        name: `${packageName}/generate-caption`,
        form: {
          components: {
            input: (props) => {
              const { schemaType } = props;
              return isImage(schemaType) ? (0, import_jsx_runtime.jsx)(ImageContextProvider, { ...props }) : props.renderDefault(props);
            }
          }
        }
      })()
    ]
  };
});
var fetch = (client, query, params, options2) => defer(
  () => (
    // getVersionedClient(options.apiVersion)
    client.observable.fetch(query, params, {
      tag: options2.tag,
      filterResponse: true
    })
  )
);
var listen = (client, query, params, options2) => defer(
  () => (
    // getVersionedClient(options.apiVersion)
    client.listen(query, params, {
      events: ["welcome", "mutation", "reconnect"],
      includeResult: false,
      visibility: "query",
      tag: options2.tag
    })
  )
);
function isWelcomeEvent(event) {
  return event.type === "welcome";
}
var listenQuery = (client, query, params = {}, options2 = {}) => {
  const fetchQuery = query, listenerQuery = query, fetchOnce$ = fetch(client, fetchQuery, params, options2), events$ = listen(client, listenerQuery, params, options2).pipe(
    mergeMap((ev, i) => i === 0 && !isWelcomeEvent(ev) ? throwError(
      new Error(
        ev.type === "reconnect" ? "Could not establish EventSource connection" : `Received unexpected type of first event "${ev.type}"`
      )
    ) : of(ev)),
    share()
  ), [welcome$, mutationAndReconnect$] = partition(events$, isWelcomeEvent), isRelevantEvent = (event) => !options2.transitions || event.type !== "mutation" ? true : options2.transitions.includes(event.transition);
  return merge(
    welcome$.pipe(take(1)),
    mutationAndReconnect$.pipe(
      filter(isRelevantEvent),
      switchMap((event) => merge(of(event), of(event).pipe(delay(options2.throttleTime || 1e3))))
    )
  ).pipe(exhaustMapToWithTrailing(fetchOnce$));
};
var DEFAULT_PARAMS = {};
var DEFAULT_OPTIONS = { apiVersion: "v2022-05-09" };
function useListeningQuery(query, params = DEFAULT_PARAMS, options2 = DEFAULT_OPTIONS) {
  const [loading, setLoading] = (0, import_react.useState)(true), [error, setError] = (0, import_react.useState)(false), [data, setData2] = (0, import_react.useState)(null), subscription = (0, import_react.useRef)(null), client = useClient({ apiVersion: "v2022-05-09" });
  return (0, import_react.useEffect)(() => (subscription.current = listenQuery(client, query, params, options2).pipe(
    distinctUntilChanged(import_react_fast_compare.default),
    catchError((err) => (console.error(err), setError(err), setLoading(false), setData2(null), err))
  ).subscribe((documents) => {
    setData2((current) => (0, import_react_fast_compare.default)(current, documents) ? current : documents), setLoading(false), setError(false);
  }), () => subscription.current ? subscription.current.unsubscribe() : void 0), [query, params, options2, client]), { loading, error, data };
}
var NO_DATA = [];
var defaultTitle = "Sync schema";
function SchemaTypeTool() {
  const schema = useSchema(), client = useClient({ apiVersion: "2023-01-01" }), [saving, setSaving] = (0, import_react.useState)(false), [syncTitle, setSyncTitle] = (0, import_react.useState)(defaultTitle), { data } = useListeningQuery("*[_type==$type] | order(_type)", {
    type: assistSerializedTypeName
  }), types = (0, import_react.useMemo)(() => serializeSchema(schema), [schema]), storeTypes = (0, import_react.useCallback)(() => {
    setSaving(true);
    let canSave = true;
    async function store() {
      setSyncTitle(`Syncing 0/${types.length}`);
      const transaction = client.transaction();
      for (let i = 0; i < types.length && canSave; i++) {
        const type = types[i];
        await transaction.createOrReplace(type), i > 0 && i % 50 === 0 && (await transaction.commit(), transaction.reset(), setSyncTitle(`Syncing ${i}/${types.length}`));
      }
      await transaction.commit();
    }
    return store().catch(console.error).finally(() => {
      setSaving(false), setSyncTitle(defaultTitle);
    }), () => {
      canSave = false, setSaving(false), setSyncTitle(defaultTitle);
    };
  }, [types, client, setSaving, setSyncTitle]);
  return (0, import_jsx_runtime.jsx)(Card, { padding: 4, overflow: "auto", style: { height: "calc(100vh - 81px)" }, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [
    (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(
      Button,
      {
        icon: saving ? (0, import_jsx_runtime.jsx)(Spinner, { style: { marginTop: 5 } }) : SyncIcon,
        text: syncTitle,
        disabled: saving,
        onClick: storeTypes
      }
    ) }),
    (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
      (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
        (0, import_jsx_runtime.jsx)(Label, { children: "Studio schema" }),
        (0, import_jsx_runtime.jsx)("ul", { children: types.map((type) => (0, import_jsx_runtime.jsx)("li", { children: (0, import_jsx_runtime.jsx)(SchemaEntry, { schemaStub: type }) }, type.name)) })
      ] }),
      (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [
        (0, import_jsx_runtime.jsx)(Label, { children: "Stored schema" }),
        (0, import_jsx_runtime.jsx)("ul", { children: (data ?? NO_DATA).map((type) => (0, import_jsx_runtime.jsx)("li", { children: (0, import_jsx_runtime.jsx)(SchemaEntry, { schemaStub: type }) }, type.name)) })
      ] })
    ] })
  ] }) });
}
function SchemaEntry({ schemaStub }) {
  const out = (0, import_react.useMemo)(() => JSON.stringify(schemaStub, null, 2), [schemaStub]);
  return (0, import_jsx_runtime.jsx)("pre", { children: out });
}
function useUserInput() {
  const { getUserInput } = useRunInstruction();
  return getUserInput;
}
export {
  SchemaTypeTool,
  assist,
  contextDocumentTypeName,
  defaultLanguageOutputs,
  defineAssistFieldAction,
  defineAssistFieldActionGroup,
  defineFieldActionDivider,
  isType,
  useUserInput
};
/*! Bundled license information:

lodash-es/lodash.default.js:
lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=@sanity_assist.js.map
